<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Warehouse</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600&display=swap');

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --accent-color: #003262;
        --secondary-color: #fdb515;
        --surface-color: rgba(255, 255, 255, 0.03);
        --glass-bg: rgba(255, 255, 255, 0.03);
        --card-border: rgba(255, 255, 255, 0.05);
        --hover-border: rgba(255, 255, 255, 0.1);
        --stanford-red: #8c1515;
        --stanford-grey: #4d4f53;
        --cal-blue: #003262;
        --cal-gold: #fdb515;
      }

      body {
        font-family: 'Plus Jakarta Sans', sans-serif;
        background: #0a0a0b;
        color: #fff;
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
      }

      .app-container {
        display: flex;
        min-height: 100vh;
        backdrop-filter: blur(100px);
        position: relative;
        overflow-x: hidden;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 40px;
      }

      .header h1 {
        font-size: 36px;
        font-weight: 600;
        color: var(--cal-gold);  /* Remove gradient text */
        margin-bottom: 12px;
      }

      .new-app-btn {
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        background: var(--accent-color);
        color: #fff;
        border: none;
        transition: all 0.3s ease;
      }

      .new-app-btn:hover {
        opacity: 0.9;
        transform: translateY(-2px);
      }

      .sidebar {
        width: 300px;
        padding: 32px;
        background: var(--glass-bg);
        border-right: 1px solid var(--card-border);
        backdrop-filter: blur(20px);
      }

      .search-box {
        width: 100%;
        padding: 14px 20px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        color: #fff;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .category-list {
        list-style: none;
        margin-top: 32px;
      }

      .category-item {
        padding: 12px 16px;
        margin: 4px 0;
        cursor: pointer;
        border-radius: 12px;
        font-size: 14px;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.6);
      }

      .category-item.active {
        color: #fff;
        background: var(--glass-bg);
      }

      .main-content {
        flex: 1;
        padding: 40px;
      }

      .app-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
        gap: 24px;
      }

      .app-card {
        background: var(--surface-color);  /* Solid color instead of gradient */
        border: 1px solid var(--card-border);
        border-radius: 16px;
        overflow: hidden;
        transition: all 0.3s ease;
        position: relative;
        cursor: pointer;
      }

      .app-card:hover {
        transform: translateY(-2px);
        border-color: var(--hover-border);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      }

      .app-info {
        padding: 24px;
      }
      .app-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #fff;
      }

      .app-description {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 20px;
        line-height: 1.6;
      }

      .app-tags {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 24px;
      }

      .tag {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        background: var(--glass-bg);
        color: var(--cal-gold);
        border: 1px solid var(--card-border);
      }

      #createAppModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
      }

      .modal-content {
        position: relative;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1e1e1e;
        padding: 32px;
        border-radius: 16px;
        border: 1px solid var(--card-border);
        width: 90%;
        max-width: 500px;
      }

      .modal-header {
        margin-bottom: 24px;
      }

      .modal-title {
        font-size: 24px;
        color: #fff;
        margin-bottom: 8px;
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #fff;
      }

      .form-group input {
        width: 100%;
        padding: 12px;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .modal-btn {
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .modal-btn.cancel {
        background: transparent;
        border: 1px solid var(--card-border);
        color: #fff;
      }

      .modal-btn.create {
        background: var(--accent-color);
        border: none;
        color: #fff;
      }

      .modal-btn:hover {
        opacity: 0.9;
      }

      .tab-button {
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        background: var(--glass-bg);
        color: #fff;
        border: 1px solid var(--card-border);
        transition: all 0.3s ease;
      }

      .tab-button.active {
        background: var(--accent-color);
        border-color: transparent;
      }

      /* Prompt Styles */
      .tab-content {
        width: 100%;
      }

      #promptsTab {
        display: none;
      }

      .prompt-card:hover {
        border-color: var(--hover-border);
      }

      .prompt-select {
        width: 100%;
        padding: 12px;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        margin-bottom: 12px;
      }

      .prompt-output .output-content {
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        padding: 16px;
        white-space: pre-wrap;
        font-family: monospace;
        color: #fff;
      }

      .prompt-card label {
        font-size: 14px;
        font-weight: 500;
      }

      /* Fix modal styles */
      #createPromptModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
        overflow-y: auto;
        padding: 40px 20px;
      }

      #createPromptModal .modal-content {
        width: 95%;
        max-width: 800px;
        max-height: 90vh;  /* Limit modal height */
        overflow-y: auto;  /* Add scrolling if content is too tall */
        display: flex;
        flex-direction: column;
        padding: 32px;
        margin: 20px auto;  /* Add margin to prevent touching screen edges */
      }

      /* Make prompt select options visible */
      .prompt-select option {
        background: #1e1e1e;
        color: #fff;
      }
      .category-item {
        padding: 12px 16px;
        margin: 4px 0;
        cursor: pointer;
        border-radius: 12px;
        font-size: 14px;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.6);
        user-select: none; /* Prevent text selection */
      }

      .category-item.active {
        color: #fff;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
      }

      /* Content area styles */
      .content-section {
        display: none;
      }

      .content-section.active {
        display: block;
      }

      /* Grid container */
      #promptsList {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
        gap: 24px;
        width: 100%;
        padding: 20px;
      }

      .prompt-card:hover {
        border-color: var(--hover-border);
        transform: translateY(-2px);
      }

      /* Prompt card content */
      .prompt-card .app-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #fff;
      }

      .prompt-card .app-description {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 20px;
        line-height: 1.6;
      }

      .prompt-card .app-tags {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 24px;
      }

      /* Make prompt content areas more compact */
      .prompt-card .prompt-textarea {
        min-height: 80px;
        max-height: 200px;
        overflow-y: auto;
        width: 100%;
        padding: 12px;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        margin-bottom: 12px;
        resize: vertical;
      }

      /* Output area */
      .prompt-card .prompt-output {
        display: none;
        margin-top: 16px;
        max-height: 300px;
        overflow-y: auto;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        padding: 16px;
      }

      .prompt-card .output-content {
        white-space: pre-wrap;
        font-family: monospace;
        color: #fff;
      }
      #createPromptModal .modal-content {
        width: 95%;
        max-width: 800px;
        max-height: 90vh;  /* Limit modal height */
        overflow-y: auto;  /* Add scrolling if content is too tall */
        display: flex;
        flex-direction: column;
        padding: 32px;
        margin: 20px auto;  /* Add margin to prevent touching screen edges */
      }

      .prompt-textarea {
        width: 100%;
        resize: vertical;
        max-height: 400px;
        min-height: 200px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 16px;
        color: #fff;
        font-family: 'Plus Jakarta Sans', monospace;
        line-height: 1.5;
      }

      /* Make form take up available space */
      #createPromptModal .modal-content > div:not(.modal-buttons) {
        flex: 1;
      }

      /* Adjust spacing */
      #createPromptModal .form-group {
        margin-bottom: 24px;
      }

      /* Updated input and textarea styles to match dark theme */
      #createPromptModal input,
      #createPromptModal textarea,
      #createPromptModal select {
        width: 100%;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        color: #fff;
        font-size: 15px;
        padding: 12px 16px;
        transition: all 0.3s ease;
      }

      /* Specific styles for the prompt template textarea */
      #createPromptModal #promptText {
        min-height: 300px;
        height: 100%;
        line-height: 1.5;
        resize: vertical;
        margin-bottom: 24px;
        background: rgba(255, 255, 255, 0.03);
        font-family: 'Plus Jakarta Sans', sans-serif;
      }

      /* Description textarea specific styles */
      #createPromptModal #promptDescription {
        height: 60px;
        resize: vertical;
      }

      /* Hover and focus states */
      #createPromptModal input:hover,
      #createPromptModal textarea:hover,
      #createPromptModal select:hover,
      #createPromptModal input:focus,
      #createPromptModal textarea:focus,
      #createPromptModal select:focus {
        border-color: var(--hover-border);
        outline: none;
      }

      /* Style for placeholder text */
      #createPromptModal input::placeholder,
      #createPromptModal textarea::placeholder {
        color: rgba(255, 255, 255, 0.3);
      }
      .param-label {
        display: block;
        margin-bottom: 8px;
        color: #fff;
        font-size: 14px;
      }
      .prompt-card {
        background: var(--surface-gradient);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        padding: 24px;
        transition: all 0.3s ease;
      }

      .prompt-template {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 16px;
        margin: 16px 0;
        font-family: 'Plus Jakarta Sans', monospace;
        color: #a8b3cf;
        font-size: 15px;
        line-height: 1.5;
      }

      .prompt-template {
        min-height: 400px !important; /* Increased from 200px */
        max-height: 800px !important;
        resize: vertical;
        transition: all 0.3s ease;
        font-size: var(--prompt-font-size, 14px); /* Default font size with CSS variable */
      }

      .font-size-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
        color: #fff;
      }

      .font-size-controls button {
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        color: var(--cal-gold);
        width: 32px;
        height: 32px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .font-size-controls button:hover {
        background: var(--cal-blue);
        color: white;
      }

      .font-size-display {
        min-width: 60px;
        text-align: center;
        font-family: monospace;
      }

      .param-group {
        margin: 24px 0;
      }

      .param-input {
        width: 100%;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        color: #fff;
        font-size: 15px;
        padding: 14px 16px;
        transition: all 0.3s ease;
        margin-top: 8px;
      }

      .param-input:hover {
        border-color: var(--hover-border);
      }

      .param-input:focus {
        border-color: var(--cal-gold);
        outline: none;
        box-shadow: 0 0 0 2px rgba(253, 181, 21, 0.1);
      }

      .param-label {
        display: block;
        color: #a8b3cf;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 4px;
      }

      .run-prompt-btn {
        width: 100%;
        background: var(--accent-color);
        color: #fff;
        border: none;
        border-radius: 12px;
        padding: 14px 24px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 8px;
      }

      .run-prompt-btn:hover {
        opacity: 0.9;
        transform: translateY(-1px);
      }

      .run-prompt-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .prompt-output {
        margin-top: 24px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 16px;
      }

      .output-content {
        font-family: 'Plus Jakarta Sans', monospace;
        color: #a8b3cf;
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;
      }
      .prompt-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
        overflow-y: auto;
        padding: 40px 20px;
      }

      .prompt-modal-content {
        position: relative;
        background: #1e1e1e;
        border: 1px solid var(--card-border);
        border-radius: 20px;
        width: 90%;
        max-width: 900px;
        margin: 0 auto;
        padding: 32px;
        color: #fff;
      }

      .prompt-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 24px;
      }

      .prompt-modal-close {
        background: none;
        border: none;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        padding: 8px;
        margin: -8px;
        opacity: 0.7;
        transition: opacity 0.2s;
      }

      .prompt-modal-close:hover {
        opacity: 1;
      }

      .prompt-preview {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .prompt-preview:hover {
        transform: translateY(-2px);
        border-color: var(--hover-border);
      }
      .edit-delete-buttons {
        display: flex;
        gap: 8px;
        margin-top: 16px;
      }

      .edit-button {
        background: var(--cal-blue);
        color: white;
      }

      .edit-button,
      .delete-button {
        width: 24px;
        height: 24px;
        border-radius: 12px;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .app-card:hover .delete-button {
        opacity: 1;
      }

      .card-actions {
        position: absolute;
        top: 16px;
        right: 16px;
        display: flex;
        gap: 8px;
        opacity: 0;
        transition: all 0.2s ease;
      }

      .app-card:hover .card-actions {
        opacity: 1;
      }

      /* Make description textarea taller than input but shorter than prompt */
      #editPromptDescription {
        min-height: 80px;
        resize: vertical;
      }

      .edit-button {
        background: rgba(0, 50, 98, 0.1);
        color: var(--cal-blue);
      }

      .delete-button {
        background: rgba(140, 21, 21, 0.1);
        color: var(--stanford-red);
        font-size: 16px;
      }

      .edit-button:hover {
        background: var(--cal-blue);
        color: white;
        transform: scale(1.1);
      }

      .delete-button:hover {
        background: var(--stanford-red);
        color: white;
        transform: scale(1.1);
      }

      /* Make prompt textarea significantly larger */
      #editPromptText {
        min-height: 400px;
        resize: vertical;
        font-family: 'Plus Jakarta Sans', monospace;
        line-height: 1.6;
      }
      .version-select {
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        color: #fff;
        font-size: 14px;
        padding: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .version-select:hover {
        border-color: var(--hover-border);
      }

      .version-select option {
        background: #1e1e1e;
        color: #fff;
        padding: 8px;
      }
      .version-select-container {
        position: relative;
        width: 100%;
      }

      .version-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px;
        border-bottom: 1px solid var(--card-border);
      }

      .rollback-btn {
        opacity: 0.8;
        transition: all 0.2s ease;
      }

      .rollback-btn:hover {
        opacity: 1;
        transform: translateY(-1px);
      }

      .app-card:hover .delete-button {
        opacity: 1;
      }

      .delete-button:hover {
        background: var(--stanford-red);
        color: white;
        transform: scale(1.1);
      }

      .app-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #fff;
      }

      .app-description {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 20px;
        line-height: 1.6;
      }

      .app-tags {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tag {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        background: var(--glass-bg);
        color: var(--cal-gold);
        border: 1px solid var(--card-border);
      }

      .new-app-btn:hover,
      .modal-btn.create:hover,
      .run-prompt-btn:hover {
          background: #004280;  /* Slightly darker shade of accent color */
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 50, 98, 0.15);
      }

      /* Add smooth transitions */
      .new-app-btn,
      .modal-btn.create,
      .run-prompt-btn,
      .app-card {
          transition: all 0.2s ease-in-out;
      }

      /* Optional: Add subtle card hover effect */
      .app-card:hover {
          transform: translateY(-2px);
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
          border-color: rgba(255, 255, 255, 0.1);
      }

      .metadata-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
      }

      .metadata-modal-content {
        position: relative;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1e1e1e;
        padding: 32px;
        border-radius: 16px;
        border: 1px solid var(--card-border);
        width: 90%;
        max-width: 500px;
      }

      .category-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }

      .category-chip {
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        padding: 4px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .category-chip button {
        background: none;
        border: none;
        color: var(--stanford-red);
        cursor: pointer;
        padding: 0;
        font-size: 16px;
      }

      .add-category-input {
        width: 100%;
        padding: 12px;
        background: var(--glass-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        margin-top: 8px;
      }

      /* Add metadata button style */
      .metadata-button {
        background: var(--glass-bg);
        color: var(--cal-gold);
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .metadata-button:hover {
        background: var(--cal-gold);
        color: white;
        transform: scale(1.1);
      }

      /* Update the modal styles */
      #createPromptModal {
        z-index: 1100; /* Increase z-index */
      }

      /* Add styles for the select element and its options */
      #promptModel {
        position: relative;
        z-index: 1200; /* Higher than modal */
      }

      #promptModel option {
        position: relative;
        z-index: 1200; /* Match select z-index */
        background: #1e1e1e;
        color: #fff;
        padding: 8px;
      }

      /* Ensure modal content is above other elements */
      #createPromptModal .modal-content {
        position: relative;
        z-index: 1150; /* Between modal and select */
      }
    </style>
  </head>

  <body>
    <div class="app-container">
      <div class="sidebar">
        <input type="text" class="search-box" placeholder="Search..." />
        <ul class="category-list">
          <li class="category-item active" onclick="switchSection('apps')">
            Apps
          </li>
          <li class="category-item" onclick="switchSection('prompts')">
            Prompts
          </li>
        </ul>
      </div>

      <div class="main-content">
        <div class="header">
          <h1>Warehouse</h1>
          <div class="action-buttons">
            <!-- Buttons will be dynamically shown/hidden based on active section -->
            <button
              id="newAppBtn"
              class="new-app-btn"
              onclick="showCreateAppModal()"
            >
              New App
            </button>
            <button
              id="newPromptBtn"
              class="new-app-btn"
              onclick="showCreatePromptModal()"
              style="display: none"
            >
              New Prompt
            </button>
          </div>
        </div>

        <div id="appsSection" class="content-section active">
          <div class="app-grid" id="appGrid">
            <!-- Apps will be rendered here -->
          </div>
        </div>

        <div id="promptsSection" class="content-section">
          <div id="promptsList">
            <!-- Prompts will be rendered here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Create App Modal -->
    <div id="createAppModal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Create New App</h2>
        </div>
        <div class="form-group">
          <label for="appName">App Name</label>
          <input type="text" id="appName" placeholder="Enter app name" />
        </div>
        <div class="form-group">
          <label for="appDescription">Description</label>
          <input
            type="text"
            id="appDescription"
            placeholder="Enter app description"
          />
        </div>
        <div class="modal-buttons">
          <button class="modal-btn cancel" onclick="hideCreateAppModal()">
            Cancel
          </button>
          <button class="modal-btn create" onclick="createNewApp()">
            Create App
          </button>
        </div>
      </div>
    </div>
    <div id="createPromptModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Create New Prompt</h2>
        </div>
        <div class="form-group">
          <label for="promptAlias">Alias</label>
          <input type="text" id="promptAlias" placeholder="Enter prompt alias"/>
        </div>
        <div class="form-group">
          <label for="promptModel">Model</label>
          <select id="promptModel" class="prompt-select">
            <option value="deepseek-r1">deepseek-r1</option>
            <option value="claude-3-5-sonnet-latest">claude-3-5-sonnet</option>
            <option value="gpt-4o">gpt-4o</option>
            <option value="o1">o1</option>
            <option value="o3-mini-low">o3-mini-low</option>
            <option value="o3-mini-medium">o3-mini-medium</option>
            <option value="o3-mini-high">o3-mini-high</option>
            <option value="dall-e-3">dall-e-3</option>
          </select>
        </div>
        <div class="form-group">
          <label for="promptDescription">Description</label>
          <textarea id="promptDescription" placeholder="Enter prompt description"></textarea>
        </div>
        <div class="form-group">
          <label for="promptText">Prompt Template</label>
          <textarea id="promptText" class="prompt-textarea" placeholder="Enter prompt template. Use [[param]] for parameters."></textarea>
        </div>
        <div class="modal-buttons">
          <button class="modal-btn cancel" onclick="hideCreatePromptModal()">Cancel</button>
          <button class="modal-btn create" onclick="createNewPrompt()">Create Prompt</button>
        </div>
      </div>
    </div>

    <script>
      const API_BASE = '{{ DOMAIN }}';
      let apps = [];

      // Move all function definitions to the top
      function showCreateAppModal() {
        document.getElementById('createAppModal').style.display = 'block';
      }

      function hideCreateAppModal() {
        document.getElementById('createAppModal').style.display = 'none';
      }

      const helpers = {
        generateUUID: () => {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
            /[xy]/g,
            function (c) {
              const r = (Math.random() * 16) | 0;
              const v = c == 'x' ? r : (r & 0x3) | 0x8;
              return v.toString(16);
            }
          );
        },
      };

      const codeBlockHelpers = {
        generateCodeBlockId: () => helpers.generateUUID(),

        saveCodeBlock: async code => {
          const blockId = helpers.generateUUID();
          try {
            await fetch(`${API_BASE}/write`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                key: blockId,
                value: code, // Store HTML directly as the value
              }),
            });
            return blockId;
          } catch (error) {
            console.error('Error saving code block:', error);
            throw error;
          }
        },

        getCodeBlock: async blockId => {
          try {
            const response = await fetch(`${API_BASE}/read?key=${blockId}`);
            if (!response.ok) throw new Error('Failed to fetch code block');
            const data = await response.json();
            return data.value; // HTML is stored directly in value
          } catch (error) {
            console.error('Error fetching code block:', error);
            throw error;
          }
        },
      };

      async function createNewApp() {
        const name = document.getElementById('appName').value.trim();
        const description = document.getElementById('appDescription').value.trim();

        if (!name) {
          alert('Please enter an app name');
          return;
        }

        const uuid = helpers.generateUUID();
        const friendlyUrl = name.toLowerCase().replace(/[^a-z0-9]/g, '-');

        try {
          // First, read current warehouse data
          const warehouseResponse = await fetch(`${API_BASE}/read?key=warehouse-data`);
          if (!warehouseResponse.ok && warehouseResponse.status !== 404) {
            throw new Error('Failed to read warehouse data');
          }

          let warehouseData = [];
          if (warehouseResponse.ok) {
            const data = await warehouseResponse.json();
            warehouseData = data.value || [];
          }

          // Create initial code block
          const initialCode = ``;
          const initialCodeBlockId = await codeBlockHelpers.saveCodeBlock(initialCode);

          // Create the app data with categories array
          const appData = {
            name: name,
            description: description,
            uuid: uuid,
            friendly_url: friendlyUrl,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            current_code: initialCodeBlockId,
            current_version: 'v0',
            categories: [], // Initialize empty categories array
            versions: {
              v0: {
                code_block: initialCodeBlockId,
                timestamp: new Date().toISOString(),
                message: 'Initial version',
              },
            },
            editor_config: {
              language: 'html',
              theme: 'vs-dark',
              settings: {
                tabSize: 4,
                wordWrap: 'on',
              },
            },
          };

          // Save app data
          const appResponse = await fetch(`${API_BASE}/write`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              key: uuid,
              value: appData,
              app_name: friendlyUrl,
            }),
          });

          if (!appResponse.ok) throw new Error('Failed to create app');

          // Update warehouse data
          warehouseData.push(uuid);
          const warehouseUpdateResponse = await fetch(`${API_BASE}/write`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              key: 'warehouse-data',
              value: warehouseData,
            }),
          });

          if (!warehouseUpdateResponse.ok) throw new Error('Failed to update warehouse data');

          hideCreateAppModal();
          document.getElementById('appName').value = '';
          document.getElementById('appDescription').value = '';

          await loadApps();
          window.open(`${API_BASE}/app/editor?app=${uuid}`, '_blank');
        } catch (error) {
          console.error('Error creating app:', error);
          alert('Failed to create app: ' + error.message);
        }
      }

      async function loadApps() {
        try {
          const response = await fetch(`${API_BASE}/read?key=warehouse-data`);
          if (response.status === 404) {
            // Initialize warehouse if it doesn't exist
            await fetch(`${API_BASE}/write`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                key: 'warehouse-data',
                value: [], // Initialize with empty array
              }),
            });
            apps = [];
          } else if (!response.ok) {
            throw new Error('Failed to load apps');
          } else {
            const data = await response.json();
            apps = data.value || [];
          }

          // Fetch all app details in parallel
          const appDetails = await Promise.all(
            apps.map(async appId => {
              try {
                const appResponse = await fetch(
                  `${API_BASE}/read?key=${appId}`
                );
                if (!appResponse.ok) return null;
                const appData = await appResponse.json();
                return {
                  key: appId,
                  value: appData.value,
                };
              } catch (error) {
                console.error(`Error fetching app ${appId}:`, error);
                return null;
              }
            })
          );

          // Filter out any null responses from failed fetches
          apps = appDetails.filter(app => app !== null);
          renderApps();
        } catch (error) {
          console.error('Error loading apps:', error);
        }
      }

      function viewApp(friendlyUrl) {
        window.open(`${API_BASE}/app/${friendlyUrl}`, '_blank');
      }

      function renderApps() {
        const grid = document.getElementById('appGrid');
        grid.innerHTML = apps
          .map(app => {
            const value = app.value || {};
            const lastUpdate = value.updated_at
              ? new Date(value.updated_at).toLocaleDateString()
              : 'N/A';
            const currentVersion = value.current_version || 'v0';
            const versionCount = value.versions
              ? Object.keys(value.versions).length
              : 0;
            const categories = value.categories || [];

            return `
              <div class="app-card" onclick="viewApp('${value.friendly_url}')">
                <div class="card-actions">
                  <button 
                    class="metadata-button" 
                    onclick="event.stopPropagation(); showMetadataModal('${app.key}')"
                    aria-label="Edit metadata for ${value.name}"
                  >
                    <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M4.5 5.5C4.5 6.32843 3.82843 7 3 7C2.17157 7 1.5 6.32843 1.5 5.5C1.5 4.67157 2.17157 4 3 4C3.82843 4 4.5 4.67157 4.5 5.5ZM8.5 5.5C8.5 6.32843 7.82843 7 7 7C6.17157 7 5.5 6.32843 5.5 5.5C5.5 4.67157 6.17157 4 7 4C7.82843 4 8.5 4.67157 8.5 5.5ZM12.5 5.5C12.5 6.32843 11.8284 7 11 7C10.1716 7 9.5 6.32843 9.5 5.5C9.5 4.67157 10.1716 4 11 4C11.8284 4 12.5 4.67157 12.5 5.5Z" fill="currentColor"/>
                    </svg>
                  </button>
                  <button 
                    class="edit-button" 
                    onclick="event.stopPropagation(); openEditor('${app.key}')"
                    aria-label="Edit ${value.name}"
                  >
                    <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1464 1.14645L3.71573 8.57714C3.62521 8.66766 3.55228 8.77543 3.50051 8.89459L2.04817 12.252C1.9496 12.4491 2.00181 12.6835 2.14645 12.8281C2.29109 12.9728 2.52554 13.025 2.72263 12.9264L6.08004 11.4741C6.19919 11.4223 6.30697 11.3494 6.39748 11.2589L13.8282 3.82818C14.0235 3.63291 14.0235 3.31633 13.8282 3.12106L11.8536 1.14645ZM4.42111 9.28253L11.5 2.20364L12.771 3.47475L5.69223 10.5536L4.21927 11.0553L4.42111 9.28253Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path>
                    </svg>
                  </button>
                  <button 
                    class="edit-button" 
                    onclick="event.stopPropagation(); window.open('${API_BASE}/app/word-to-ai?uuid=${app.key}', '_blank')"
                    aria-label="Open Word to AI for ${value.name}"
                    style="margin-left: 4px;"
                  >
                    <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M3 2C2.44772 2 2 2.44772 2 3V12C2 12.5523 2.44772 13 3 13H12C12.5523 13 13 12.5523 13 12V8.5C13 8.22386 12.7761 8 12.5 8C12.2239 8 12 8.22386 12 8.5V12H3V3L6.5 3C6.77614 3 7 2.77614 7 2.5C7 2.22386 6.77614 2 6.5 2H3ZM12.8536 2.14645C12.9015 2.19439 12.9377 2.24964 12.9621 2.30861C12.9861 2.36669 12.9996 2.4303 13 2.497L13 2.5V2.50049V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V3.70711L6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355C5.95118 8.65829 5.95118 8.34171 6.14645 8.14645L11.2929 3H9.5C9.22386 3 9 2.77614 9 2.5C9 2.22386 9.22386 2 9.5 2H12.4999H12.5C12.5678 2 12.6324 2.01349 12.6914 2.03794C12.7504 2.06234 12.8056 2.09851 12.8536 2.14645Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"/>
                    </svg>
                  </button>
                  <button 
                    class="delete-button" 
                    onclick="event.stopPropagation(); deleteApp('${app.key}', '${value.name}')"
                    aria-label="Delete ${value.name}"
                  >×</button>
                </div>
                <div class="app-info">
                  <h3 class="app-title">${value.name || 'Unnamed App'}</h3>
                  <p class="app-description">${value.description || 'No description'}</p>
                  <div class="app-tags">
                    <span class="tag">Version ${currentVersion[1]}</span>
                    <span class="tag">${versionCount} versions</span>
                    <span class="tag">Updated ${lastUpdate}</span>
                    <span class="tag">${value.friendly_url}</span>
                    ${categories.map(category => `
                      <span class="tag">${category}</span>
                    `).join('')}
                  </div>
                </div>
              </div>
            `;
          })
          .join('');
      }
      async function openEditor(appKey) {
        try {
          // Get the app data to access the friendly URL
          const response = await fetch(`${API_BASE}/read?key=${appKey}`);
          if (!response.ok) throw new Error('Failed to fetch app data');
          const data = await response.json();
          const friendlyUrl = data.value.friendly_url;

          // Use the new URL format
          window.open(
            `${API_BASE}/app/editor?app=${data.value.uuid}`,
            '_blank'
          );
        } catch (error) {
          console.error('Error opening editor:', error);
          alert('Failed to open editor: ' + error.message);
        }
      }

      // Event Listeners
      document.querySelector('.search-box').addEventListener('input', e => {
        const searchTerm = e.target.value.toLowerCase();
        const activeSection = document.querySelector('.content-section.active');

        const cards = activeSection.querySelectorAll('.app-card, .prompt-card');
        cards.forEach(card => {
          const title = card
            .querySelector('.app-title')
            .textContent.toLowerCase();
          const description = card
            .querySelector('.app-description')
            .textContent.toLowerCase();
          const isVisible =
            title.includes(searchTerm) || description.includes(searchTerm);
          card.style.display = isVisible ? 'block' : 'none';
        });
      });

      window.onclick = function (event) {
        if (event.target == document.getElementById('createAppModal')) {
          hideCreateAppModal();
        }
      };

      window.addEventListener('click', e => {
        if (e.target.classList.contains('metadata-modal')) {
          const appKey = e.target.id.split('-')[1];
          hideMetadataModal(appKey);
        }
      });

      async function deleteApp(appKey, appName) {
        if (!confirm(`Are you sure you want to delete "${appName}"? This cannot be undone.`)) {
          return;
        }

        try {
          // Call the delete app endpoint with the UUID as a URL parameter
          const response = await fetch(`${API_BASE}/delete_app?uuid=${appKey}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          if (!response.ok) {
            throw new Error('Failed to delete app');
          }

          // Refresh the app list
          await loadApps();
        } catch (error) {
          console.error('Error deleting app:', error);
          alert('Failed to delete app: ' + error.message);
        }
      }

      async function loadPrompts() {
        try {
          const response = await fetch(`${API_BASE}/list_prompts`);
          const prompts = await response.json();

          // Store references to open modals and their positions
          const openModals = Array.from(
            document.querySelectorAll('.prompt-modal')
          )
            .filter(modal => modal.style.display === 'block')
            .map(modal => ({
              modal,
              alias: modal.querySelector('.app-title').value,
              scrollTop: modal.scrollTop,
            }));

          // Render new prompt list
          renderPrompts(prompts);

          // Restore open modals
          openModals.forEach(({ alias, scrollTop }) => {
            const newCard = document.querySelector(
              `.prompt-card[data-alias="${alias}"]`
            );
            if (newCard) {
              const index = Array.from(newCard.parentElement.children).indexOf(
                newCard
              );
              openPromptModal(index);
              const restoredModal = document.getElementById(
                `promptModal-${index}`
              );
              if (restoredModal) {
                restoredModal.scrollTop = scrollTop;
              }
            }
          });
        } catch (error) {
          console.error('Error loading prompts:', error);
        }
      }

      function renderPrompts(prompts) {
        const promptsList = document.getElementById('promptsList');
        promptsList.innerHTML = '';

        document.querySelectorAll('.prompt-modal').forEach(modal => {
          modal.remove();
        });

        prompts.forEach((prompt, index) => {
          if (!prompt.prompt) return;

          // Format dates nicely
          const created = prompt.created_at
            ? new Date(prompt.created_at).toLocaleDateString()
            : 'N/A';
          const updated = prompt.updated_at
            ? new Date(prompt.updated_at).toLocaleDateString()
            : 'N/A';

          const previewCard = document.createElement('div');
          previewCard.className = 'prompt-card prompt-preview';
          previewCard.setAttribute('data-alias', prompt.alias);
          previewCard.innerHTML = `
    <h3 class="app-title">${prompt.alias}</h3>
    <p class="app-description">${prompt.description || 'No description'}</p>
    <div class="app-tags">
        <span class="tag">Model: ${prompt.model}</span>
        <span class="tag">Created: ${created}</span>
        <span class="tag">Updated: ${updated}</span>
        <span class="tag">Uses: ${prompt.use_count || 0}</span>
        <span class="tag">Versions: ${
          prompt.version_count || 1
        }</span>  <!-- Add this line -->
        ${(prompt.tags || [])
          .map(tag => `<span class="tag">${tag}</span>`)
          .join('')}
    </div>
`;

          // Create combined edit/run modal
          const modal = document.createElement('div');
          modal.className = 'prompt-modal';
          modal.id = `promptModal-${index}`;

          const params = (prompt.prompt.match(/\[\[([^\]]+)\]\]/g) || []).map(param =>
            param.replace(/\[\[|\]\]/g, '')
          );

          modal.innerHTML = `
            <div class="prompt-modal-content">
        <div class="prompt-modal-header">
            <div>
                <input type="text" class="app-title prompt-input" style="font-size: 24px; background: transparent; border: 1px solid transparent; width: 100%;" value="${
                  prompt.alias
                }">
                <textarea class="app-description prompt-input" style="width: 100%; background: transparent; border: 1px solid transparent; resize: vertical; min-height: 60px;">${
                  prompt.description || ''
                }</textarea>
                <div class="app-tags" style="margin-top: 8px;">
                    <span class="tag">Created: ${created}</span>
                    <span class="tag">Updated: ${updated}</span>
                    <span class="tag">Uses: ${prompt.use_count || 0}</span>
                    <span class="tag">Versions: ${
                      prompt.version_count || 1
                    }</span>  <!-- Add this line -->
                </div>
            </div>
            <button class="prompt-modal-close" onclick="closePromptModal(${index})">×</button>
        </div>
        <div style="display: flex; gap: 12px; margin-bottom: 24px;">
            <select class="prompt-select model-select" style="flex: 2;">
                <option value="deepseek-r1" ${prompt.model === 'deepseek-r1' ? 'selected' : ''}>deepseek-r1</option>
                <option value="claude-3-5-sonnet-latest" ${prompt.model === 'claude-3-5-sonnet-latest' ? 'selected' : ''}>claude-3-5-sonnet</option>
                <option value="gpt-4o" ${prompt.model === 'gpt-4o' ? 'selected' : ''}>gpt-4o</option>
                <option value="o1" ${prompt.model === 'o1' ? 'selected' : ''}>o1</option>
                <option value="o3-mini-low" ${prompt.model === 'o3-mini-low' ? 'selected' : ''}>o3-mini-low</option>
                <option value="o3-mini-medium" ${prompt.model === 'o3-mini-medium' ? 'selected' : ''}>o3-mini-medium</option>
                <option value="o3-mini-high" ${prompt.model === 'o3-mini-high' ? 'selected' : ''}>o3-mini-high</option>
                <option value="dall-e-3" ${prompt.model === 'dall-e-3' ? 'selected' : ''}>dall-e-3</option>
            </select>
            
            <div class="version-select-container" style="flex: 1;">
                <select class="prompt-select version-select" onchange="loadPromptVersion('${
                  prompt.alias
                }', this.value)">
                    ${generateVersionOptions(prompt)}
                </select>
            </div>
        </div>
        
        <div class="font-size-controls">
          <button onclick="adjustFontSize(-1)" aria-label="Decrease font size">-</button>
          <span class="font-size-display">14px</span>
          <button onclick="adjustFontSize(1)" aria-label="Increase font size">+</button>
        </div>

        <textarea class="prompt-template prompt-input" style="width: 100%; min-height: 200px; background: rgba(255, 255, 255, 0.03); border: 1px solid var(--card-border); border-radius: 12px; padding: 16px; margin-bottom: 32px; color: #fff; font-family: monospace;">${
          prompt.prompt
        }</textarea>
        
        <div class="param-group">
            ${params
              .map(
                param => `
                <div style="margin-bottom: 16px;">
                    <label class="param-label">${param}</label>
                    <input type="text" class="param-input" data-param="${param}" placeholder="Enter value...">
                </div>
            `
              )
              .join('')}
        </div>
        
        <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button class="run-prompt-btn" style="flex: 1;" onclick='runPrompt("${
              prompt.alias
            }", this)'>
                Run Prompt
            </button>
            <button class="run-prompt-btn" style="flex: 1; background: var(--cal-blue);" onclick='updatePromptFromModal(this)'>
                Save Changes
            </button>
            <button class="run-prompt-btn" style="flex: 1; background: var(--stanford-red);" onclick='deletePrompt("${
              prompt.alias
            }")'>
    Delete Prompt
</button>
        </div>
        
        <div class="prompt-output" style="display: none; margin-top: 24px;">
            <div class="output-content"></div>
        </div>
    </div>
        `;

          previewCard.addEventListener('click', e => {
            if (!e.target.matches('.delete-button')) {
              // Close any open modals first
              document.querySelectorAll('.prompt-modal').forEach(m => {
                m.style.display = 'none';
              });
              // Then open the clicked one
              openPromptModal(index);
            }
          });

          promptsList.appendChild(previewCard);
          document.body.appendChild(modal);
        });
      }

      function generateVersionOptions(prompt) {
        const totalVersions = prompt.version_count || 1;
        const currentVersion = prompt.current_version || 'version 1';
        let options = '';

        for (let i = totalVersions; i > 0; i--) {
          const version = `v${i}`;
          const isCurrentVersion = version === currentVersion;
          options += `
            <option value="${version}" ${isCurrentVersion ? 'selected' : ''}>
                Version ${i} ${isCurrentVersion ? '(Current)' : ''}
            </option>`;
        }
        return options;
      }

      async function handleRollback(alias, version, event) {
        event.stopPropagation(); // Prevent version select from triggering

        if (
          confirm(
            `Are you sure you want to roll back to version ${version}? This will make ${version} the current version.`
          )
        ) {
          try {
            await rollbackPromptVersion(alias, version);
            alert(`Successfully rolled back to version ${version}`);
          } catch (error) {
            alert('Failed to roll back: ' + error.message);
          }
        }
      }

      async function loadPromptVersion(alias, version) {
        try {
          const versionResponse = await fetch(
            `${API_BASE}/read?key=prompt:version:${alias}:${version}`
          );
          if (!versionResponse.ok)
            throw new Error('Failed to load version data');
          const versionData = await versionResponse.json();

          const modal = document.querySelector(
            '.prompt-modal[style*="display: block"]'
          );
          if (!modal) return;

          if (versionData.value) {
            modal.querySelector('.prompt-template').value =
              versionData.value.prompt_text;
            modal.querySelector('.model-select').value =
              versionData.value.model;

            // Update parameters section
            updateParameterFields(modal, versionData.value.prompt_text);
          }
        } catch (error) {
          console.error('Error loading prompt version:', error);
          alert('Failed to load version: ' + error.message);
        }
      }
      function updateParameterFields(modal, promptText) {
        const paramGroup = modal.querySelector('.param-group');
        const params = (promptText.match(/\[\[([^\]]+)\]\]/g) || []).map(param => param.replace(/\[\[|\]\]/g, ''));

        paramGroup.innerHTML = params
          .map(
            param => `
        <div style="margin-bottom: 16px;">
            <label class="param-label">${param}</label>
            <input type="text" class="param-input" data-param="${param}" placeholder="Enter value...">
        </div>
    `
          )
          .join('');
      }

      async function updatePromptFromModal(buttonElement) {
        const modalContent = buttonElement.closest('.prompt-modal-content');
        const alias = modalContent.querySelector('.app-title').value.trim();
        const description = modalContent
          .querySelector('.app-description')
          .value.trim();
        const prompt = modalContent
          .querySelector('.prompt-template')
          .value.trim();
        const model = modalContent.querySelector('.model-select').value;

        if (!alias || !prompt) {
          alert('Please fill in all required fields');
          return;
        }

        try {
          buttonElement.disabled = true;
          buttonElement.textContent = 'Saving...';

          // Get the metadata first to get the current version count
          const metaResponse = await fetch(
            `${API_BASE}/read?key=prompt:meta:${alias}`
          );
          if (!metaResponse.ok) throw new Error('Failed to get metadata');
          const metaData = await metaResponse.json();
          const version_count = metaData.value.version_count || 1;

          // Store the prompt with updated version count
          const response = await fetch(`${API_BASE}/store_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias,
              description,
              prompt,
              model,
              version_count: version_count,
              updated_at: new Date().toISOString(),
            }),
          });

          if (!response.ok) throw new Error('Failed to update prompt');

          // Wait a brief moment to ensure the server has processed the update
          await new Promise(resolve => setTimeout(resolve, 100));

          // Refresh the main prompts list in the background
          await loadPrompts();

          // Fetch the latest data for this prompt
          const promptResponse = await fetch(
            `${API_BASE}/read?key=prompt:meta:${alias}`
          );
          if (!promptResponse.ok)
            throw new Error('Failed to fetch updated prompt data');
          const updatedPrompt = await promptResponse.json();

          // Update the modal's content with fresh data
          const modalTags = modalContent.querySelector('.app-tags');
          modalTags.innerHTML = `
            <span class="tag">Created: ${new Date(
              updatedPrompt.value.created_at
            ).toLocaleDateString()}</span>
            <span class="tag">Updated: ${new Date(
              updatedPrompt.value.updated_at
            ).toLocaleDateString()}</span>
            <span class="tag">Uses: ${updatedPrompt.value.use_count || 0}</span>
            <span class="tag">Versions: ${
              updatedPrompt.value.version_count || 1
            }</span>
        `;

          // Update version selector
          const versionSelect = modalContent.querySelector('.version-select');
          versionSelect.innerHTML = generateVersionOptions(updatedPrompt.value);

          // Show success message within the modal
          const successMessage = document.createElement('div');
          successMessage.style.cssText = `
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--cal-blue);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
          successMessage.textContent = 'Changes saved successfully!';
          modalContent.appendChild(successMessage);

          // Fade in and out animation for success message
          requestAnimationFrame(() => {
            successMessage.style.opacity = '1';
            setTimeout(() => {
              successMessage.style.opacity = '0';
              setTimeout(() => {
                successMessage.remove();
              }, 300);
            }, 2000);
          });
        } catch (error) {
          console.error('Error updating prompt:', error);
          alert('Failed to update prompt: ' + error.message);
        } finally {
          buttonElement.textContent = 'Save Changes';
          buttonElement.disabled = false;
        }
      }

      async function deletePrompt(alias) {
        if (
          !confirm(
            `Are you sure you want to delete the prompt "${alias}"? This cannot be undone.`
          )
        ) {
          return;
        }

        try {
          // Use the existing store_prompt endpoint with an empty prompt to "delete" it
          const response = await fetch(`${API_BASE}/store_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias,
              description: '',
              prompt: '', // Empty prompt will be filtered out by the backend
              model: '',
              delete: true, // Add a flag to indicate deletion
            }),
          });

          if (!response.ok) throw new Error('Failed to delete prompt');

          await loadPrompts();
        } catch (error) {
          console.error('Error deleting prompt:', error);
          alert('Failed to delete prompt: ' + error.message);
        }
      }

      function findDefaultParams(promptTemplate) {
        // Extract parameters enclosed in curly braces
        const params = {};
        const matches = promptTemplate.match(/\[\[([^\]]+)\]\]/g) || [];

        matches.forEach(match => {
          const param = match.replace(/{|}/g, '');
          params[param] = ''; // Set empty string as default value
        });

        return JSON.stringify(params, null, 2);
      }

      function showCreatePromptModal() {
        document.getElementById('createPromptModal').style.display = 'block';
      }

      function hideCreatePromptModal() {
        document.getElementById('createPromptModal').style.display = 'none';
      }

      async function createNewPrompt() {
        const alias = document.getElementById('promptAlias').value.trim();
        const description = document
          .getElementById('promptDescription')
          .value.trim();
        const prompt = document.getElementById('promptText').value.trim();
        const model = document.getElementById('promptModel').value;

        if (!alias || !prompt) {
          alert('Please fill in all required fields');
          return;
        }

        try {
          const current_time = new Date().toISOString();

          const response = await fetch(`${API_BASE}/store_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias,
              description,
              prompt,
              model,
              tags: [],
              current_version: 'v1',
              created_at: current_time,
              updated_at: current_time,
            }),
          });

          if (!response.ok) throw new Error('Failed to create prompt');

          hideCreatePromptModal();
          document.getElementById('promptAlias').value = '';
          document.getElementById('promptDescription').value = '';
          document.getElementById('promptText').value = '';

          await loadPrompts();
        } catch (error) {
          console.error('Error creating prompt:', error);
          alert('Failed to create prompt: ' + error.message);
        }
      }

      function switchSection(section) {
        // Update sidebar active state
        document.querySelectorAll('.category-item').forEach(item => {
          item.classList.remove('active');
          if (item.textContent.toLowerCase().includes(section)) {
            item.classList.add('active');
          }
        });

        // Hide all sections
        document.querySelectorAll('.content-section').forEach(section => {
          section.classList.remove('active');
        });

        // Show appropriate section and buttons
        const newAppBtn = document.getElementById('newAppBtn');
        const newPromptBtn = document.getElementById('newPromptBtn');

        switch (section) {
          case 'apps':
            document.getElementById('appsSection').classList.add('active');
            newAppBtn.style.display = 'block';
            newPromptBtn.style.display = 'none';
            loadApps();
            break;
          case 'prompts':
            document.getElementById('promptsSection').classList.add('active');
            newAppBtn.style.display = 'none';
            newPromptBtn.style.display = 'block';
            loadPrompts();
            break;
        }
      }
      function openPromptModal(index) {
        // First close any open modals
        document.querySelectorAll('.prompt-modal').forEach(modal => {
          modal.style.display = 'none';
        });

        // Then open the requested modal
        const modal = document.getElementById(`promptModal-${index}`);
        if (modal) {
          modal.style.display = 'block';
          document.body.style.overflow = 'hidden';
          
          // Reset font size to default
          const textarea = modal.querySelector('.prompt-template');
          textarea.style.setProperty('--prompt-font-size', '14px');
          const display = modal.querySelector('.font-size-display');
          if (display) display.textContent = '14px';
        }
      }

      function closePromptModal(index) {
        const modal = document.getElementById(`promptModal-${index}`);
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = 'auto';
        }
      }

      async function runPrompt(alias, buttonElement) {
        const modalContent = buttonElement.closest('.prompt-modal-content');
        const paramInputs = modalContent.querySelectorAll('.param-input');
        const outputDiv = modalContent.querySelector('.prompt-output');
        const outputContent = outputDiv.querySelector('.output-content');
        const versionSelect = modalContent.querySelector('.version-select');
        const currentVersion = versionSelect ? versionSelect.value : null;
        const modalIndex = modalContent
          .closest('.prompt-modal')
          .id.split('-')[1];

        try {
          const params = {};
          paramInputs.forEach(input => {
            params[input.dataset.param] = input.value;
          });

          buttonElement.disabled = true;
          buttonElement.textContent = 'Running...';

          const response = await fetch(`${API_BASE}/run_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias: alias,
              params: params,
            }),
          });

          if (!response.ok) throw new Error('Failed to run prompt');
          const result = await response.json();

          const content = result?.content || 'No content returned';

          // Store current state before refresh
          const currentState = {
            modalIndex,
            content,
            version: currentVersion,
            paramValues: Array.from(paramInputs).map(input => ({
              param: input.dataset.param,
              value: input.value,
            })),
          };

          // Refresh prompts list
          await loadPrompts();

          // After refresh, find and restore the modal state
          const newModal = document.getElementById(
            `promptModal-${currentState.modalIndex}`
          );
          if (newModal) {
            const newOutputDiv = newModal.querySelector('.prompt-output');
            const newOutputContent =
              newOutputDiv.querySelector('.output-content');
            const newVersionSelect = newModal.querySelector('.version-select');

            // Restore version if it exists
            if (newVersionSelect && currentState.version) {
              newVersionSelect.value = currentState.version;
            }

            // Restore parameter values
            currentState.paramValues.forEach(({ param, value }) => {
              const input = newModal.querySelector(
                `.param-input[data-param="${param}"]`
              );
              if (input) input.value = value;
            });

            // Restore output
            newOutputContent.textContent = currentState.content;
            newOutputDiv.style.display = 'block';

            // Make sure modal stays open
            newModal.style.display = 'block';
          }
        } catch (error) {
          outputContent.textContent = `Error: ${error.message}`;
          outputDiv.style.display = 'block';
        } finally {
          buttonElement.disabled = false;
          buttonElement.textContent = 'Run Prompt';
        }
      }

      async function rollbackPromptVersion(alias, version) {
        try {
          // Load the version we want to roll back to
          const versionResponse = await fetch(
            `${API_BASE}/read?key=prompt:version:${alias}:${version}`
          );
          if (!versionResponse.ok)
            throw new Error('Failed to load version data');
          const versionData = await versionResponse.json();

          // Update prompt metadata with rolled back version
          const response = await fetch(`${API_BASE}/store_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias,
              description: versionData.value.description || '',
              prompt: versionData.value.prompt_text,
              model: versionData.value.model,
              current_version: version,
              updated_at: new Date().toISOString(),
              rollback: true,
            }),
          });

          if (!response.ok) throw new Error('Failed to rollback version');

          // Refresh prompts list
          await loadPrompts();
          return true;
        } catch (error) {
          console.error('Error rolling back version:', error);
          throw error;
        }
      }

      async function deletePrompt(alias) {
        if (
          !confirm(
            `Are you sure you want to delete the prompt "${alias}"? This will delete all versions and cannot be undone.`
          )
        ) {
          return;
        }

        try {
          const response = await fetch(`${API_BASE}/delete_prompt`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              alias: alias,
            }),
          });

          if (!response.ok) {
            throw new Error('Failed to delete prompt');
          }

          // Close modal if open
          const modal = document.querySelector(
            '.prompt-modal[style*="display: block"]'
          );
          if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
          }

          // Refresh the prompts list
          await loadPrompts();
        } catch (error) {
          console.error('Error deleting prompt:', error);
          alert('Failed to delete prompt: ' + error.message);
        }
      }

      function adjustFontSize(delta) {
        const textarea = document.querySelector('.prompt-template');
        const display = document.querySelector('.font-size-display');
        const currentSize = parseInt(getComputedStyle(textarea).getPropertyValue('--prompt-font-size')) || 14;
        const newSize = Math.max(8, Math.min(24, currentSize + delta)); // Limit size between 8px and 24px
        
        textarea.style.setProperty('--prompt-font-size', `${newSize}px`);
        display.textContent = `${newSize}px`;
      }

      function showMetadataModal(appKey) {
        const modal = document.createElement('div');
        modal.className = 'metadata-modal';
        modal.id = `metadataModal-${appKey}`;
        
        // Find the app data
        const app = apps.find(app => app.key === appKey);
        const appData = app.value;
        
        modal.innerHTML = `
          <div class="metadata-modal-content">
            <div class="modal-header">
              <h2 class="modal-title">Edit App Metadata</h2>
            </div>
            <div class="form-group">
              <label for="editAppName">App Name</label>
              <input type="text" id="editAppName" value="${appData.name || ''}" placeholder="Enter app name" />
            </div>
            <div class="form-group">
              <label for="editAppDescription">Description</label>
              <input type="text" id="editAppDescription" value="${appData.description || ''}" placeholder="Enter app description" />
            </div>
            <div class="form-group">
              <label>Categories</label>
              <div class="category-chips">
                ${(appData.categories || [])
                  .map(
                    category => `
                    <div class="category-chip">
                      ${category}
                      <button onclick="removeCategory('${appKey}', '${category}')">&times;</button>
                    </div>
                  `
                  )
                  .join('')}
              </div>
              <input type="text" class="add-category-input" placeholder="Add category and press Enter" onkeypress="addCategoryOnEnter(event, '${appKey}')" />
            </div>
            <div class="modal-buttons">
              <button class="modal-btn cancel" onclick="hideMetadataModal('${appKey}')">Cancel</button>
              <button class="modal-btn create" onclick="updateAppMetadata('${appKey}')">Save Changes</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }

      function hideMetadataModal(appKey) {
        const modal = document.getElementById(`metadataModal-${appKey}`);
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = 'auto';
          modal.remove();
        }
      }

      async function updateAppMetadata(appKey) {
        try {
            const name = document.getElementById('editAppName').value.trim();
            const description = document.getElementById('editAppDescription').value.trim();
            const categoryInput = document.querySelector('.add-category-input');
            const category = categoryInput.value.trim();
            
            if (!name) {
                alert('Please enter an app name');
                return;
            }

            const response = await fetch(`${API_BASE}/read?key=${appKey}`);
            if (!response.ok) throw new Error('Failed to fetch app data');
            const data = await response.json();
            const appData = data.value;

            // Add any pending category from input
            if (category && !appData.categories.includes(category)) {
                appData.categories.push(category);
            }

            appData.name = name;
            appData.description = description;
            appData.updated_at = new Date().toISOString();

            const updateResponse = await fetch(`${API_BASE}/write`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    key: appKey,
                    value: appData,
                }),
            });

            if (!updateResponse.ok) throw new Error('Failed to update app metadata');

            hideMetadataModal(appKey);
            await loadApps();
        } catch (error) {
            console.error('Error updating app metadata:', error);
            alert('Failed to update app metadata: ' + error.message);
        }
    }

      async function addCategoryOnEnter(event, appKey) {
        if (event.key === 'Enter') {
          event.preventDefault();
          const input = event.target;
          const category = input.value.trim();
          
          if (!category) return;

          try {
            // Get current app data
            const response = await fetch(`${API_BASE}/read?key=${appKey}`);
            if (!response.ok) throw new Error('Failed to fetch app data');
            const data = await response.json();
            const appData = data.value;

            // Initialize categories array if it doesn't exist
            if (!appData.categories) {
              appData.categories = [];
            }

            // Add new category if it doesn't already exist
            if (!appData.categories.includes(category)) {
              appData.categories.push(category);
              appData.updated_at = new Date().toISOString();

              // Save updated app data
              const updateResponse = await fetch(`${API_BASE}/write`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  key: appKey,
                  value: appData,
                }),
              });

              if (!updateResponse.ok) throw new Error('Failed to add category');

              // Clear input and refresh the modal
              input.value = '';
              await loadApps();
              hideMetadataModal(appKey);
              showMetadataModal(appKey);
            }
          } catch (error) {
            console.error('Error adding category:', error);
            alert('Failed to add category: ' + error.message);
          }
        }
      }

      async function removeCategory(appKey, category) {
        try {
          // Get current app data
          const response = await fetch(`${API_BASE}/read?key=${appKey}`);
          if (!response.ok) throw new Error('Failed to fetch app data');
          const data = await response.json();
          const appData = data.value;

          // Remove the category
          appData.categories = (appData.categories || []).filter(c => c !== category);
          appData.updated_at = new Date().toISOString();

          // Save updated app data
          const updateResponse = await fetch(`${API_BASE}/write`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              key: appKey,
              value: appData,
            }),
          });

          if (!updateResponse.ok) throw new Error('Failed to remove category');

          // Refresh the modal
          await loadApps();
          hideMetadataModal(appKey);
          showMetadataModal(appKey);
        } catch (error) {
          console.error('Error removing category:', error);
          alert('Failed to remove category: ' + error.message);
        }
      }

      window.addEventListener('click', e => {
        if (e.target.matches('.prompt-modal')) {
          const index = e.target.id.split('-')[1];
          closePromptModal(index);
        }
      });

      switchSection('apps');
    </script>
  </body>
</html>



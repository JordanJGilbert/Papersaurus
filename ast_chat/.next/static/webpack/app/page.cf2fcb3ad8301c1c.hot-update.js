"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts":
/*!**********************************************!*\
  !*** ./hooks/cardStudio/useJobManagement.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useJobManagement: function() { return /* binding */ useJobManagement; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useJobManagement auto */ \nfunction useJobManagement() {\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [progressPercentage, setProgressPercentage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [generationStartTime, setGenerationStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentElapsedTime, setCurrentElapsedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [elapsedTimeInterval, setElapsedTimeInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentJobType, setCurrentJobType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Job management functions\n    const saveJobToStorage = (jobId, jobData)=>{\n        if (false) {}\n        try {\n            // Enhanced job data with progress, state, and expiration\n            const enhancedJobData = {\n                ...jobData,\n                id: jobId,\n                status: \"processing\",\n                createdAt: Date.now(),\n                expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,\n                lastProgress: progressPercentage,\n                lastProgressText: generationProgress,\n                elapsedTime: currentElapsedTime\n            };\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(enhancedJobData));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            if (!pendingJobs.includes(jobId)) {\n                pendingJobs.push(jobId);\n                localStorage.setItem(\"pendingCardJobs\", JSON.stringify(pendingJobs));\n            }\n            // Run cleanup of expired jobs\n            cleanupExpiredJobs();\n        } catch (error) {\n            console.error(\"Failed to save job to localStorage:\", error);\n        }\n    };\n    // Update job progress in storage\n    const updateJobProgress = (jobId, progress, progressText)=>{\n        if (false) {}\n        try {\n            const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n            if (!jobData) return;\n            const job = JSON.parse(jobData);\n            job.lastProgress = progress;\n            job.lastProgressText = progressText;\n            job.elapsedTime = currentElapsedTime;\n            job.lastUpdate = Date.now();\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(job));\n        } catch (error) {\n            console.error(\"Failed to update job progress:\", error);\n        }\n    };\n    // Remove job from storage\n    const removeJobFromStorage = (jobId)=>{\n        if (false) {}\n        try {\n            localStorage.removeItem(\"cardJob_\".concat(jobId));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const updatedJobs = pendingJobs.filter((id)=>id !== jobId);\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(updatedJobs));\n        } catch (error) {\n            console.error(\"Failed to remove job from localStorage:\", error);\n        }\n    };\n    // Cleanup expired jobs from localStorage\n    const cleanupExpiredJobs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        const now = Date.now();\n        const keysToRemove = [];\n        // Check all localStorage keys\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith(\"cardJob_\")) {\n                try {\n                    const jobData = localStorage.getItem(key);\n                    if (jobData) {\n                        const job = JSON.parse(jobData);\n                        // Remove if expired or corrupted data\n                        if (!job.expiresAt || job.expiresAt < now) {\n                            keysToRemove.push(key);\n                        }\n                    }\n                } catch (error) {\n                    // Remove corrupted data\n                    keysToRemove.push(key);\n                }\n            }\n        });\n        // Remove expired jobs\n        keysToRemove.forEach((key)=>{\n            localStorage.removeItem(key);\n            console.log(\"\\uD83E\\uDDF9 Removed expired job: \".concat(key));\n        });\n        // Update pending jobs list\n        if (keysToRemove.length > 0) {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const cleanedJobs = pendingJobs.filter((jobId)=>!keysToRemove.includes(\"cardJob_\".concat(jobId)));\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(cleanedJobs));\n        }\n    }, []);\n    // Start elapsed time tracking\n    const startElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const start = Date.now();\n        setGenerationStartTime(start);\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n        }\n        const interval = setInterval(()=>{\n            const elapsed = (Date.now() - start) / 1000;\n            setCurrentElapsedTime(elapsed);\n        }, 1000);\n        setElapsedTimeInterval(interval);\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Stop elapsed time tracking\n    const stopElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n            setElapsedTimeInterval(null);\n        }\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Clear all job data from localStorage\n    const clearAllJobData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        console.log(\"\\uD83E\\uDDF9 Clearing all job data from localStorage\");\n        // Get all keys\n        const keys = Object.keys(localStorage);\n        // Remove all job-related keys\n        keys.forEach((key)=>{\n            if (key.startsWith(\"cardJob_\") || key === \"pendingCardJobs\" || key === \"generation-start-time\") {\n                localStorage.removeItem(key);\n            }\n        });\n        // Reset state\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setGenerationStartTime(null);\n    }, []);\n    // Recovery function - resume WebSocket subscriptions for pending jobs\n    const checkPendingJobs = async ()=>{\n        if (false) {}\n        try {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const jobsData = [];\n            for (const jobId of pendingJobs){\n                const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n                if (!jobData) continue;\n                const job = JSON.parse(jobData);\n                jobsData.push({\n                    jobId,\n                    job\n                });\n            }\n            return jobsData;\n        } catch (error) {\n            console.error(\"Failed to check pending jobs:\", error);\n            return [];\n        }\n    };\n    // Load most recent draft batch (5 cards)\n    const loadMostRecentDraftBatch = ()=>{\n        if (false) {}\n        try {\n            // Get all localStorage keys\n            const keys = Object.keys(localStorage);\n            const draftJobKeys = keys.filter((key)=>key.startsWith(\"cardJob_draft-\"));\n            console.log(\"\\uD83D\\uDD0D Found \".concat(draftJobKeys.length, \" draft job keys in localStorage\"));\n            const draftJobs = [];\n            // Find all draft job entries\n            for (const key of draftJobKeys){\n                const jobData = localStorage.getItem(key);\n                if (jobData) {\n                    try {\n                        var _job_draftCards;\n                        const job = JSON.parse(jobData);\n                        console.log(\"\\uD83D\\uDCC4 Checking \".concat(key, \":\"), {\n                            hasDraftCards: !!job.draftCards,\n                            cardCount: ((_job_draftCards = job.draftCards) === null || _job_draftCards === void 0 ? void 0 : _job_draftCards.length) || 0,\n                            createdAt: job.createdAt\n                        });\n                        if (job.draftCards && Array.isArray(job.draftCards) && job.draftCards.length > 0) {\n                            draftJobs.push({\n                                key,\n                                job,\n                                createdAt: job.createdAt || 0\n                            });\n                        }\n                    } catch (e) {\n                        console.error(\"Failed to parse \".concat(key, \":\"), e);\n                    }\n                }\n            }\n            // If no draft jobs found, return null\n            if (draftJobs.length === 0) return null;\n            // Sort by creation time (newest first)\n            draftJobs.sort((a, b)=>b.createdAt - a.createdAt);\n            // Get the most recent batch (they should all have similar timestamps)\n            const mostRecentTimestamp = draftJobs[0].createdAt;\n            const recentBatch = draftJobs.filter((job)=>{\n                // Consider jobs within 5 minutes of each other as the same batch\n                return Math.abs(job.createdAt - mostRecentTimestamp) < 5 * 60 * 1000;\n            });\n            // Collect all draft cards from the batch, avoiding duplicates\n            const draftCardMap = new Map();\n            for (const { job } of recentBatch){\n                if (job.draftCards && job.draftCards.length > 0) {\n                    var _draftCard_id_match;\n                    // Each job now stores only one draft card\n                    const draftCard = job.draftCards[0];\n                    const draftIndex = job.draftIndex !== undefined ? job.draftIndex : parseInt(((_draftCard_id_match = draftCard.id.match(/draft-(\\d+)-/)) === null || _draftCard_id_match === void 0 ? void 0 : _draftCard_id_match[1]) || \"0\") - 1;\n                    // Use draft index as key to avoid duplicates\n                    if (!draftCardMap.has(draftIndex)) {\n                        draftCardMap.set(draftIndex, draftCard);\n                    }\n                }\n            }\n            // Convert map to array and sort by draft index\n            const allDraftCards = Array.from(draftCardMap.entries()).sort((a, b)=>a[0] - b[0]).map((param)=>{\n                let [_, card] = param;\n                return card;\n            });\n            console.log(\"\\uD83D\\uDCCB Loaded \".concat(allDraftCards.length, \" unique draft cards from batch\"));\n            // Return the batch info\n            return {\n                cards: allDraftCards,\n                createdAt: mostRecentTimestamp,\n                count: allDraftCards.length\n            };\n        } catch (error) {\n            console.error(\"Failed to load recent draft batch:\", error);\n            return null;\n        }\n    };\n    // Run cleanup on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        cleanupExpiredJobs();\n    }, [\n        cleanupExpiredJobs\n    ]);\n    return {\n        currentJobId,\n        setCurrentJobId,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        generationStartTime,\n        setGenerationStartTime,\n        currentElapsedTime,\n        setCurrentElapsedTime,\n        elapsedTimeInterval,\n        setElapsedTimeInterval,\n        generationDuration,\n        setGenerationDuration,\n        saveJobToStorage,\n        updateJobProgress,\n        removeJobFromStorage,\n        startElapsedTimeTracking,\n        stopElapsedTimeTracking,\n        clearAllJobData,\n        checkPendingJobs,\n        loadMostRecentDraftBatch,\n        cleanupExpiredJobs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlSm9iTWFuYWdlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7c0VBRXlEO0FBSWxELFNBQVNHO0lBQ2QsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR0wsK0NBQVFBLENBQWdCO0lBQ2hFLE1BQU0sQ0FBQ00sb0JBQW9CQyxzQkFBc0IsR0FBR1AsK0NBQVFBLENBQVM7SUFDckUsTUFBTSxDQUFDUSxvQkFBb0JDLHNCQUFzQixHQUFHVCwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUNVLHFCQUFxQkMsdUJBQXVCLEdBQUdYLCtDQUFRQSxDQUFnQjtJQUM5RSxNQUFNLENBQUNZLG9CQUFvQkMsc0JBQXNCLEdBQUdiLCtDQUFRQSxDQUFTO0lBQ3JFLE1BQU0sQ0FBQ2MscUJBQXFCQyx1QkFBdUIsR0FBR2YsK0NBQVFBLENBQXdCO0lBQ3RGLE1BQU0sQ0FBQ2dCLG9CQUFvQkMsc0JBQXNCLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFDNUUsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR25CLCtDQUFRQSxDQUEyQjtJQUUvRSwyQkFBMkI7SUFDM0IsTUFBTW9CLG1CQUFtQixDQUFDQyxPQUFlQztRQUN2QyxJQUFJLEtBQWtCLEVBQWEsRUFBTztRQUUxQyxJQUFJO1lBQ0YseURBQXlEO1lBQ3pELE1BQU1DLGtCQUFrQjtnQkFDdEIsR0FBR0QsT0FBTztnQkFDVkUsSUFBSUg7Z0JBQ0pJLFFBQVE7Z0JBQ1JDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CQyxXQUFXRixLQUFLQyxHQUFHLEtBQU0sS0FBSyxLQUFLLEtBQUssS0FBSztnQkFDN0NFLGNBQWN0QjtnQkFDZHVCLGtCQUFrQnpCO2dCQUNsQjBCLGFBQWFwQjtZQUNmO1lBRUFxQixhQUFhQyxPQUFPLENBQUMsV0FBaUIsT0FBTmIsUUFBU2MsS0FBS0MsU0FBUyxDQUFDYjtZQUV4RCxNQUFNYyxjQUFjRixLQUFLRyxLQUFLLENBQUNM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RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy9jYXJkU3R1ZGlvL3VzZUpvYk1hbmFnZW1lbnQudHM/ZmM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgR2VuZXJhdGVkQ2FyZCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUpvYk1hbmFnZW1lbnQoKSB7XG4gIGNvbnN0IFtjdXJyZW50Sm9iSWQsIHNldEN1cnJlbnRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRpb25Qcm9ncmVzcywgc2V0R2VuZXJhdGlvblByb2dyZXNzXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtwcm9ncmVzc1BlcmNlbnRhZ2UsIHNldFByb2dyZXNzUGVyY2VudGFnZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbZ2VuZXJhdGlvblN0YXJ0VGltZSwgc2V0R2VuZXJhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRFbGFwc2VkVGltZSwgc2V0Q3VycmVudEVsYXBzZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtlbGFwc2VkVGltZUludGVydmFsLCBzZXRFbGFwc2VkVGltZUludGVydmFsXSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uRHVyYXRpb24sIHNldEdlbmVyYXRpb25EdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRKb2JUeXBlLCBzZXRDdXJyZW50Sm9iVHlwZV0gPSB1c2VTdGF0ZTwnZHJhZnQnIHwgJ2ZpbmFsJyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEpvYiBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICBjb25zdCBzYXZlSm9iVG9TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcsIGpvYkRhdGE6IGFueSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBFbmhhbmNlZCBqb2IgZGF0YSB3aXRoIHByb2dyZXNzLCBzdGF0ZSwgYW5kIGV4cGlyYXRpb25cbiAgICAgIGNvbnN0IGVuaGFuY2VkSm9iRGF0YSA9IHtcbiAgICAgICAgLi4uam9iRGF0YSxcbiAgICAgICAgaWQ6IGpvYklkLFxuICAgICAgICBzdGF0dXM6ICdwcm9jZXNzaW5nJyxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyAoMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKSwgLy8gMzAgZGF5cyBleHBpcmF0aW9uXG4gICAgICAgIGxhc3RQcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgICAgICBsYXN0UHJvZ3Jlc3NUZXh0OiBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgICAgIGVsYXBzZWRUaW1lOiBjdXJyZW50RWxhcHNlZFRpbWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCwgSlNPTi5zdHJpbmdpZnkoZW5oYW5jZWRKb2JEYXRhKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJykgfHwgJ1tdJyk7XG4gICAgICBpZiAoIXBlbmRpbmdKb2JzLmluY2x1ZGVzKGpvYklkKSkge1xuICAgICAgICBwZW5kaW5nSm9icy5wdXNoKGpvYklkKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHBlbmRpbmdKb2JzKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJ1biBjbGVhbnVwIG9mIGV4cGlyZWQgam9ic1xuICAgICAgY2xlYW51cEV4cGlyZWRKb2JzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGpvYiB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGRhdGUgam9iIHByb2dyZXNzIGluIHN0b3JhZ2VcbiAgY29uc3QgdXBkYXRlSm9iUHJvZ3Jlc3MgPSAoam9iSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgcHJvZ3Jlc3NUZXh0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICBpZiAoIWpvYkRhdGEpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3Qgam9iID0gSlNPTi5wYXJzZShqb2JEYXRhKTtcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3NUZXh0ID0gcHJvZ3Jlc3NUZXh0O1xuICAgICAgam9iLmVsYXBzZWRUaW1lID0gY3VycmVudEVsYXBzZWRUaW1lO1xuICAgICAgam9iLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgY2FyZEpvYl8ke2pvYklkfWAsIEpTT04uc3RyaW5naWZ5KGpvYikpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGpvYiBwcm9ncmVzczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZSBqb2IgZnJvbSBzdG9yYWdlXG4gIGNvbnN0IHJlbW92ZUpvYkZyb21TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChpZDogc3RyaW5nKSA9PiBpZCAhPT0gam9iSWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRKb2JzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgam9iIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2xlYW51cCBleHBpcmVkIGpvYnMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgY2xlYW51cEV4cGlyZWRKb2JzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIENoZWNrIGFsbCBsb2NhbFN0b3JhZ2Uga2V5c1xuICAgIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdjYXJkSm9iXycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgaWYgKGpvYkRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IEpTT04ucGFyc2Uoam9iRGF0YSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgaWYgZXhwaXJlZCBvciBjb3JydXB0ZWQgZGF0YVxuICAgICAgICAgICAgaWYgKCFqb2IuZXhwaXJlc0F0IHx8IGpvYi5leHBpcmVzQXQgPCBub3cpIHtcbiAgICAgICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGNvcnJ1cHRlZCBkYXRhXG4gICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGpvYnNcbiAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJlbW92ZWQgZXhwaXJlZCBqb2I6ICR7a2V5fWApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGpvYnMgbGlzdFxuICAgIGlmIChrZXlzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IGNsZWFuZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChqb2JJZDogc3RyaW5nKSA9PiBcbiAgICAgICAgIWtleXNUb1JlbW92ZS5pbmNsdWRlcyhgY2FyZEpvYl8ke2pvYklkfWApXG4gICAgICApO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KGNsZWFuZWRKb2JzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU3RhcnQgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZShzdGFydCk7XG4gICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lKDApO1xuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICBcbiAgICBpZiAoZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChlbGFwc2VkVGltZUludGVydmFsKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwO1xuICAgICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lKGVsYXBzZWQpO1xuICAgIH0sIDEwMDApO1xuICAgIFxuICAgIHNldEVsYXBzZWRUaW1lSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbZWxhcHNlZFRpbWVJbnRlcnZhbF0pO1xuXG4gIC8vIFN0b3AgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHN0b3BFbGFwc2VkVGltZVRyYWNraW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChlbGFwc2VkVGltZUludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKGVsYXBzZWRUaW1lSW50ZXJ2YWwpO1xuICAgICAgc2V0RWxhcHNlZFRpbWVJbnRlcnZhbChudWxsKTtcbiAgICB9XG4gIH0sIFtlbGFwc2VkVGltZUludGVydmFsXSk7XG5cbiAgLy8gQ2xlYXIgYWxsIGpvYiBkYXRhIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGNsZWFyQWxsSm9iRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+nuSBDbGVhcmluZyBhbGwgam9iIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UnKTtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGtleXNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgYWxsIGpvYi1yZWxhdGVkIGtleXNcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnY2FyZEpvYl8nKSB8fCBrZXkgPT09ICdwZW5kaW5nQ2FyZEpvYnMnIHx8IGtleSA9PT0gJ2dlbmVyYXRpb24tc3RhcnQtdGltZScpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZXNldCBzdGF0ZVxuICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZSgwKTtcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMCk7XG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZShudWxsKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJlY292ZXJ5IGZ1bmN0aW9uIC0gcmVzdW1lIFdlYlNvY2tldCBzdWJzY3JpcHRpb25zIGZvciBwZW5kaW5nIGpvYnNcbiAgY29uc3QgY2hlY2tQZW5kaW5nSm9icyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IGpvYnNEYXRhID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgam9iSWQgb2YgcGVuZGluZ0pvYnMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICAgIGlmICgham9iRGF0YSkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBqb2IgPSBKU09OLnBhcnNlKGpvYkRhdGEpO1xuICAgICAgICBqb2JzRGF0YS5wdXNoKHsgam9iSWQsIGpvYiB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGpvYnNEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgcGVuZGluZyBqb2JzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTG9hZCBtb3N0IHJlY2VudCBkcmFmdCBiYXRjaCAoNSBjYXJkcylcbiAgY29uc3QgbG9hZE1vc3RSZWNlbnREcmFmdEJhdGNoID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBhbGwgbG9jYWxTdG9yYWdlIGtleXNcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpO1xuICAgICAgY29uc3QgZHJhZnRKb2JLZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdjYXJkSm9iX2RyYWZ0LScpKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZvdW5kICR7ZHJhZnRKb2JLZXlzLmxlbmd0aH0gZHJhZnQgam9iIGtleXMgaW4gbG9jYWxTdG9yYWdlYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRyYWZ0Sm9icyA9IFtdO1xuICAgICAgXG4gICAgICAvLyBGaW5kIGFsbCBkcmFmdCBqb2IgZW50cmllc1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZHJhZnRKb2JLZXlzKSB7XG4gICAgICAgIGNvbnN0IGpvYkRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoam9iRGF0YSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSBKU09OLnBhcnNlKGpvYkRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4QgQ2hlY2tpbmcgJHtrZXl9OmAsIHsgXG4gICAgICAgICAgICAgIGhhc0RyYWZ0Q2FyZHM6ICEham9iLmRyYWZ0Q2FyZHMsIFxuICAgICAgICAgICAgICBjYXJkQ291bnQ6IGpvYi5kcmFmdENhcmRzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBqb2IuY3JlYXRlZEF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGpvYi5kcmFmdENhcmRzICYmIEFycmF5LmlzQXJyYXkoam9iLmRyYWZ0Q2FyZHMpICYmIGpvYi5kcmFmdENhcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZHJhZnRKb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBqb2IsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBqb2IuY3JlYXRlZEF0IHx8IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlICR7a2V5fTpgLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgbm8gZHJhZnQgam9icyBmb3VuZCwgcmV0dXJuIG51bGxcbiAgICAgIGlmIChkcmFmdEpvYnMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIFxuICAgICAgLy8gU29ydCBieSBjcmVhdGlvbiB0aW1lIChuZXdlc3QgZmlyc3QpXG4gICAgICBkcmFmdEpvYnMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQgLSBhLmNyZWF0ZWRBdCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgbW9zdCByZWNlbnQgYmF0Y2ggKHRoZXkgc2hvdWxkIGFsbCBoYXZlIHNpbWlsYXIgdGltZXN0YW1wcylcbiAgICAgIGNvbnN0IG1vc3RSZWNlbnRUaW1lc3RhbXAgPSBkcmFmdEpvYnNbMF0uY3JlYXRlZEF0O1xuICAgICAgY29uc3QgcmVjZW50QmF0Y2ggPSBkcmFmdEpvYnMuZmlsdGVyKGpvYiA9PiB7XG4gICAgICAgIC8vIENvbnNpZGVyIGpvYnMgd2l0aGluIDUgbWludXRlcyBvZiBlYWNoIG90aGVyIGFzIHRoZSBzYW1lIGJhdGNoXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhqb2IuY3JlYXRlZEF0IC0gbW9zdFJlY2VudFRpbWVzdGFtcCkgPCA1ICogNjAgKiAxMDAwO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENvbGxlY3QgYWxsIGRyYWZ0IGNhcmRzIGZyb20gdGhlIGJhdGNoLCBhdm9pZGluZyBkdXBsaWNhdGVzXG4gICAgICBjb25zdCBkcmFmdENhcmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgeyBqb2IgfSBvZiByZWNlbnRCYXRjaCkge1xuICAgICAgICBpZiAoam9iLmRyYWZ0Q2FyZHMgJiYgam9iLmRyYWZ0Q2FyZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIEVhY2ggam9iIG5vdyBzdG9yZXMgb25seSBvbmUgZHJhZnQgY2FyZFxuICAgICAgICAgIGNvbnN0IGRyYWZ0Q2FyZCA9IGpvYi5kcmFmdENhcmRzWzBdO1xuICAgICAgICAgIGNvbnN0IGRyYWZ0SW5kZXggPSBqb2IuZHJhZnRJbmRleCAhPT0gdW5kZWZpbmVkID8gam9iLmRyYWZ0SW5kZXggOiBcbiAgICAgICAgICAgIHBhcnNlSW50KGRyYWZ0Q2FyZC5pZC5tYXRjaCgvZHJhZnQtKFxcZCspLS8pPy5bMV0gfHwgJzAnKSAtIDE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXNlIGRyYWZ0IGluZGV4IGFzIGtleSB0byBhdm9pZCBkdXBsaWNhdGVzXG4gICAgICAgICAgaWYgKCFkcmFmdENhcmRNYXAuaGFzKGRyYWZ0SW5kZXgpKSB7XG4gICAgICAgICAgICBkcmFmdENhcmRNYXAuc2V0KGRyYWZ0SW5kZXgsIGRyYWZ0Q2FyZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgbWFwIHRvIGFycmF5IGFuZCBzb3J0IGJ5IGRyYWZ0IGluZGV4XG4gICAgICBjb25zdCBhbGxEcmFmdENhcmRzID0gQXJyYXkuZnJvbShkcmFmdENhcmRNYXAuZW50cmllcygpKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pXG4gICAgICAgIC5tYXAoKFtfLCBjYXJkXSkgPT4gY2FyZCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIExvYWRlZCAke2FsbERyYWZ0Q2FyZHMubGVuZ3RofSB1bmlxdWUgZHJhZnQgY2FyZHMgZnJvbSBiYXRjaGApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gdGhlIGJhdGNoIGluZm9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhcmRzOiBhbGxEcmFmdENhcmRzLFxuICAgICAgICBjcmVhdGVkQXQ6IG1vc3RSZWNlbnRUaW1lc3RhbXAsXG4gICAgICAgIGNvdW50OiBhbGxEcmFmdENhcmRzLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgcmVjZW50IGRyYWZ0IGJhdGNoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSdW4gY2xlYW51cCBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNsZWFudXBFeHBpcmVkSm9icygpO1xuICB9LCBbY2xlYW51cEV4cGlyZWRKb2JzXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50Sm9iSWQsXG4gICAgc2V0Q3VycmVudEpvYklkLFxuICAgIGdlbmVyYXRpb25Qcm9ncmVzcyxcbiAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBnZW5lcmF0aW9uU3RhcnRUaW1lLFxuICAgIHNldEdlbmVyYXRpb25TdGFydFRpbWUsXG4gICAgY3VycmVudEVsYXBzZWRUaW1lLFxuICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZSxcbiAgICBlbGFwc2VkVGltZUludGVydmFsLFxuICAgIHNldEVsYXBzZWRUaW1lSW50ZXJ2YWwsXG4gICAgZ2VuZXJhdGlvbkR1cmF0aW9uLFxuICAgIHNldEdlbmVyYXRpb25EdXJhdGlvbixcbiAgICBzYXZlSm9iVG9TdG9yYWdlLFxuICAgIHVwZGF0ZUpvYlByb2dyZXNzLFxuICAgIHJlbW92ZUpvYkZyb21TdG9yYWdlLFxuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBjbGVhckFsbEpvYkRhdGEsXG4gICAgY2hlY2tQZW5kaW5nSm9icyxcbiAgICBsb2FkTW9zdFJlY2VudERyYWZ0QmF0Y2gsXG4gICAgY2xlYW51cEV4cGlyZWRKb2JzXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VKb2JNYW5hZ2VtZW50IiwiY3VycmVudEpvYklkIiwic2V0Q3VycmVudEpvYklkIiwiZ2VuZXJhdGlvblByb2dyZXNzIiwic2V0R2VuZXJhdGlvblByb2dyZXNzIiwicHJvZ3Jlc3NQZXJjZW50YWdlIiwic2V0UHJvZ3Jlc3NQZXJjZW50YWdlIiwiZ2VuZXJhdGlvblN0YXJ0VGltZSIsInNldEdlbmVyYXRpb25TdGFydFRpbWUiLCJjdXJyZW50RWxhcHNlZFRpbWUiLCJzZXRDdXJyZW50RWxhcHNlZFRpbWUiLCJlbGFwc2VkVGltZUludGVydmFsIiwic2V0RWxhcHNlZFRpbWVJbnRlcnZhbCIsImdlbmVyYXRpb25EdXJhdGlvbiIsInNldEdlbmVyYXRpb25EdXJhdGlvbiIsImN1cnJlbnRKb2JUeXBlIiwic2V0Q3VycmVudEpvYlR5cGUiLCJzYXZlSm9iVG9TdG9yYWdlIiwiam9iSWQiLCJqb2JEYXRhIiwiZW5oYW5jZWRKb2JEYXRhIiwiaWQiLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwibGFzdFByb2dyZXNzIiwibGFzdFByb2dyZXNzVGV4dCIsImVsYXBzZWRUaW1lIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwZW5kaW5nSm9icyIsInBhcnNlIiwiZ2V0SXRlbSIsImluY2x1ZGVzIiwicHVzaCIsImNsZWFudXBFeHBpcmVkSm9icyIsImVycm9yIiwiY29uc29sZSIsInVwZGF0ZUpvYlByb2dyZXNzIiwicHJvZ3Jlc3MiLCJwcm9ncmVzc1RleHQiLCJqb2IiLCJsYXN0VXBkYXRlIiwicmVtb3ZlSm9iRnJvbVN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwidXBkYXRlZEpvYnMiLCJmaWx0ZXIiLCJrZXlzVG9SZW1vdmUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInN0YXJ0c1dpdGgiLCJsb2ciLCJsZW5ndGgiLCJjbGVhbmVkSm9icyIsInN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyIsInN0YXJ0IiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwic3RvcEVsYXBzZWRUaW1lVHJhY2tpbmciLCJjbGVhckFsbEpvYkRhdGEiLCJjaGVja1BlbmRpbmdKb2JzIiwiam9ic0RhdGEiLCJsb2FkTW9zdFJlY2VudERyYWZ0QmF0Y2giLCJkcmFmdEpvYktleXMiLCJkcmFmdEpvYnMiLCJoYXNEcmFmdENhcmRzIiwiZHJhZnRDYXJkcyIsImNhcmRDb3VudCIsIkFycmF5IiwiaXNBcnJheSIsImUiLCJzb3J0IiwiYSIsImIiLCJtb3N0UmVjZW50VGltZXN0YW1wIiwicmVjZW50QmF0Y2giLCJNYXRoIiwiYWJzIiwiZHJhZnRDYXJkTWFwIiwiTWFwIiwiZHJhZnRDYXJkIiwiZHJhZnRJbmRleCIsInVuZGVmaW5lZCIsInBhcnNlSW50IiwibWF0Y2giLCJoYXMiLCJzZXQiLCJhbGxEcmFmdENhcmRzIiwiZnJvbSIsImVudHJpZXMiLCJtYXAiLCJfIiwiY2FyZCIsImNhcmRzIiwiY291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts\n"));

/***/ })

});
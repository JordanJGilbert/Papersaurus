"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardForm.tsx":
/*!*******************************!*\
  !*** ./hooks/useCardForm.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardForm: function() { return /* binding */ useCardForm; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useCardForm auto */ var _s = $RefreshSig$();\n\nconst defaultFormData = {\n    // Step 1: Card Basics\n    selectedType: \"birthday\",\n    customCardType: \"\",\n    selectedTone: \"funny\",\n    toField: \"\",\n    fromField: \"\",\n    relationshipField: \"\",\n    // Step 2: Content Creation\n    prompt: \"\",\n    finalCardMessage: \"\",\n    isHandwrittenMessage: false,\n    // Step 3: Personalization\n    selectedArtisticStyle: \"watercolor\",\n    customStyleDescription: \"\",\n    referenceImages: [],\n    referenceImageUrls: [],\n    imageTransformation: \"\",\n    // Step 4: Details\n    userEmail: \"\",\n    selectedImageModel: \"gpt-image-1\",\n    selectedDraftModel: \"gpt-image-1\",\n    selectedPaperSize: \"standard\",\n    numberOfCards: 1,\n    isFrontBackOnly: false\n};\n// Storage keys for persistence\nconst FORM_DATA_KEY = \"vibecarding-wizard-form-data\";\nconst WIZARD_STATE_KEY = \"vibecarding-wizard-state\";\n// Helper function to safely store data (handles quota issues)\nconst safeSetItem = (key, value)=>{\n    try {\n        localStorage.setItem(key, value);\n        return true;\n    } catch (error) {\n        console.warn(\"Failed to save \".concat(key, \" to localStorage:\"), error);\n        return false;\n    }\n};\n// Helper function to safely retrieve data\nconst safeGetItem = (key)=>{\n    try {\n        return localStorage.getItem(key);\n    } catch (error) {\n        console.warn(\"Failed to retrieve \".concat(key, \" from localStorage:\"), error);\n        return null;\n    }\n};\n// Helper function to create serializable form data (excludes File objects)\nconst createSerializableFormData = (formData)=>{\n    const { referenceImages, ...serializableData } = formData;\n    return serializableData;\n};\n// Helper function to restore form data from storage\nconst restoreFormDataFromStorage = ()=>{\n    try {\n        const savedData = safeGetItem(FORM_DATA_KEY);\n        if (!savedData) return defaultFormData;\n        const parsedData = JSON.parse(savedData);\n        // Merge with default data to ensure all fields exist\n        return {\n            ...defaultFormData,\n            ...parsedData,\n            referenceImages: []\n        };\n    } catch (error) {\n        console.warn(\"Failed to restore form data from localStorage:\", error);\n        return defaultFormData;\n    }\n};\nfunction useCardForm() {\n    _s();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultFormData);\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Initialize form data from storage on component mount (after hydration)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ( true && !isInitialLoadComplete) {\n            const restoredData = restoreFormDataFromStorage();\n            setFormData(restoredData);\n            setIsInitialLoadComplete(true);\n        }\n    }, [\n        isInitialLoadComplete\n    ]);\n    // Save form data to localStorage whenever it changes (debounced)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialLoadComplete) return;\n        const timeoutId = setTimeout(()=>{\n            const serializableData = createSerializableFormData(formData);\n            safeSetItem(FORM_DATA_KEY, JSON.stringify(serializableData));\n        }, 500); // Debounce by 500ms\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        formData,\n        isInitialLoadComplete\n    ]);\n    const updateFormData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setFormData((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const resetForm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFormData(defaultFormData);\n        // Clear stored data\n        try {\n            localStorage.removeItem(FORM_DATA_KEY);\n        } catch (error) {\n            console.warn(\"Failed to clear form data from localStorage:\", error);\n        }\n    }, []);\n    const clearStoredData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        try {\n            localStorage.removeItem(FORM_DATA_KEY);\n            localStorage.removeItem(WIZARD_STATE_KEY);\n        } catch (error) {\n            console.warn(\"Failed to clear stored data:\", error);\n        }\n    }, []);\n    const validateStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        switch(step){\n            case 1:\n                // Card type is required\n                if (!formData.selectedType) return false;\n                // If custom type is selected, custom description is required\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) return false;\n                // Tone is required\n                if (!formData.selectedTone) return false;\n                // If photos are uploaded, they must have descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    // Check if we have photoReferences data\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) return false;\n                    // Check if all photos have descriptions\n                    const allHaveDescriptions = formData.photoReferences.every((ref)=>ref.description && ref.description.trim());\n                    if (!allHaveDescriptions) return false;\n                }\n                return true;\n            case 2:\n                // All fields are optional - let AI generate defaults\n                return true;\n            case 3:\n                // All fields are optional\n                // If custom style is selected, description is required\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) return false;\n                // If reference images with incompatible model\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") return false;\n                return true;\n            case 4:\n                // Email is required\n                if (!formData.userEmail.trim()) return false;\n                // Basic email validation\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                if (!emailRegex.test(formData.userEmail)) return false;\n                return true;\n            case 5:\n                // All previous steps must be valid\n                return validateStep(1) && validateStep(2) && validateStep(3) && validateStep(4);\n            default:\n                return false;\n        }\n    }, [\n        formData\n    ]);\n    const getStepSummary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const summary = [];\n        switch(step){\n            case 1:\n                const cardType = formData.selectedType === \"custom\" ? formData.customCardType : formData.selectedType;\n                summary.push(\"Card Type: \".concat(cardType || \"Not selected\"));\n                summary.push(\"Tone: \".concat(formData.selectedTone || \"Not selected\"));\n                if (formData.toField) summary.push(\"To: \".concat(formData.toField));\n                if (formData.fromField) summary.push(\"From: \".concat(formData.fromField));\n                break;\n            case 2:\n                if (formData.prompt) summary.push(\"Description: \".concat(formData.prompt.substring(0, 50), \"...\"));\n                if (formData.finalCardMessage) summary.push(\"Message: \".concat(formData.finalCardMessage.substring(0, 50), \"...\"));\n                if (formData.isHandwrittenMessage) summary.push(\"Handwritten message space included\");\n                break;\n            case 3:\n                summary.push(\"Style: \".concat(formData.selectedArtisticStyle));\n                if (formData.referenceImageUrls.length > 0) {\n                    summary.push(\"Reference photos: \".concat(formData.referenceImageUrls.length, \" uploaded\"));\n                }\n                break;\n            case 4:\n                summary.push(\"Email: \".concat(formData.userEmail));\n                summary.push(\"Model: \".concat(formData.selectedImageModel));\n                summary.push(\"Paper: \".concat(formData.selectedPaperSize));\n                if (formData.isFrontBackOnly) summary.push(\"Front/back only\");\n                break;\n        }\n        return summary;\n    }, [\n        formData\n    ]);\n    const getValidationErrors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const errors = [];\n        switch(step){\n            case 1:\n                if (!formData.selectedType) errors.push(\"Please select a card type\");\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) {\n                    errors.push(\"Please describe your custom card type\");\n                }\n                if (!formData.selectedTone) errors.push(\"Please select a tone\");\n                // Check photo descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) {\n                        errors.push(\"Please describe who's in your photos\");\n                    } else {\n                        const missingDescriptions = formData.photoReferences.filter((ref)=>!ref.description || !ref.description.trim()).length;\n                        if (missingDescriptions > 0) {\n                            errors.push(\"Please describe who's in \".concat(missingDescriptions, \" photo\").concat(missingDescriptions > 1 ? \"s\" : \"\"));\n                        }\n                    }\n                }\n                break;\n            case 3:\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) {\n                    errors.push(\"Please describe your custom artistic style\");\n                }\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") {\n                    errors.push(\"Reference photos are only supported with GPT Image 1 model\");\n                }\n                break;\n            case 4:\n                if (!formData.userEmail.trim()) {\n                    errors.push(\"Email address is required\");\n                } else {\n                    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                    if (!emailRegex.test(formData.userEmail)) {\n                        errors.push(\"Please enter a valid email address\");\n                    }\n                }\n                break;\n        }\n        return errors;\n    }, [\n        formData\n    ]);\n    return {\n        formData,\n        updateFormData,\n        resetForm,\n        clearStoredData,\n        validateStep,\n        getStepSummary,\n        getValidationErrors,\n        isInitialLoadComplete\n    };\n}\n_s(useCardForm, \"YE2fe0fHZ97w2jIa4AHNqZm6dc4=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRXlEO0FBaUN6RCxNQUFNRyxrQkFBZ0M7SUFDcEMsc0JBQXNCO0lBQ3RCQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsbUJBQW1CO0lBRW5CLDJCQUEyQjtJQUMzQkMsUUFBUTtJQUNSQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUV0QiwwQkFBMEI7SUFDMUJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxpQkFBaUIsRUFBRTtJQUNuQkMsb0JBQW9CLEVBQUU7SUFDdEJDLHFCQUFxQjtJQUVyQixrQkFBa0I7SUFDbEJDLFdBQVc7SUFDWEMsb0JBQW9CO0lBQ3BCQyxvQkFBb0I7SUFDcEJDLG1CQUFtQjtJQUNuQkMsZUFBZTtJQUNmQyxpQkFBaUI7QUFDbkI7QUFFQSwrQkFBK0I7QUFDL0IsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLG1CQUFtQjtBQUV6Qiw4REFBOEQ7QUFDOUQsTUFBTUMsY0FBYyxDQUFDQyxLQUFhQztJQUNoQyxJQUFJO1FBQ0ZDLGFBQWFDLE9BQU8sQ0FBQ0gsS0FBS0M7UUFDMUIsT0FBTztJQUNULEVBQUUsT0FBT0csT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsa0JBQXNCLE9BQUpOLEtBQUksc0JBQW9CSTtRQUN2RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxNQUFNRyxjQUFjLENBQUNQO0lBQ25CLElBQUk7UUFDRixPQUFPRSxhQUFhTSxPQUFPLENBQUNSO0lBQzlCLEVBQUUsT0FBT0ksT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsc0JBQTBCLE9BQUpOLEtBQUksd0JBQXNCSTtRQUM3RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDJFQUEyRTtBQUMzRSxNQUFNSyw2QkFBNkIsQ0FBQ0M7SUFDbEMsTUFBTSxFQUFFdEIsZUFBZSxFQUFF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QUFTbkIsU0FBUyxDQUFDMkMsSUFBSSxJQUFJO29CQUM5QmUsT0FBT0gsSUFBSSxDQUFDO2dCQUNkLE9BQU87b0JBQ0wsTUFBTUwsYUFBYTtvQkFDbkIsSUFBSSxDQUFDQSxXQUFXQyxJQUFJLENBQUNoQyxTQUFTbkIsU0FBUyxHQUFHO3dCQUN4QzBELE9BQU9ILElBQUksQ0FBQztvQkFDZDtnQkFDRjtnQkFDQTtRQUNKO1FBRUEsT0FBT0c7SUFDVCxHQUFHO1FBQUN2QztLQUFTO0lBRWIsT0FBTztRQUNMQTtRQUNBZ0I7UUFDQUc7UUFDQUU7UUFDQUM7UUFDQVc7UUFDQUs7UUFDQTdCO0lBQ0Y7QUFDRjtHQTdMZ0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeD80YzM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRGb3JtRGF0YSB7XG4gIC8vIFN0ZXAgMTogQ2FyZCBCYXNpY3NcbiAgc2VsZWN0ZWRUeXBlOiBzdHJpbmc7XG4gIGN1c3RvbUNhcmRUeXBlOiBzdHJpbmc7XG4gIHNlbGVjdGVkVG9uZTogc3RyaW5nO1xuICB0b0ZpZWxkOiBzdHJpbmc7XG4gIGZyb21GaWVsZDogc3RyaW5nO1xuICByZWxhdGlvbnNoaXBGaWVsZDogc3RyaW5nO1xuXG4gIC8vIFN0ZXAgMjogQ29udGVudCBDcmVhdGlvblxuICBwcm9tcHQ6IHN0cmluZztcbiAgZmluYWxDYXJkTWVzc2FnZTogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogYm9vbGVhbjtcblxuICAvLyBTdGVwIDM6IFBlcnNvbmFsaXphdGlvblxuICBzZWxlY3RlZEFydGlzdGljU3R5bGU6IHN0cmluZztcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogc3RyaW5nO1xuICByZWZlcmVuY2VJbWFnZXM6IEZpbGVbXTtcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBzdHJpbmdbXTtcbiAgaW1hZ2VUcmFuc2Zvcm1hdGlvbjogc3RyaW5nO1xuICBwaG90b1JlZmVyZW5jZXM/OiBBcnJheTx7IGltYWdlVXJsOiBzdHJpbmc7IGltYWdlSW5kZXg6IG51bWJlcjsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IH0+O1xuXG4gIC8vIFN0ZXAgNDogRGV0YWlsc1xuICB1c2VyRW1haWw6IHN0cmluZztcbiAgc2VsZWN0ZWRJbWFnZU1vZGVsOiBzdHJpbmc7XG4gIHNlbGVjdGVkRHJhZnRNb2RlbDogc3RyaW5nO1xuICBzZWxlY3RlZFBhcGVyU2l6ZTogc3RyaW5nO1xuICBudW1iZXJPZkNhcmRzOiBudW1iZXI7XG4gIGlzRnJvbnRCYWNrT25seTogYm9vbGVhbjtcbn1cblxuY29uc3QgZGVmYXVsdEZvcm1EYXRhOiBDYXJkRm9ybURhdGEgPSB7XG4gIC8vIFN0ZXAgMTogQ2FyZCBCYXNpY3NcbiAgc2VsZWN0ZWRUeXBlOiBcImJpcnRoZGF5XCIsXG4gIGN1c3RvbUNhcmRUeXBlOiBcIlwiLFxuICBzZWxlY3RlZFRvbmU6IFwiZnVubnlcIixcbiAgdG9GaWVsZDogXCJcIixcbiAgZnJvbUZpZWxkOiBcIlwiLFxuICByZWxhdGlvbnNoaXBGaWVsZDogXCJcIixcblxuICAvLyBTdGVwIDI6IENvbnRlbnQgQ3JlYXRpb25cbiAgcHJvbXB0OiBcIlwiLFxuICBmaW5hbENhcmRNZXNzYWdlOiBcIlwiLFxuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogZmFsc2UsXG5cbiAgLy8gU3RlcCAzOiBQZXJzb25hbGl6YXRpb25cbiAgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlOiBcIndhdGVyY29sb3JcIixcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogXCJcIixcbiAgcmVmZXJlbmNlSW1hZ2VzOiBbXSxcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBbXSxcbiAgaW1hZ2VUcmFuc2Zvcm1hdGlvbjogXCJcIixcblxuICAvLyBTdGVwIDQ6IERldGFpbHNcbiAgdXNlckVtYWlsOiBcIlwiLFxuICBzZWxlY3RlZEltYWdlTW9kZWw6IFwiZ3B0LWltYWdlLTFcIixcbiAgc2VsZWN0ZWREcmFmdE1vZGVsOiBcImdwdC1pbWFnZS0xXCIsXG4gIHNlbGVjdGVkUGFwZXJTaXplOiBcInN0YW5kYXJkXCIsXG4gIG51bWJlck9mQ2FyZHM6IDEsXG4gIGlzRnJvbnRCYWNrT25seTogZmFsc2UsXG59O1xuXG4vLyBTdG9yYWdlIGtleXMgZm9yIHBlcnNpc3RlbmNlXG5jb25zdCBGT1JNX0RBVEFfS0VZID0gJ3ZpYmVjYXJkaW5nLXdpemFyZC1mb3JtLWRhdGEnO1xuY29uc3QgV0laQVJEX1NUQVRFX0tFWSA9ICd2aWJlY2FyZGluZy13aXphcmQtc3RhdGUnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2FmZWx5IHN0b3JlIGRhdGEgKGhhbmRsZXMgcXVvdGEgaXNzdWVzKVxuY29uc3Qgc2FmZVNldEl0ZW0gPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBzYXZlICR7a2V5fSB0byBsb2NhbFN0b3JhZ2U6YCwgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSByZXRyaWV2ZSBkYXRhXG5jb25zdCBzYWZlR2V0SXRlbSA9IChrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJldHJpZXZlICR7a2V5fSBmcm9tIGxvY2FsU3RvcmFnZTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc2VyaWFsaXphYmxlIGZvcm0gZGF0YSAoZXhjbHVkZXMgRmlsZSBvYmplY3RzKVxuY29uc3QgY3JlYXRlU2VyaWFsaXphYmxlRm9ybURhdGEgPSAoZm9ybURhdGE6IENhcmRGb3JtRGF0YSk6IE9taXQ8Q2FyZEZvcm1EYXRhLCAncmVmZXJlbmNlSW1hZ2VzJz4gPT4ge1xuICBjb25zdCB7IHJlZmVyZW5jZUltYWdlcywgLi4uc2VyaWFsaXphYmxlRGF0YSB9ID0gZm9ybURhdGE7XG4gIHJldHVybiBzZXJpYWxpemFibGVEYXRhO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlc3RvcmUgZm9ybSBkYXRhIGZyb20gc3RvcmFnZVxuY29uc3QgcmVzdG9yZUZvcm1EYXRhRnJvbVN0b3JhZ2UgPSAoKTogQ2FyZEZvcm1EYXRhID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzYXZlZERhdGEgPSBzYWZlR2V0SXRlbShGT1JNX0RBVEFfS0VZKTtcbiAgICBpZiAoIXNhdmVkRGF0YSkgcmV0dXJuIGRlZmF1bHRGb3JtRGF0YTtcblxuICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHNhdmVkRGF0YSk7XG4gICAgXG4gICAgLy8gTWVyZ2Ugd2l0aCBkZWZhdWx0IGRhdGEgdG8gZW5zdXJlIGFsbCBmaWVsZHMgZXhpc3RcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEZvcm1EYXRhLFxuICAgICAgLi4ucGFyc2VkRGF0YSxcbiAgICAgIHJlZmVyZW5jZUltYWdlczogW10sIC8vIEFsd2F5cyByZXNldCBGaWxlIG9iamVjdHNcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlc3RvcmUgZm9ybSBkYXRhIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICByZXR1cm4gZGVmYXVsdEZvcm1EYXRhO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FyZEZvcm0oKSB7XG4gIGNvbnN0IFtmb3JtRGF0YSwgc2V0Rm9ybURhdGFdID0gdXNlU3RhdGU8Q2FyZEZvcm1EYXRhPihkZWZhdWx0Rm9ybURhdGEpO1xuICBjb25zdCBbaXNJbml0aWFsTG9hZENvbXBsZXRlLCBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIEluaXRpYWxpemUgZm9ybSBkYXRhIGZyb20gc3RvcmFnZSBvbiBjb21wb25lbnQgbW91bnQgKGFmdGVyIGh5ZHJhdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSW5pdGlhbExvYWRDb21wbGV0ZSkge1xuICAgICAgY29uc3QgcmVzdG9yZWREYXRhID0gcmVzdG9yZUZvcm1EYXRhRnJvbVN0b3JhZ2UoKTtcbiAgICAgIHNldEZvcm1EYXRhKHJlc3RvcmVkRGF0YSk7XG4gICAgICBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGUodHJ1ZSk7XG4gICAgfVxuICB9LCBbaXNJbml0aWFsTG9hZENvbXBsZXRlXSk7XG5cbiAgLy8gU2F2ZSBmb3JtIGRhdGEgdG8gbG9jYWxTdG9yYWdlIHdoZW5ldmVyIGl0IGNoYW5nZXMgKGRlYm91bmNlZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzSW5pdGlhbExvYWRDb21wbGV0ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBzZXJpYWxpemFibGVEYXRhID0gY3JlYXRlU2VyaWFsaXphYmxlRm9ybURhdGEoZm9ybURhdGEpO1xuICAgICAgc2FmZVNldEl0ZW0oRk9STV9EQVRBX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXphYmxlRGF0YSkpO1xuICAgIH0sIDUwMCk7IC8vIERlYm91bmNlIGJ5IDUwMG1zXG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH0sIFtmb3JtRGF0YSwgaXNJbml0aWFsTG9hZENvbXBsZXRlXSk7XG5cbiAgY29uc3QgdXBkYXRlRm9ybURhdGEgPSB1c2VDYWxsYmFjaygodXBkYXRlczogUGFydGlhbDxDYXJkRm9ybURhdGE+KSA9PiB7XG4gICAgc2V0Rm9ybURhdGEocHJldiA9PiAoeyAuLi5wcmV2LCAuLi51cGRhdGVzIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlc2V0Rm9ybSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRGb3JtRGF0YShkZWZhdWx0Rm9ybURhdGEpO1xuICAgIC8vIENsZWFyIHN0b3JlZCBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEZPUk1fREFUQV9LRVkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBmb3JtIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNsZWFyU3RvcmVkRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oRk9STV9EQVRBX0tFWSk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShXSVpBUkRfU1RBVEVfS0VZKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xlYXIgc3RvcmVkIGRhdGE6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHZhbGlkYXRlU3RlcCA9IHVzZUNhbGxiYWNrKChzdGVwOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTogLy8gQ2FyZCBCYXNpY3NcbiAgICAgICAgLy8gQ2FyZCB0eXBlIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmICghZm9ybURhdGEuc2VsZWN0ZWRUeXBlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIGN1c3RvbSB0eXBlIGlzIHNlbGVjdGVkLCBjdXN0b20gZGVzY3JpcHRpb24gaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKGZvcm1EYXRhLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiAmJiAhZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUudHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRvbmUgaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFRvbmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgcGhvdG9zIGFyZSB1cGxvYWRlZCwgdGhleSBtdXN0IGhhdmUgZGVzY3JpcHRpb25zXG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcGhvdG9SZWZlcmVuY2VzIGRhdGFcbiAgICAgICAgICBpZiAoIWZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcyB8fCBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHBob3RvcyBoYXZlIGRlc2NyaXB0aW9uc1xuICAgICAgICAgIGNvbnN0IGFsbEhhdmVEZXNjcmlwdGlvbnMgPSBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMuZXZlcnkocmVmID0+IHJlZi5kZXNjcmlwdGlvbiAmJiByZWYuZGVzY3JpcHRpb24udHJpbSgpKTtcbiAgICAgICAgICBpZiAoIWFsbEhhdmVEZXNjcmlwdGlvbnMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSAyOiAvLyBDb250ZW50IENyZWF0aW9uXG4gICAgICAgIC8vIEFsbCBmaWVsZHMgYXJlIG9wdGlvbmFsIC0gbGV0IEFJIGdlbmVyYXRlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDM6IC8vIFBlcnNvbmFsaXphdGlvblxuICAgICAgICAvLyBBbGwgZmllbGRzIGFyZSBvcHRpb25hbFxuICAgICAgICAvLyBJZiBjdXN0b20gc3R5bGUgaXMgc2VsZWN0ZWQsIGRlc2NyaXB0aW9uIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbVN0eWxlRGVzY3JpcHRpb24udHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHJlZmVyZW5jZSBpbWFnZXMgd2l0aCBpbmNvbXBhdGlibGUgbW9kZWxcbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIGZvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbCAhPT0gXCJncHQtaW1hZ2UtMVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDQ6IC8vIERldGFpbHNcbiAgICAgICAgLy8gRW1haWwgaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFmb3JtRGF0YS51c2VyRW1haWwudHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEJhc2ljIGVtYWlsIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChmb3JtRGF0YS51c2VyRW1haWwpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDU6IC8vIEdlbmVyYXRlXG4gICAgICAgIC8vIEFsbCBwcmV2aW91cyBzdGVwcyBtdXN0IGJlIHZhbGlkXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVN0ZXAoMSkgJiYgdmFsaWRhdGVTdGVwKDIpICYmIHZhbGlkYXRlU3RlcCgzKSAmJiB2YWxpZGF0ZVN0ZXAoNCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFtmb3JtRGF0YV0pO1xuXG4gIGNvbnN0IGdldFN0ZXBTdW1tYXJ5ID0gdXNlQ2FsbGJhY2soKHN0ZXA6IG51bWJlcik6IHN0cmluZ1tdID0+IHtcbiAgICBjb25zdCBzdW1tYXJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjb25zdCBjYXJkVHlwZSA9IGZvcm1EYXRhLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGZvcm1EYXRhLmN1c3RvbUNhcmRUeXBlIDogZm9ybURhdGEuc2VsZWN0ZWRUeXBlO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYENhcmQgVHlwZTogJHtjYXJkVHlwZSB8fCBcIk5vdCBzZWxlY3RlZFwifWApO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYFRvbmU6ICR7Zm9ybURhdGEuc2VsZWN0ZWRUb25lIHx8IFwiTm90IHNlbGVjdGVkXCJ9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS50b0ZpZWxkKSBzdW1tYXJ5LnB1c2goYFRvOiAke2Zvcm1EYXRhLnRvRmllbGR9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5mcm9tRmllbGQpIHN1bW1hcnkucHVzaChgRnJvbTogJHtmb3JtRGF0YS5mcm9tRmllbGR9YCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmIChmb3JtRGF0YS5wcm9tcHQpIHN1bW1hcnkucHVzaChgRGVzY3JpcHRpb246ICR7Zm9ybURhdGEucHJvbXB0LnN1YnN0cmluZygwLCA1MCl9Li4uYCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5maW5hbENhcmRNZXNzYWdlKSBzdW1tYXJ5LnB1c2goYE1lc3NhZ2U6ICR7Zm9ybURhdGEuZmluYWxDYXJkTWVzc2FnZS5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xuICAgICAgICBpZiAoZm9ybURhdGEuaXNIYW5kd3JpdHRlbk1lc3NhZ2UpIHN1bW1hcnkucHVzaChcIkhhbmR3cml0dGVuIG1lc3NhZ2Ugc3BhY2UgaW5jbHVkZWRcIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN1bW1hcnkucHVzaChgU3R5bGU6ICR7Zm9ybURhdGEuc2VsZWN0ZWRBcnRpc3RpY1N0eWxlfWApO1xuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdW1tYXJ5LnB1c2goYFJlZmVyZW5jZSBwaG90b3M6ICR7Zm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aH0gdXBsb2FkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA0OlxuICAgICAgICBzdW1tYXJ5LnB1c2goYEVtYWlsOiAke2Zvcm1EYXRhLnVzZXJFbWFpbH1gKTtcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBNb2RlbDogJHtmb3JtRGF0YS5zZWxlY3RlZEltYWdlTW9kZWx9YCk7XG4gICAgICAgIHN1bW1hcnkucHVzaChgUGFwZXI6ICR7Zm9ybURhdGEuc2VsZWN0ZWRQYXBlclNpemV9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5pc0Zyb250QmFja09ubHkpIHN1bW1hcnkucHVzaChcIkZyb250L2JhY2sgb25seVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bW1hcnk7XG4gIH0sIFtmb3JtRGF0YV0pO1xuXG4gIGNvbnN0IGdldFZhbGlkYXRpb25FcnJvcnMgPSB1c2VDYWxsYmFjaygoc3RlcDogbnVtYmVyKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoIWZvcm1EYXRhLnNlbGVjdGVkVHlwZSkgZXJyb3JzLnB1c2goXCJQbGVhc2Ugc2VsZWN0IGEgY2FyZCB0eXBlXCIpO1xuICAgICAgICBpZiAoZm9ybURhdGEuc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiICYmICFmb3JtRGF0YS5jdXN0b21DYXJkVHlwZS50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBkZXNjcmliZSB5b3VyIGN1c3RvbSBjYXJkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFRvbmUpIGVycm9ycy5wdXNoKFwiUGxlYXNlIHNlbGVjdCBhIHRvbmVcIik7XG4gICAgICAgIC8vIENoZWNrIHBob3RvIGRlc2NyaXB0aW9uc1xuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoIWZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcyB8fCBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBkZXNjcmliZSB3aG8ncyBpbiB5b3VyIHBob3Rvc1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0Rlc2NyaXB0aW9ucyA9IGZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcy5maWx0ZXIocmVmID0+ICFyZWYuZGVzY3JpcHRpb24gfHwgIXJlZi5kZXNjcmlwdGlvbi50cmltKCkpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nRGVzY3JpcHRpb25zID4gMCkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChgUGxlYXNlIGRlc2NyaWJlIHdobydzIGluICR7bWlzc2luZ0Rlc2NyaXB0aW9uc30gcGhvdG8ke21pc3NpbmdEZXNjcmlwdGlvbnMgPiAxID8gJ3MnIDogJyd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbVN0eWxlRGVzY3JpcHRpb24udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIGZvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbCAhPT0gXCJncHQtaW1hZ2UtMVwiKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJSZWZlcmVuY2UgcGhvdG9zIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIEdQVCBJbWFnZSAxIG1vZGVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICghZm9ybURhdGEudXNlckVtYWlsLnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiRW1haWwgYWRkcmVzcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoZm9ybURhdGEudXNlckVtYWlsKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9LCBbZm9ybURhdGFdKTtcblxuICByZXR1cm4ge1xuICAgIGZvcm1EYXRhLFxuICAgIHVwZGF0ZUZvcm1EYXRhLFxuICAgIHJlc2V0Rm9ybSxcbiAgICBjbGVhclN0b3JlZERhdGEsXG4gICAgdmFsaWRhdGVTdGVwLFxuICAgIGdldFN0ZXBTdW1tYXJ5LFxuICAgIGdldFZhbGlkYXRpb25FcnJvcnMsXG4gICAgaXNJbml0aWFsTG9hZENvbXBsZXRlLFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsImRlZmF1bHRGb3JtRGF0YSIsInNlbGVjdGVkVHlwZSIsImN1c3RvbUNhcmRUeXBlIiwic2VsZWN0ZWRUb25lIiwidG9GaWVsZCIsImZyb21GaWVsZCIsInJlbGF0aW9uc2hpcEZpZWxkIiwicHJvbXB0IiwiZmluYWxDYXJkTWVzc2FnZSIsImlzSGFuZHdyaXR0ZW5NZXNzYWdlIiwic2VsZWN0ZWRBcnRpc3RpY1N0eWxlIiwiY3VzdG9tU3R5bGVEZXNjcmlwdGlvbiIsInJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlVXJscyIsImltYWdlVHJhbnNmb3JtYXRpb24iLCJ1c2VyRW1haWwiLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJzZWxlY3RlZERyYWZ0TW9kZWwiLCJzZWxlY3RlZFBhcGVyU2l6ZSIsIm51bWJlck9mQ2FyZHMiLCJpc0Zyb250QmFja09ubHkiLCJGT1JNX0RBVEFfS0VZIiwiV0laQVJEX1NUQVRFX0tFWSIsInNhZmVTZXRJdGVtIiwia2V5IiwidmFsdWUiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsInNhZmVHZXRJdGVtIiwiZ2V0SXRlbSIsImNyZWF0ZVNlcmlhbGl6YWJsZUZvcm1EYXRhIiwiZm9ybURhdGEiLCJzZXJpYWxpemFibGVEYXRhIiwicmVzdG9yZUZvcm1EYXRhRnJvbVN0b3JhZ2UiLCJzYXZlZERhdGEiLCJwYXJzZWREYXRhIiwiSlNPTiIsInBhcnNlIiwidXNlQ2FyZEZvcm0iLCJzZXRGb3JtRGF0YSIsImlzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNldElzSW5pdGlhbExvYWRDb21wbGV0ZSIsInJlc3RvcmVkRGF0YSIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJzdHJpbmdpZnkiLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVGb3JtRGF0YSIsInVwZGF0ZXMiLCJwcmV2IiwicmVzZXRGb3JtIiwicmVtb3ZlSXRlbSIsImNsZWFyU3RvcmVkRGF0YSIsInZhbGlkYXRlU3RlcCIsInN0ZXAiLCJ0cmltIiwibGVuZ3RoIiwicGhvdG9SZWZlcmVuY2VzIiwiYWxsSGF2ZURlc2NyaXB0aW9ucyIsImV2ZXJ5IiwicmVmIiwiZGVzY3JpcHRpb24iLCJlbWFpbFJlZ2V4IiwidGVzdCIsImdldFN0ZXBTdW1tYXJ5Iiwic3VtbWFyeSIsImNhcmRUeXBlIiwicHVzaCIsInN1YnN0cmluZyIsImdldFZhbGlkYXRpb25FcnJvcnMiLCJlcnJvcnMiLCJtaXNzaW5nRGVzY3JpcHRpb25zIiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardForm.tsx\n"));

/***/ })

});
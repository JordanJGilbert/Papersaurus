"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts":
/*!**********************************************!*\
  !*** ./hooks/cardStudio/useJobManagement.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useJobManagement: function() { return /* binding */ useJobManagement; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useJobManagement auto */ \nfunction useJobManagement() {\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [progressPercentage, setProgressPercentage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [generationStartTime, setGenerationStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentElapsedTime, setCurrentElapsedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [elapsedTimeInterval, setElapsedTimeInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Job management functions\n    const saveJobToStorage = (jobId, jobData)=>{\n        if (false) {}\n        try {\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify({\n                ...jobData,\n                id: jobId,\n                status: \"processing\",\n                createdAt: Date.now()\n            }));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            if (!pendingJobs.includes(jobId)) {\n                pendingJobs.push(jobId);\n                localStorage.setItem(\"pendingCardJobs\", JSON.stringify(pendingJobs));\n            }\n        } catch (error) {\n            console.error(\"Failed to save job to localStorage:\", error);\n        }\n    };\n    // Remove job from storage\n    const removeJobFromStorage = (jobId)=>{\n        if (false) {}\n        try {\n            localStorage.removeItem(\"cardJob_\".concat(jobId));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const updatedJobs = pendingJobs.filter((id)=>id !== jobId);\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(updatedJobs));\n        } catch (error) {\n            console.error(\"Failed to remove job from localStorage:\", error);\n        }\n    };\n    // Start elapsed time tracking\n    const startElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((startTime, estimatedTotalSeconds)=>{\n        // Always use fresh start time, ignore any old stored values\n        const start = startTime || Date.now();\n        setGenerationStartTime(start);\n        setCurrentElapsedTime(0); // Reset elapsed time\n        setProgressPercentage(0); // Reset progress\n        if (true) {\n            // Clear any old generation time before setting new one\n            localStorage.removeItem(\"generation-start-time\");\n            localStorage.setItem(\"generation-start-time\", start.toString());\n        }\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n        }\n        const interval = setInterval(()=>{\n            const elapsed = (Date.now() - start) / 1000;\n            setCurrentElapsedTime(elapsed);\n            // Only use time-based estimation if we don't have real progress\n            // Don't update percentage here - let WebSocket updates handle it\n            const estimatedTotal = estimatedTotalSeconds || 150;\n            const timeBasedPercentage = Math.min(elapsed / estimatedTotal * 100, 90);\n            // Only set time-based progress if we haven't received WebSocket updates\n            setProgressPercentage((prev)=>{\n                // If we have WebSocket progress (> 0), don't override with time estimation\n                if (prev > 0 && prev < timeBasedPercentage) {\n                    // WebSocket might be lagging, use time estimation as minimum\n                    return Math.max(prev, timeBasedPercentage);\n                } else if (prev === 0) {\n                    // No WebSocket updates yet, use time estimation\n                    return timeBasedPercentage;\n                }\n                return prev;\n            });\n        }, 1000);\n        setElapsedTimeInterval(interval);\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Stop elapsed time tracking\n    const stopElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n            setElapsedTimeInterval(null);\n        }\n        if (true) {\n            localStorage.removeItem(\"generation-start-time\");\n        }\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Clear all job data from localStorage\n    const clearAllJobData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        console.log(\"\\uD83E\\uDDF9 Clearing all job data from localStorage\");\n        // Get all keys\n        const keys = Object.keys(localStorage);\n        // Remove all job-related keys\n        keys.forEach((key)=>{\n            if (key.startsWith(\"cardJob_\") || key === \"pendingCardJobs\" || key === \"generation-start-time\") {\n                localStorage.removeItem(key);\n            }\n        });\n        // Reset state\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setGenerationStartTime(null);\n    }, []);\n    // Recovery function - resume WebSocket subscriptions for pending jobs\n    const checkPendingJobs = async ()=>{\n        if (false) {}\n        try {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const jobsData = [];\n            for (const jobId of pendingJobs){\n                const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n                if (!jobData) continue;\n                const job = JSON.parse(jobData);\n                jobsData.push({\n                    jobId,\n                    job\n                });\n            }\n            return jobsData;\n        } catch (error) {\n            console.error(\"Failed to check pending jobs:\", error);\n            return [];\n        }\n    };\n    return {\n        currentJobId,\n        setCurrentJobId,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        generationStartTime,\n        setGenerationStartTime,\n        currentElapsedTime,\n        setCurrentElapsedTime,\n        elapsedTimeInterval,\n        setElapsedTimeInterval,\n        generationDuration,\n        setGenerationDuration,\n        saveJobToStorage,\n        removeJobFromStorage,\n        startElapsedTimeTracking,\n        stopElapsedTimeTracking,\n        checkPendingJobs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlSm9iTWFuYWdlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7c0VBRXlEO0FBSWxELFNBQVNFO0lBQ2QsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR0osK0NBQVFBLENBQWdCO0lBQ2hFLE1BQU0sQ0FBQ0ssb0JBQW9CQyxzQkFBc0IsR0FBR04sK0NBQVFBLENBQVM7SUFDckUsTUFBTSxDQUFDTyxvQkFBb0JDLHNCQUFzQixHQUFHUiwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUNTLHFCQUFxQkMsdUJBQXVCLEdBQUdWLCtDQUFRQSxDQUFnQjtJQUM5RSxNQUFNLENBQUNXLG9CQUFvQkMsc0JBQXNCLEdBQUdaLCtDQUFRQSxDQUFTO0lBQ3JFLE1BQU0sQ0FBQ2EscUJBQXFCQyx1QkFBdUIsR0FBR2QsK0NBQVFBLENBQXdCO0lBQ3RGLE1BQU0sQ0FBQ2Usb0JBQW9CQyxzQkFBc0IsR0FBR2hCLCtDQUFRQSxDQUFnQjtJQUU1RSwyQkFBMkI7SUFDM0IsTUFBTWlCLG1CQUFtQixDQUFDQyxPQUFlQztRQUN2QyxJQUFJLEtBQWtCLEVBQWEsRUFBTztRQUUxQyxJQUFJO1lBQ0ZDLGFBQWFDLE9BQU8sQ0FBQyxXQUFpQixPQUFOSCxRQUFTSSxLQUFLQyxTQUFTLENBQUM7Z0JBQ3RELEdBQUdKLE9BQU87Z0JBQ1ZLLElBQUlOO2dCQUNKTyxRQUFRO2dCQUNSQyxXQUFXQyxLQUFLQyxHQUFHO1lBQ3JCO1lBRUEsTUFBTUMsY0FBY1AsS0FBS1EsS0FBSyxDQUFDVixhQUFhVyxPQUFPLENBQUMsc0JBQXNCO1lBQzFFLElBQUksQ0FBQ0YsWUFBWUcsUUFBUSxDQUFDZCxRQUFRO2dCQUNoQ1csWUFBWUksSUFBSSxDQUFDZjtnQkFDakJFLGFBQWFDLE9BQU8sQ0FBQyxtQkFBbUJDLEtBQUtDLFNBQVMsQ0FBQ007WUFDekQ7UUFDRixFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFD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MUUsTUFBTWlDLFdBQVcsRUFBRTtZQUVuQixLQUFLLE1BQU05QyxTQUFTVyxZQUFhO2dCQUMvQixNQUFNVixVQUFVQyxhQUFhVyxPQUFPLENBQUMsV0FBaUIsT0FBTmI7Z0JBQ2hELElBQUksQ0FBQ0MsU0FBUztnQkFFZCxNQUFNOEMsTUFBTTNDLEtBQUtRLEtBQUssQ0FBQ1g7Z0JBQ3ZCNkMsU0FBUy9CLElBQUksQ0FBQztvQkFBRWY7b0JBQU8rQztnQkFBSTtZQUM3QjtZQUVBLE9BQU9EO1FBQ1QsRUFBRSxPQUFPOUIsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsT0FBTztRQUNML0I7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQW1CO1FBQ0FJO1FBQ0FlO1FBQ0FRO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy9jYXJkU3R1ZGlvL3VzZUpvYk1hbmFnZW1lbnQudHM/ZmM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgR2VuZXJhdGVkQ2FyZCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUpvYk1hbmFnZW1lbnQoKSB7XG4gIGNvbnN0IFtjdXJyZW50Sm9iSWQsIHNldEN1cnJlbnRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRpb25Qcm9ncmVzcywgc2V0R2VuZXJhdGlvblByb2dyZXNzXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtwcm9ncmVzc1BlcmNlbnRhZ2UsIHNldFByb2dyZXNzUGVyY2VudGFnZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbZ2VuZXJhdGlvblN0YXJ0VGltZSwgc2V0R2VuZXJhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRFbGFwc2VkVGltZSwgc2V0Q3VycmVudEVsYXBzZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtlbGFwc2VkVGltZUludGVydmFsLCBzZXRFbGFwc2VkVGltZUludGVydmFsXSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uRHVyYXRpb24sIHNldEdlbmVyYXRpb25EdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAvLyBKb2IgbWFuYWdlbWVudCBmdW5jdGlvbnNcbiAgY29uc3Qgc2F2ZUpvYlRvU3RvcmFnZSA9IChqb2JJZDogc3RyaW5nLCBqb2JEYXRhOiBhbnkpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIC4uLmpvYkRhdGEsXG4gICAgICAgIGlkOiBqb2JJZCxcbiAgICAgICAgc3RhdHVzOiAncHJvY2Vzc2luZycsXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zdCBwZW5kaW5nSm9icyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycpIHx8ICdbXScpO1xuICAgICAgaWYgKCFwZW5kaW5nSm9icy5pbmNsdWRlcyhqb2JJZCkpIHtcbiAgICAgICAgcGVuZGluZ0pvYnMucHVzaChqb2JJZCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnLCBKU09OLnN0cmluZ2lmeShwZW5kaW5nSm9icykpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBqb2IgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGpvYiBmcm9tIHN0b3JhZ2VcbiAgY29uc3QgcmVtb3ZlSm9iRnJvbVN0b3JhZ2UgPSAoam9iSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShgY2FyZEpvYl8ke2pvYklkfWApO1xuICAgICAgXG4gICAgICBjb25zdCBwZW5kaW5nSm9icyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycpIHx8ICdbXScpO1xuICAgICAgY29uc3QgdXBkYXRlZEpvYnMgPSBwZW5kaW5nSm9icy5maWx0ZXIoKGlkOiBzdHJpbmcpID0+IGlkICE9PSBqb2JJZCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZEpvYnMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbW92ZSBqb2IgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTdGFydCBlbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgY29uc3Qgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nID0gdXNlQ2FsbGJhY2soKHN0YXJ0VGltZT86IG51bWJlciwgZXN0aW1hdGVkVG90YWxTZWNvbmRzPzogbnVtYmVyKSA9PiB7XG4gICAgLy8gQWx3YXlzIHVzZSBmcmVzaCBzdGFydCB0aW1lLCBpZ25vcmUgYW55IG9sZCBzdG9yZWQgdmFsdWVzXG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICBzZXRHZW5lcmF0aW9uU3RhcnRUaW1lKHN0YXJ0KTtcbiAgICBzZXRDdXJyZW50RWxhcHNlZFRpbWUoMCk7IC8vIFJlc2V0IGVsYXBzZWQgdGltZVxuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTsgLy8gUmVzZXQgcHJvZ3Jlc3NcbiAgICBcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIENsZWFyIGFueSBvbGQgZ2VuZXJhdGlvbiB0aW1lIGJlZm9yZSBzZXR0aW5nIG5ldyBvbmVcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdnZW5lcmF0aW9uLXN0YXJ0LXRpbWUnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnZW5lcmF0aW9uLXN0YXJ0LXRpbWUnLCBzdGFydC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGVsYXBzZWRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZWxhcHNlZFRpbWVJbnRlcnZhbCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMDtcbiAgICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZShlbGFwc2VkKTtcbiAgICAgIFxuICAgICAgLy8gT25seSB1c2UgdGltZS1iYXNlZCBlc3RpbWF0aW9uIGlmIHdlIGRvbid0IGhhdmUgcmVhbCBwcm9ncmVzc1xuICAgICAgLy8gRG9uJ3QgdXBkYXRlIHBlcmNlbnRhZ2UgaGVyZSAtIGxldCBXZWJTb2NrZXQgdXBkYXRlcyBoYW5kbGUgaXRcbiAgICAgIGNvbnN0IGVzdGltYXRlZFRvdGFsID0gZXN0aW1hdGVkVG90YWxTZWNvbmRzIHx8IDE1MDtcbiAgICAgIGNvbnN0IHRpbWVCYXNlZFBlcmNlbnRhZ2UgPSBNYXRoLm1pbigoZWxhcHNlZCAvIGVzdGltYXRlZFRvdGFsKSAqIDEwMCwgOTApO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHNldCB0aW1lLWJhc2VkIHByb2dyZXNzIGlmIHdlIGhhdmVuJ3QgcmVjZWl2ZWQgV2ViU29ja2V0IHVwZGF0ZXNcbiAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZShwcmV2ID0+IHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBXZWJTb2NrZXQgcHJvZ3Jlc3MgKD4gMCksIGRvbid0IG92ZXJyaWRlIHdpdGggdGltZSBlc3RpbWF0aW9uXG4gICAgICAgIGlmIChwcmV2ID4gMCAmJiBwcmV2IDwgdGltZUJhc2VkUGVyY2VudGFnZSkge1xuICAgICAgICAgIC8vIFdlYlNvY2tldCBtaWdodCBiZSBsYWdnaW5nLCB1c2UgdGltZSBlc3RpbWF0aW9uIGFzIG1pbmltdW1cbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgdGltZUJhc2VkUGVyY2VudGFnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldiA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vIFdlYlNvY2tldCB1cGRhdGVzIHlldCwgdXNlIHRpbWUgZXN0aW1hdGlvblxuICAgICAgICAgIHJldHVybiB0aW1lQmFzZWRQZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSk7XG4gICAgfSwgMTAwMCk7XG4gICAgXG4gICAgc2V0RWxhcHNlZFRpbWVJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtlbGFwc2VkVGltZUludGVydmFsXSk7XG5cbiAgLy8gU3RvcCBlbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgY29uc3Qgc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGVsYXBzZWRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZWxhcHNlZFRpbWVJbnRlcnZhbCk7XG4gICAgICBzZXRFbGFwc2VkVGltZUludGVydmFsKG51bGwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdnZW5lcmF0aW9uLXN0YXJ0LXRpbWUnKTtcbiAgICB9XG4gIH0sIFtlbGFwc2VkVGltZUludGVydmFsXSk7XG5cbiAgLy8gQ2xlYXIgYWxsIGpvYiBkYXRhIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGNsZWFyQWxsSm9iRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+nuSBDbGVhcmluZyBhbGwgam9iIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UnKTtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGtleXNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgYWxsIGpvYi1yZWxhdGVkIGtleXNcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnY2FyZEpvYl8nKSB8fCBrZXkgPT09ICdwZW5kaW5nQ2FyZEpvYnMnIHx8IGtleSA9PT0gJ2dlbmVyYXRpb24tc3RhcnQtdGltZScpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZXNldCBzdGF0ZVxuICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZSgwKTtcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMCk7XG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZShudWxsKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJlY292ZXJ5IGZ1bmN0aW9uIC0gcmVzdW1lIFdlYlNvY2tldCBzdWJzY3JpcHRpb25zIGZvciBwZW5kaW5nIGpvYnNcbiAgY29uc3QgY2hlY2tQZW5kaW5nSm9icyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IGpvYnNEYXRhID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgam9iSWQgb2YgcGVuZGluZ0pvYnMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICAgIGlmICgham9iRGF0YSkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBqb2IgPSBKU09OLnBhcnNlKGpvYkRhdGEpO1xuICAgICAgICBqb2JzRGF0YS5wdXNoKHsgam9iSWQsIGpvYiB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGpvYnNEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgcGVuZGluZyBqb2JzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50Sm9iSWQsXG4gICAgc2V0Q3VycmVudEpvYklkLFxuICAgIGdlbmVyYXRpb25Qcm9ncmVzcyxcbiAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBnZW5lcmF0aW9uU3RhcnRUaW1lLFxuICAgIHNldEdlbmVyYXRpb25TdGFydFRpbWUsXG4gICAgY3VycmVudEVsYXBzZWRUaW1lLFxuICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZSxcbiAgICBlbGFwc2VkVGltZUludGVydmFsLFxuICAgIHNldEVsYXBzZWRUaW1lSW50ZXJ2YWwsXG4gICAgZ2VuZXJhdGlvbkR1cmF0aW9uLFxuICAgIHNldEdlbmVyYXRpb25EdXJhdGlvbixcbiAgICBzYXZlSm9iVG9TdG9yYWdlLFxuICAgIHJlbW92ZUpvYkZyb21TdG9yYWdlLFxuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBjaGVja1BlbmRpbmdKb2JzXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VKb2JNYW5hZ2VtZW50IiwiY3VycmVudEpvYklkIiwic2V0Q3VycmVudEpvYklkIiwiZ2VuZXJhdGlvblByb2dyZXNzIiwic2V0R2VuZXJhdGlvblByb2dyZXNzIiwicHJvZ3Jlc3NQZXJjZW50YWdlIiwic2V0UHJvZ3Jlc3NQZXJjZW50YWdlIiwiZ2VuZXJhdGlvblN0YXJ0VGltZSIsInNldEdlbmVyYXRpb25TdGFydFRpbWUiLCJjdXJyZW50RWxhcHNlZFRpbWUiLCJzZXRDdXJyZW50RWxhcHNlZFRpbWUiLCJlbGFwc2VkVGltZUludGVydmFsIiwic2V0RWxhcHNlZFRpbWVJbnRlcnZhbCIsImdlbmVyYXRpb25EdXJhdGlvbiIsInNldEdlbmVyYXRpb25EdXJhdGlvbiIsInNhdmVKb2JUb1N0b3JhZ2UiLCJqb2JJZCIsImpvYkRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImlkIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdyIsInBlbmRpbmdKb2JzIiwicGFyc2UiLCJnZXRJdGVtIiwiaW5jbHVkZXMiLCJwdXNoIiwiZXJyb3IiLCJjb25zb2xlIiwicmVtb3ZlSm9iRnJvbVN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwidXBkYXRlZEpvYnMiLCJmaWx0ZXIiLCJzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmciLCJzdGFydFRpbWUiLCJlc3RpbWF0ZWRUb3RhbFNlY29uZHMiLCJzdGFydCIsInRvU3RyaW5nIiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwiZXN0aW1hdGVkVG90YWwiLCJ0aW1lQmFzZWRQZXJjZW50YWdlIiwiTWF0aCIsIm1pbiIsInByZXYiLCJtYXgiLCJzdG9wRWxhcHNlZFRpbWVUcmFja2luZyIsImNsZWFyQWxsSm9iRGF0YSIsImxvZyIsImtleXMiLCJPYmplY3QiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRzV2l0aCIsImNoZWNrUGVuZGluZ0pvYnMiLCJqb2JzRGF0YSIsImpvYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts\n"));

/***/ })

});
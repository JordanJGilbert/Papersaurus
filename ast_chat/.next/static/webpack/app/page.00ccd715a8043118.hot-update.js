"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/wizard/CardWizardEffects.tsx":
/*!*************************************************!*\
  !*** ./components/wizard/CardWizardEffects.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CardWizardEffects: function() { return /* binding */ CardWizardEffects; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ CardWizardEffects auto */ var _s = $RefreshSig$();\n\nfunction CardWizardEffects(param) {\n    let { cardStudio, cardForm, cardHistory, wizardState, updateWizardState, isResumingDraft, isRestoringJobs } = param;\n    _s();\n    // Track the current session ID to update the same session\n    const [currentDraftSessionId, setCurrentDraftSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [lastSavedDraftCount, setLastSavedDraftCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Check for pending jobs on component mount but don't auto-navigate\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const restorePendingJobs = async ()=>{\n            console.log(\"\\uD83D\\uDD04 CardWizardEffects: Starting checkPendingJobs...\");\n            // First check for saved draft session\n            let currentSession = null;\n            try {\n                currentSession = JSON.parse(localStorage.getItem(\"vibe-current-draft-session\") || \"null\");\n            } catch (e) {\n                currentSession = null;\n            }\n            if (currentSession && currentSession.draftCards && currentSession.draftCards.length > 0) {\n                console.log(\"\\uD83D\\uDD04 Found saved draft session with\", currentSession.draftCards.length, \"drafts\");\n                // Check if draft is less than 2 hours old\n                const draftAge = Date.now() - new Date(currentSession.savedAt).getTime();\n                const twoHours = 2 * 60 * 60 * 1000;\n                if (draftAge < twoHours) {\n                    // Restore draft cards but don't navigate\n                    cardStudio.setDraftCards(currentSession.draftCards);\n                    cardStudio.setIsDraftMode(true);\n                    // Restore form data if needed\n                    if (currentSession.formData) {\n                        cardForm.updateFormData(currentSession.formData);\n                    }\n                    // Don't auto-navigate - let user choose via Resume Draft button\n                    console.log(\"\\uD83D\\uDD04 Draft session restored, user can resume via UI\");\n                    // Set the current session ID for updates\n                    setCurrentDraftSessionId(currentSession.id);\n                    setLastSavedDraftCount(currentSession.draftCards.length);\n                } else {\n                    // Draft is too old, remove it\n                    console.log(\"\\uD83D\\uDD04 Draft session expired, removing...\");\n                    localStorage.removeItem(\"vibe-current-draft-session\");\n                    cardHistory.removeDraftSession(currentSession.id);\n                }\n                return; // Skip pending jobs check if we processed a draft session\n            }\n            await cardStudio.checkPendingJobs();\n            // Only auto-navigate if there's an active generation in progress\n            // Don't navigate for completed drafts - let user choose\n            if (cardStudio.isGenerating && cardStudio.generationProgress) {\n                if (cardStudio.isGeneratingFinalCard) {\n                    console.log(\"\\uD83D\\uDD04 Restoring to Step 6 due to ongoing final generation\");\n                    // Mark all previous steps as completed\n                    for(let i = 1; i <= 5; i++){\n                        if (!wizardState.completedSteps.includes(i)) wizardState.markStepCompleted(i);\n                    }\n                    wizardState.updateCurrentStep(6);\n                } else if (cardStudio.isDraftMode && cardStudio.isGenerating) {\n                    console.log(\"\\uD83D\\uDD04 Restoring to Step 5 due to ongoing draft generation\");\n                    // Mark previous steps as completed\n                    if (!wizardState.completedSteps.includes(1)) wizardState.markStepCompleted(1);\n                    if (!wizardState.completedSteps.includes(2)) wizardState.markStepCompleted(2);\n                    if (!wizardState.completedSteps.includes(3)) wizardState.markStepCompleted(3);\n                    if (!wizardState.completedSteps.includes(4)) wizardState.markStepCompleted(4);\n                    wizardState.updateCurrentStep(5);\n                }\n            } else {\n                // No active generation - reset wizard to step 1 if we're on a later step\n                // This handles the case where user left off on step 5 but isn't actively generating\n                if (wizardState.currentStep > 1 && !cardStudio.isGenerating) {\n                    console.log(\"\\uD83D\\uDD04 No active generation, resetting to Step 1\");\n                    wizardState.updateCurrentStep(1);\n                }\n            }\n        // If we have completed drafts but no active generation, stay on Step 1\n        // User can choose to resume via the UI\n        };\n        restorePendingJobs();\n    }, []);\n    // Only mark step 1 as completed if user has made selections, but don't auto-advance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!wizardState.isInitialLoadComplete || !cardForm.isInitialLoadComplete) return;\n        // Only mark step as completed, don't navigate\n        if (wizardState.currentStep === 1 && !wizardState.completedSteps.includes(1)) {\n            const formData = cardForm.formData;\n            // Mark step 1 as completed if user has made selections\n            if (formData.selectedType && formData.selectedTone) {\n                console.log(\"âœ… Marking step 1 as completed based on saved data\");\n                wizardState.markStepCompleted(1);\n            }\n        }\n    }, [\n        wizardState.isInitialLoadComplete,\n        cardForm.isInitialLoadComplete\n    ]);\n    // Only navigate to Step 5 when NEW draft cards are being generated (not restored)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Only navigate if we're actively generating NEW drafts, not restoring old ones\n        if (cardStudio.draftCards.length > 0 && wizardState.currentStep < 5 && cardStudio.isGenerating && !isRestoringJobs) {\n            console.log(\"\\uD83D\\uDCCB New draft cards being generated, navigating to Step 5\");\n            // Mark previous steps as completed\n            for(let i = 1; i <= 4; i++){\n                if (!wizardState.completedSteps.includes(i)) {\n                    wizardState.markStepCompleted(i);\n                }\n            }\n            wizardState.updateCurrentStep(5);\n        }\n    }, [\n        cardStudio.draftCards.length,\n        cardStudio.isGenerating,\n        isRestoringJobs\n    ]);\n    // Auto-save drafts when user creates draft cards\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Skip auto-save if card is already completed\n        if (cardStudio.isCardCompleted) {\n            return;\n        }\n        // Only save if we have draft cards and not resuming or restoring\n        if (cardStudio.draftCards.length > 0) {\n            console.log(\"\\uD83D\\uDD0D Auto-save check:\", {\n                hasCards: cardStudio.draftCards.length > 0,\n                isInitialLoadComplete: cardForm.isInitialLoadComplete,\n                isResumingDraft,\n                isRestoringJobs,\n                isCardCompleted: cardStudio.isCardCompleted,\n                shouldSave: cardForm.isInitialLoadComplete && !isResumingDraft && !isRestoringJobs && !cardStudio.isCardCompleted\n            });\n        }\n        if (cardStudio.draftCards.length > 0 && cardForm.isInitialLoadComplete && !isResumingDraft && !isRestoringJobs && !cardStudio.isCardCompleted) {\n            // Count non-null draft cards\n            const validDrafts = cardStudio.draftCards.filter((card)=>card !== null).length;\n            // Only save when:\n            // 1. All 5 drafts are complete (validDrafts === 5)\n            // 2. This is the first draft and we haven't saved yet (validDrafts === 1 && !currentDraftSessionId)\n            // 3. User selected a draft (selectedDraftIndex >= 0)\n            const shouldSave = validDrafts === 5 && lastSavedDraftCount < 5 || // All drafts complete\n            validDrafts === 1 && !currentDraftSessionId || // First draft\n            cardStudio.selectedDraftIndex >= 0 && validDrafts > lastSavedDraftCount // User selected\n            ;\n            if (shouldSave && validDrafts > 0) {\n                // Save or update the session with the same ID\n                const sessionId = cardHistory.saveDraftSession(cardForm.formData, cardStudio.draftCards, cardStudio.selectedDraftIndex, currentDraftSessionId || undefined // Use existing session ID if available\n                );\n                // Store the session ID for future updates\n                if (!currentDraftSessionId) {\n                    setCurrentDraftSessionId(sessionId);\n                }\n                // Update the last saved count\n                setLastSavedDraftCount(validDrafts);\n                console.log(\"\\uD83D\\uDCBE Draft session saved: \".concat(validDrafts, \"/5 drafts complete\"));\n            }\n        }\n    }, [\n        cardStudio.draftCards,\n        cardStudio.selectedDraftIndex,\n        cardForm.formData,\n        cardForm.isInitialLoadComplete,\n        isResumingDraft,\n        isRestoringJobs,\n        currentDraftSessionId,\n        lastSavedDraftCount\n    ]);\n    // Reset session ID when drafts are cleared\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const validDrafts = cardStudio.draftCards.filter((card)=>card !== null).length;\n        if (validDrafts === 0) {\n            setCurrentDraftSessionId(null);\n            setLastSavedDraftCount(0);\n        }\n    }, [\n        cardStudio.draftCards\n    ]);\n    // Auto-save completed cards and ensure we're on Step 6\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cardStudio.generatedCard && cardStudio.isCardCompleted) {\n            cardHistory.addCompletedCard(cardStudio.generatedCard);\n            // Clear draft session since card is completed\n            if (currentDraftSessionId) {\n                console.log(\"\\uD83E\\uDDF9 Clearing draft session after successful card completion\");\n                localStorage.removeItem(\"vibe-current-draft-session\");\n                cardHistory.removeDraftSession(currentDraftSessionId);\n                setCurrentDraftSessionId(null);\n                setLastSavedDraftCount(0);\n            }\n            // Ensure we're on Step 6 to see the completed card\n            if (wizardState.currentStep !== 6) {\n                console.log(\"\\uD83D\\uDCCD Card completed but not on Step 6, navigating there now...\");\n                wizardState.updateCurrentStep(6);\n            }\n        }\n    }, [\n        cardStudio.generatedCard,\n        cardStudio.isCardCompleted,\n        wizardState.currentStep,\n        currentDraftSessionId\n    ]);\n    // Sync form data with cardStudio when form data changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!cardForm.isInitialLoadComplete) return;\n        const { formData } = cardForm;\n        // Update cardStudio with form data\n        cardStudio.setSelectedType(formData.selectedType);\n        cardStudio.setCustomCardType(formData.customCardType);\n        cardStudio.setSelectedTone(formData.selectedTone);\n        cardStudio.setToField(formData.toField);\n        cardStudio.setFromField(formData.fromField);\n        cardStudio.setRelationshipField(formData.relationshipField);\n        cardStudio.setPrompt(formData.prompt);\n        cardStudio.setFinalCardMessage(formData.finalCardMessage);\n        cardStudio.setIsHandwrittenMessage(formData.isHandwrittenMessage);\n        cardStudio.setSelectedArtisticStyle(formData.selectedArtisticStyle);\n        cardStudio.setCustomStyleDescription(formData.customStyleDescription);\n        // Skip syncing reference images from form to cardStudio\n        // This should only flow from cardStudio -> form after uploads\n        // cardStudio.setReferenceImages(formData.referenceImages);\n        // cardStudio.setReferenceImageUrls(formData.referenceImageUrls);\n        cardStudio.setUserEmail(formData.userEmail);\n        cardStudio.setSelectedImageModel(formData.selectedImageModel);\n        cardStudio.setSelectedDraftModel(formData.selectedDraftModel);\n        cardStudio.setSelectedPaperSize(formData.selectedPaperSize);\n        cardStudio.setNumberOfCards(formData.numberOfCards);\n        cardStudio.setIsFrontBackOnly(formData.isFrontBackOnly);\n    }, [\n        cardForm.formData,\n        cardForm.isInitialLoadComplete\n    ]);\n    // Auto-complete step 1 once user makes selections\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cardForm.validateStep(1) && !wizardState.completedSteps.includes(1)) {\n            wizardState.markStepCompleted(1);\n        }\n    }, [\n        cardForm.formData.selectedType,\n        cardForm.formData.selectedTone,\n        cardForm.formData.customCardType,\n        wizardState\n    ]);\n    // Auto-complete step 4 once email is valid\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cardForm.validateStep(4) && !wizardState.completedSteps.includes(4)) {\n            wizardState.markStepCompleted(4);\n        }\n    }, [\n        cardForm.formData.userEmail,\n        wizardState\n    ]);\n    // Auto-advance to Step 6 when final card generation starts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cardStudio.isGeneratingFinalCard && wizardState.currentStep < 6) {\n            console.log(\"\\uD83D\\uDE80 Auto-advancing to Step 6: Final Generation\");\n            if (!wizardState.completedSteps.includes(5)) {\n                wizardState.markStepCompleted(5);\n            }\n            wizardState.updateCurrentStep(6);\n        }\n    }, [\n        cardStudio.isGeneratingFinalCard,\n        wizardState\n    ]);\n    // Sync reference images from cardStudio to form when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!cardForm.isInitialLoadComplete) return;\n        // Sync if cardStudio has images but form doesn't, or if photoReferences changed\n        const shouldSync = cardStudio.referenceImageUrls.length > 0 && cardForm.formData.referenceImageUrls.length !== cardStudio.referenceImageUrls.length || cardStudio.photoReferences && cardStudio.photoReferences !== cardForm.formData.photoReferences;\n        if (shouldSync) {\n            cardForm.updateFormData({\n                referenceImages: cardStudio.referenceImages,\n                referenceImageUrls: cardStudio.referenceImageUrls,\n                photoReferences: cardStudio.photoReferences\n            });\n        }\n    }, [\n        cardStudio.referenceImageUrls,\n        cardStudio.referenceImages,\n        cardStudio.photoReferences,\n        cardForm.isInitialLoadComplete\n    ]);\n    return null;\n}\n_s(CardWizardEffects, \"8icF1iS0y70QOL81ZXfYgpSjIkA=\");\n_c = CardWizardEffects;\nvar _c;\n$RefreshReg$(_c, \"CardWizardEffects\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvd2l6YXJkL0NhcmRXaXphcmRFZmZlY3RzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRTRDO0FBZXJDLFNBQVNFLGtCQUFrQixLQVFUO1FBUlMsRUFDaENDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsaUJBQWlCLEVBQ2pCQyxlQUFlLEVBQ2ZDLGVBQWUsRUFDUSxHQVJTOztJQVNoQywwREFBMEQ7SUFDMUQsTUFBTSxDQUFDQyx1QkFBdUJDLHlCQUF5QixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDbEYsTUFBTSxDQUFDVyxxQkFBcUJDLHVCQUF1QixHQUFHWiwrQ0FBUUEsQ0FBUztJQUN2RSxvRUFBb0U7SUFDcEVELGdEQUFTQSxDQUFDO1FBQ1IsTUFBTWMscUJBQXFCO1lBQ3pCQyxRQUFRQyxHQUFHLENBQUM7WUFFWixzQ0FBc0M7WUFDdEMsSUFBSUMsaUJBQWlCO1lBQ3JCLElBQUk7Z0JBQ0ZBLGlCQUFpQkMsS0FBS0MsS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUMsaUNBQWlDO1lBQ3BGLEVBQUUsVUFBTTtnQkFDTkosaUJBQWlCO1lBQ25CO1lBQ0EsSUFBSUEsa0JBQWtCQSxlQUFlSyxVQUFVLElBQUlMLGVBQWVLLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ3ZGUixRQUFRQyxHQUFHLENBQUMsK0NBQXFDQyxlQUFlSyxVQUFVLENBQUNDLE1BQU0sRUFBRTtnQkFFbkYsMENBQTBDO2dCQUMxQyxNQUFNQyxXQUFXQyxLQUFLQyxHQUFHLEtBQUssSUFBSUQsS0FBS1IsZUFBZVUsT0FBTyxFQUFFQyxPQUFPO2dCQUN0RSxNQUFNQyxXQUFXLElBQUksS0FBSyxLQUFLO2dCQUUvQixJQUFJTCxXQUFXSyxVQUFVO29CQUN2Qix5Q0FBeUM7b0JBQ3pDMUIsV0FBVzJCLGFBQWEsQ0FBQ2IsZUFBZUssVUFBVTtvQkFDbERuQixXQUFXNEIsY0FBYyxDQUFDO29CQUUx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TixnREFBU0EsQ0FBQztRQUNSLElBQUlHLFdBQVdxQyxxQkFBcUIsSUFBSWxDLFlBQVl5QyxXQUFXLEdBQUcsR0FBRztZQUNuRWhDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLElBQUksQ0FBQ1YsWUFBWW9DLGNBQWMsQ0FBQ0MsUUFBUSxDQUFDLElBQUk7Z0JBQzNDckMsWUFBWXNDLGlCQUFpQixDQUFDO1lBQ2hDO1lBQ0F0QyxZQUFZdUMsaUJBQWlCLENBQUM7UUFDaEM7SUFDRixHQUFHO1FBQUMxQyxXQUFXcUMscUJBQXFCO1FBQUVsQztLQUFZO0lBRWxELGlFQUFpRTtJQUNqRU4sZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNJLFNBQVM0QyxxQkFBcUIsRUFBRTtRQUVyQyxnRkFBZ0Y7UUFDaEYsTUFBTWdELGFBQ0osV0FBWUMsa0JBQWtCLENBQUMxRSxNQUFNLEdBQUcsS0FDdkNuQixTQUFTNEIsUUFBUSxDQUFDaUUsa0JBQWtCLENBQUMxRSxNQUFNLEtBQUtwQixXQUFXOEYsa0JBQWtCLENBQUMxRSxNQUFNLElBQ3BGcEIsV0FBVytGLGVBQWUsSUFBSS9GLFdBQVcrRixlQUFlLEtBQUs5RixTQUFTNEIsUUFBUSxDQUFDa0UsZUFBZTtRQUdqRyxJQUFJRixZQUFZO1lBQ2Q1RixTQUFTNkIsY0FBYyxDQUFDO2dCQUN0QmtFLGlCQUFpQmhHLFdBQVdnRyxlQUFlO2dCQUMzQ0Ysb0JBQW9COUYsV0FBVzhGLGtCQUFrQjtnQkFDakRDLGlCQUFpQi9GLFdBQVcrRixlQUFlO1lBQzdDO1FBQ0Y7SUFDRixHQUFHO1FBQUMvRixXQUFXOEYsa0JBQWtCO1FBQUU5RixXQUFXZ0csZUFBZTtRQUFFaEcsV0FBVytGLGVBQWU7UUFBRTlGLFNBQVM0QyxxQkFBcUI7S0FBQztJQUUxSCxPQUFPO0FBQ1Q7R0FqU2dCOUM7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy93aXphcmQvQ2FyZFdpemFyZEVmZmVjdHMudHN4P2RhNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENhcmRGb3JtRGF0YSB9IGZyb20gXCJAL2hvb2tzL3VzZUNhcmRGb3JtXCI7XG5pbXBvcnQgeyBHZW5lcmF0ZWRDYXJkIH0gZnJvbSBcIkAvaG9va3MvY2FyZFN0dWRpby9jb25zdGFudHNcIjtcbmltcG9ydCB7IHN0b3JhZ2UgfSBmcm9tIFwiQC9saWIvc3RvcmFnZU1hbmFnZXJcIjtcblxuaW50ZXJmYWNlIENhcmRXaXphcmRFZmZlY3RzUHJvcHMge1xuICBjYXJkU3R1ZGlvOiBhbnk7XG4gIGNhcmRGb3JtOiBhbnk7XG4gIGNhcmRIaXN0b3J5OiBhbnk7XG4gIHdpemFyZFN0YXRlOiBhbnk7XG4gIHVwZGF0ZVdpemFyZFN0YXRlOiAodXBkYXRlczogYW55KSA9PiB2b2lkO1xuICBpc1Jlc3VtaW5nRHJhZnQ6IGJvb2xlYW47XG4gIGlzUmVzdG9yaW5nSm9iczogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRXaXphcmRFZmZlY3RzKHtcbiAgY2FyZFN0dWRpbyxcbiAgY2FyZEZvcm0sXG4gIGNhcmRIaXN0b3J5LFxuICB3aXphcmRTdGF0ZSxcbiAgdXBkYXRlV2l6YXJkU3RhdGUsXG4gIGlzUmVzdW1pbmdEcmFmdCxcbiAgaXNSZXN0b3JpbmdKb2JzXG59OiBDYXJkV2l6YXJkRWZmZWN0c1Byb3BzKSB7XG4gIC8vIFRyYWNrIHRoZSBjdXJyZW50IHNlc3Npb24gSUQgdG8gdXBkYXRlIHRoZSBzYW1lIHNlc3Npb25cbiAgY29uc3QgW2N1cnJlbnREcmFmdFNlc3Npb25JZCwgc2V0Q3VycmVudERyYWZ0U2Vzc2lvbklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbGFzdFNhdmVkRHJhZnRDb3VudCwgc2V0TGFzdFNhdmVkRHJhZnRDb3VudF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICAvLyBDaGVjayBmb3IgcGVuZGluZyBqb2JzIG9uIGNvbXBvbmVudCBtb3VudCBidXQgZG9uJ3QgYXV0by1uYXZpZ2F0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3RvcmVQZW5kaW5nSm9icyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIENhcmRXaXphcmRFZmZlY3RzOiBTdGFydGluZyBjaGVja1BlbmRpbmdKb2JzLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBzYXZlZCBkcmFmdCBzZXNzaW9uXG4gICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudFNlc3Npb24gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd2aWJlLWN1cnJlbnQtZHJhZnQtc2Vzc2lvbicpIHx8ICdudWxsJyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICYmIGN1cnJlbnRTZXNzaW9uLmRyYWZ0Q2FyZHMgJiYgY3VycmVudFNlc3Npb24uZHJhZnRDYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEZvdW5kIHNhdmVkIGRyYWZ0IHNlc3Npb24gd2l0aCcsIGN1cnJlbnRTZXNzaW9uLmRyYWZ0Q2FyZHMubGVuZ3RoLCAnZHJhZnRzJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBkcmFmdCBpcyBsZXNzIHRoYW4gMiBob3VycyBvbGRcbiAgICAgICAgY29uc3QgZHJhZnRBZ2UgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUoY3VycmVudFNlc3Npb24uc2F2ZWRBdCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCB0d29Ib3VycyA9IDIgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChkcmFmdEFnZSA8IHR3b0hvdXJzKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSBkcmFmdCBjYXJkcyBidXQgZG9uJ3QgbmF2aWdhdGVcbiAgICAgICAgICBjYXJkU3R1ZGlvLnNldERyYWZ0Q2FyZHMoY3VycmVudFNlc3Npb24uZHJhZnRDYXJkcyk7XG4gICAgICAgICAgY2FyZFN0dWRpby5zZXRJc0RyYWZ0TW9kZSh0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXN0b3JlIGZvcm0gZGF0YSBpZiBuZWVkZWRcbiAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24uZm9ybURhdGEpIHtcbiAgICAgICAgICAgIGNhcmRGb3JtLnVwZGF0ZUZvcm1EYXRhKGN1cnJlbnRTZXNzaW9uLmZvcm1EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG9uJ3QgYXV0by1uYXZpZ2F0ZSAtIGxldCB1c2VyIGNob29zZSB2aWEgUmVzdW1lIERyYWZ0IGJ1dHRvblxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIERyYWZ0IHNlc3Npb24gcmVzdG9yZWQsIHVzZXIgY2FuIHJlc3VtZSB2aWEgVUknKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiBJRCBmb3IgdXBkYXRlc1xuICAgICAgICAgIHNldEN1cnJlbnREcmFmdFNlc3Npb25JZChjdXJyZW50U2Vzc2lvbi5pZCk7XG4gICAgICAgICAgc2V0TGFzdFNhdmVkRHJhZnRDb3VudChjdXJyZW50U2Vzc2lvbi5kcmFmdENhcmRzLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRHJhZnQgaXMgdG9vIG9sZCwgcmVtb3ZlIGl0XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgRHJhZnQgc2Vzc2lvbiBleHBpcmVkLCByZW1vdmluZy4uLicpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd2aWJlLWN1cnJlbnQtZHJhZnQtc2Vzc2lvbicpO1xuICAgICAgICAgIGNhcmRIaXN0b3J5LnJlbW92ZURyYWZ0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybjsgLy8gU2tpcCBwZW5kaW5nIGpvYnMgY2hlY2sgaWYgd2UgcHJvY2Vzc2VkIGEgZHJhZnQgc2Vzc2lvblxuICAgICAgfVxuICAgICAgXG4gICAgICBhd2FpdCBjYXJkU3R1ZGlvLmNoZWNrUGVuZGluZ0pvYnMoKTtcbiAgICAgIFxuICAgICAgLy8gT25seSBhdXRvLW5hdmlnYXRlIGlmIHRoZXJlJ3MgYW4gYWN0aXZlIGdlbmVyYXRpb24gaW4gcHJvZ3Jlc3NcbiAgICAgIC8vIERvbid0IG5hdmlnYXRlIGZvciBjb21wbGV0ZWQgZHJhZnRzIC0gbGV0IHVzZXIgY2hvb3NlXG4gICAgICBpZiAoY2FyZFN0dWRpby5pc0dlbmVyYXRpbmcgJiYgY2FyZFN0dWRpby5nZW5lcmF0aW9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKGNhcmRTdHVkaW8uaXNHZW5lcmF0aW5nRmluYWxDYXJkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgUmVzdG9yaW5nIHRvIFN0ZXAgNiBkdWUgdG8gb25nb2luZyBmaW5hbCBnZW5lcmF0aW9uJyk7XG4gICAgICAgICAgLy8gTWFyayBhbGwgcHJldmlvdXMgc3RlcHMgYXMgY29tcGxldGVkXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXdpemFyZFN0YXRlLmNvbXBsZXRlZFN0ZXBzLmluY2x1ZGVzKGkpKSB3aXphcmRTdGF0ZS5tYXJrU3RlcENvbXBsZXRlZChpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2l6YXJkU3RhdGUudXBkYXRlQ3VycmVudFN0ZXAoNik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FyZFN0dWRpby5pc0RyYWZ0TW9kZSAmJiBjYXJkU3R1ZGlvLmlzR2VuZXJhdGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJlc3RvcmluZyB0byBTdGVwIDUgZHVlIHRvIG9uZ29pbmcgZHJhZnQgZ2VuZXJhdGlvbicpO1xuICAgICAgICAgIC8vIE1hcmsgcHJldmlvdXMgc3RlcHMgYXMgY29tcGxldGVkXG4gICAgICAgICAgaWYgKCF3aXphcmRTdGF0ZS5jb21wbGV0ZWRTdGVwcy5pbmNsdWRlcygxKSkgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoMSk7XG4gICAgICAgICAgaWYgKCF3aXphcmRTdGF0ZS5jb21wbGV0ZWRTdGVwcy5pbmNsdWRlcygyKSkgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoMik7XG4gICAgICAgICAgaWYgKCF3aXphcmRTdGF0ZS5jb21wbGV0ZWRTdGVwcy5pbmNsdWRlcygzKSkgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoMyk7XG4gICAgICAgICAgaWYgKCF3aXphcmRTdGF0ZS5jb21wbGV0ZWRTdGVwcy5pbmNsdWRlcyg0KSkgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoNCk7XG4gICAgICAgICAgd2l6YXJkU3RhdGUudXBkYXRlQ3VycmVudFN0ZXAoNSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGFjdGl2ZSBnZW5lcmF0aW9uIC0gcmVzZXQgd2l6YXJkIHRvIHN0ZXAgMSBpZiB3ZSdyZSBvbiBhIGxhdGVyIHN0ZXBcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHVzZXIgbGVmdCBvZmYgb24gc3RlcCA1IGJ1dCBpc24ndCBhY3RpdmVseSBnZW5lcmF0aW5nXG4gICAgICAgIGlmICh3aXphcmRTdGF0ZS5jdXJyZW50U3RlcCA+IDEgJiYgIWNhcmRTdHVkaW8uaXNHZW5lcmF0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgTm8gYWN0aXZlIGdlbmVyYXRpb24sIHJlc2V0dGluZyB0byBTdGVwIDEnKTtcbiAgICAgICAgICB3aXphcmRTdGF0ZS51cGRhdGVDdXJyZW50U3RlcCgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBjb21wbGV0ZWQgZHJhZnRzIGJ1dCBubyBhY3RpdmUgZ2VuZXJhdGlvbiwgc3RheSBvbiBTdGVwIDFcbiAgICAgIC8vIFVzZXIgY2FuIGNob29zZSB0byByZXN1bWUgdmlhIHRoZSBVSVxuICAgIH07XG4gICAgXG4gICAgcmVzdG9yZVBlbmRpbmdKb2JzKCk7XG4gIH0sIFtdKTtcblxuICAvLyBPbmx5IG1hcmsgc3RlcCAxIGFzIGNvbXBsZXRlZCBpZiB1c2VyIGhhcyBtYWRlIHNlbGVjdGlvbnMsIGJ1dCBkb24ndCBhdXRvLWFkdmFuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdpemFyZFN0YXRlLmlzSW5pdGlhbExvYWRDb21wbGV0ZSB8fCAhY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlKSByZXR1cm47XG4gICAgXG4gICAgLy8gT25seSBtYXJrIHN0ZXAgYXMgY29tcGxldGVkLCBkb24ndCBuYXZpZ2F0ZVxuICAgIGlmICh3aXphcmRTdGF0ZS5jdXJyZW50U3RlcCA9PT0gMSAmJiAhd2l6YXJkU3RhdGUuY29tcGxldGVkU3RlcHMuaW5jbHVkZXMoMSkpIHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gY2FyZEZvcm0uZm9ybURhdGE7XG4gICAgICBcbiAgICAgIC8vIE1hcmsgc3RlcCAxIGFzIGNvbXBsZXRlZCBpZiB1c2VyIGhhcyBtYWRlIHNlbGVjdGlvbnNcbiAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZFR5cGUgJiYgZm9ybURhdGEuc2VsZWN0ZWRUb25lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWFya2luZyBzdGVwIDEgYXMgY29tcGxldGVkIGJhc2VkIG9uIHNhdmVkIGRhdGEnKTtcbiAgICAgICAgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoMSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbd2l6YXJkU3RhdGUuaXNJbml0aWFsTG9hZENvbXBsZXRlLCBjYXJkRm9ybS5pc0luaXRpYWxMb2FkQ29tcGxldGVdKTtcblxuICAvLyBPbmx5IG5hdmlnYXRlIHRvIFN0ZXAgNSB3aGVuIE5FVyBkcmFmdCBjYXJkcyBhcmUgYmVpbmcgZ2VuZXJhdGVkIChub3QgcmVzdG9yZWQpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gT25seSBuYXZpZ2F0ZSBpZiB3ZSdyZSBhY3RpdmVseSBnZW5lcmF0aW5nIE5FVyBkcmFmdHMsIG5vdCByZXN0b3Jpbmcgb2xkIG9uZXNcbiAgICBpZiAoY2FyZFN0dWRpby5kcmFmdENhcmRzLmxlbmd0aCA+IDAgJiYgXG4gICAgICAgIHdpemFyZFN0YXRlLmN1cnJlbnRTdGVwIDwgNSAmJiBcbiAgICAgICAgY2FyZFN0dWRpby5pc0dlbmVyYXRpbmcgJiYgXG4gICAgICAgICFpc1Jlc3RvcmluZ0pvYnMpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIE5ldyBkcmFmdCBjYXJkcyBiZWluZyBnZW5lcmF0ZWQsIG5hdmlnYXRpbmcgdG8gU3RlcCA1Jyk7XG4gICAgICAvLyBNYXJrIHByZXZpb3VzIHN0ZXBzIGFzIGNvbXBsZXRlZFxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNDsgaSsrKSB7XG4gICAgICAgIGlmICghd2l6YXJkU3RhdGUuY29tcGxldGVkU3RlcHMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICB3aXphcmRTdGF0ZS5tYXJrU3RlcENvbXBsZXRlZChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2l6YXJkU3RhdGUudXBkYXRlQ3VycmVudFN0ZXAoNSk7XG4gICAgfVxuICB9LCBbY2FyZFN0dWRpby5kcmFmdENhcmRzLmxlbmd0aCwgY2FyZFN0dWRpby5pc0dlbmVyYXRpbmcsIGlzUmVzdG9yaW5nSm9ic10pO1xuXG4gIC8vIEF1dG8tc2F2ZSBkcmFmdHMgd2hlbiB1c2VyIGNyZWF0ZXMgZHJhZnQgY2FyZHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIGF1dG8tc2F2ZSBpZiBjYXJkIGlzIGFscmVhZHkgY29tcGxldGVkXG4gICAgaWYgKGNhcmRTdHVkaW8uaXNDYXJkQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE9ubHkgc2F2ZSBpZiB3ZSBoYXZlIGRyYWZ0IGNhcmRzIGFuZCBub3QgcmVzdW1pbmcgb3IgcmVzdG9yaW5nXG4gICAgaWYgKGNhcmRTdHVkaW8uZHJhZnRDYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBBdXRvLXNhdmUgY2hlY2s6Jywge1xuICAgICAgICBoYXNDYXJkczogY2FyZFN0dWRpby5kcmFmdENhcmRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGlzSW5pdGlhbExvYWRDb21wbGV0ZTogY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlLFxuICAgICAgICBpc1Jlc3VtaW5nRHJhZnQsXG4gICAgICAgIGlzUmVzdG9yaW5nSm9icyxcbiAgICAgICAgaXNDYXJkQ29tcGxldGVkOiBjYXJkU3R1ZGlvLmlzQ2FyZENvbXBsZXRlZCxcbiAgICAgICAgc2hvdWxkU2F2ZTogY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlICYmICFpc1Jlc3VtaW5nRHJhZnQgJiYgIWlzUmVzdG9yaW5nSm9icyAmJiAhY2FyZFN0dWRpby5pc0NhcmRDb21wbGV0ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAoY2FyZFN0dWRpby5kcmFmdENhcmRzLmxlbmd0aCA+IDAgJiYgY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlICYmICFpc1Jlc3VtaW5nRHJhZnQgJiYgIWlzUmVzdG9yaW5nSm9icyAmJiAhY2FyZFN0dWRpby5pc0NhcmRDb21wbGV0ZWQpIHtcbiAgICAgIC8vIENvdW50IG5vbi1udWxsIGRyYWZ0IGNhcmRzXG4gICAgICBjb25zdCB2YWxpZERyYWZ0cyA9IGNhcmRTdHVkaW8uZHJhZnRDYXJkcy5maWx0ZXIoY2FyZCA9PiBjYXJkICE9PSBudWxsKS5sZW5ndGg7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgc2F2ZSB3aGVuOlxuICAgICAgLy8gMS4gQWxsIDUgZHJhZnRzIGFyZSBjb21wbGV0ZSAodmFsaWREcmFmdHMgPT09IDUpXG4gICAgICAvLyAyLiBUaGlzIGlzIHRoZSBmaXJzdCBkcmFmdCBhbmQgd2UgaGF2ZW4ndCBzYXZlZCB5ZXQgKHZhbGlkRHJhZnRzID09PSAxICYmICFjdXJyZW50RHJhZnRTZXNzaW9uSWQpXG4gICAgICAvLyAzLiBVc2VyIHNlbGVjdGVkIGEgZHJhZnQgKHNlbGVjdGVkRHJhZnRJbmRleCA+PSAwKVxuICAgICAgY29uc3Qgc2hvdWxkU2F2ZSA9IChcbiAgICAgICAgKHZhbGlkRHJhZnRzID09PSA1ICYmIGxhc3RTYXZlZERyYWZ0Q291bnQgPCA1KSB8fCAvLyBBbGwgZHJhZnRzIGNvbXBsZXRlXG4gICAgICAgICh2YWxpZERyYWZ0cyA9PT0gMSAmJiAhY3VycmVudERyYWZ0U2Vzc2lvbklkKSB8fCAvLyBGaXJzdCBkcmFmdFxuICAgICAgICAoY2FyZFN0dWRpby5zZWxlY3RlZERyYWZ0SW5kZXggPj0gMCAmJiB2YWxpZERyYWZ0cyA+IGxhc3RTYXZlZERyYWZ0Q291bnQpIC8vIFVzZXIgc2VsZWN0ZWRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChzaG91bGRTYXZlICYmIHZhbGlkRHJhZnRzID4gMCkge1xuICAgICAgICAvLyBTYXZlIG9yIHVwZGF0ZSB0aGUgc2Vzc2lvbiB3aXRoIHRoZSBzYW1lIElEXG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGNhcmRIaXN0b3J5LnNhdmVEcmFmdFNlc3Npb24oXG4gICAgICAgICAgY2FyZEZvcm0uZm9ybURhdGEsXG4gICAgICAgICAgY2FyZFN0dWRpby5kcmFmdENhcmRzLFxuICAgICAgICAgIGNhcmRTdHVkaW8uc2VsZWN0ZWREcmFmdEluZGV4LFxuICAgICAgICAgIGN1cnJlbnREcmFmdFNlc3Npb25JZCB8fCB1bmRlZmluZWQgLy8gVXNlIGV4aXN0aW5nIHNlc3Npb24gSUQgaWYgYXZhaWxhYmxlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSB0aGUgc2Vzc2lvbiBJRCBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFjdXJyZW50RHJhZnRTZXNzaW9uSWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RHJhZnRTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IHNhdmVkIGNvdW50XG4gICAgICAgIHNldExhc3RTYXZlZERyYWZ0Q291bnQodmFsaWREcmFmdHMpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfkr4gRHJhZnQgc2Vzc2lvbiBzYXZlZDogJHt2YWxpZERyYWZ0c30vNSBkcmFmdHMgY29tcGxldGVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjYXJkU3R1ZGlvLmRyYWZ0Q2FyZHMsIGNhcmRTdHVkaW8uc2VsZWN0ZWREcmFmdEluZGV4LCBjYXJkRm9ybS5mb3JtRGF0YSwgY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlLCBpc1Jlc3VtaW5nRHJhZnQsIGlzUmVzdG9yaW5nSm9icywgY3VycmVudERyYWZ0U2Vzc2lvbklkLCBsYXN0U2F2ZWREcmFmdENvdW50XSk7XG4gIFxuICAvLyBSZXNldCBzZXNzaW9uIElEIHdoZW4gZHJhZnRzIGFyZSBjbGVhcmVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdmFsaWREcmFmdHMgPSBjYXJkU3R1ZGlvLmRyYWZ0Q2FyZHMuZmlsdGVyKGNhcmQgPT4gY2FyZCAhPT0gbnVsbCkubGVuZ3RoO1xuICAgIGlmICh2YWxpZERyYWZ0cyA9PT0gMCkge1xuICAgICAgc2V0Q3VycmVudERyYWZ0U2Vzc2lvbklkKG51bGwpO1xuICAgICAgc2V0TGFzdFNhdmVkRHJhZnRDb3VudCgwKTtcbiAgICB9XG4gIH0sIFtjYXJkU3R1ZGlvLmRyYWZ0Q2FyZHNdKTtcblxuICAvLyBBdXRvLXNhdmUgY29tcGxldGVkIGNhcmRzIGFuZCBlbnN1cmUgd2UncmUgb24gU3RlcCA2XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNhcmRTdHVkaW8uZ2VuZXJhdGVkQ2FyZCAmJiBjYXJkU3R1ZGlvLmlzQ2FyZENvbXBsZXRlZCkge1xuICAgICAgY2FyZEhpc3RvcnkuYWRkQ29tcGxldGVkQ2FyZChjYXJkU3R1ZGlvLmdlbmVyYXRlZENhcmQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBkcmFmdCBzZXNzaW9uIHNpbmNlIGNhcmQgaXMgY29tcGxldGVkXG4gICAgICBpZiAoY3VycmVudERyYWZ0U2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFyaW5nIGRyYWZ0IHNlc3Npb24gYWZ0ZXIgc3VjY2Vzc2Z1bCBjYXJkIGNvbXBsZXRpb24nKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3ZpYmUtY3VycmVudC1kcmFmdC1zZXNzaW9uJyk7XG4gICAgICAgIGNhcmRIaXN0b3J5LnJlbW92ZURyYWZ0U2Vzc2lvbihjdXJyZW50RHJhZnRTZXNzaW9uSWQpO1xuICAgICAgICBzZXRDdXJyZW50RHJhZnRTZXNzaW9uSWQobnVsbCk7XG4gICAgICAgIHNldExhc3RTYXZlZERyYWZ0Q291bnQoMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB3ZSdyZSBvbiBTdGVwIDYgdG8gc2VlIHRoZSBjb21wbGV0ZWQgY2FyZFxuICAgICAgaWYgKHdpemFyZFN0YXRlLmN1cnJlbnRTdGVwICE9PSA2KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5ONIENhcmQgY29tcGxldGVkIGJ1dCBub3Qgb24gU3RlcCA2LCBuYXZpZ2F0aW5nIHRoZXJlIG5vdy4uLicpO1xuICAgICAgICB3aXphcmRTdGF0ZS51cGRhdGVDdXJyZW50U3RlcCg2KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjYXJkU3R1ZGlvLmdlbmVyYXRlZENhcmQsIGNhcmRTdHVkaW8uaXNDYXJkQ29tcGxldGVkLCB3aXphcmRTdGF0ZS5jdXJyZW50U3RlcCwgY3VycmVudERyYWZ0U2Vzc2lvbklkXSk7XG5cbiAgLy8gU3luYyBmb3JtIGRhdGEgd2l0aCBjYXJkU3R1ZGlvIHdoZW4gZm9ybSBkYXRhIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhcmRGb3JtLmlzSW5pdGlhbExvYWRDb21wbGV0ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgeyBmb3JtRGF0YSB9ID0gY2FyZEZvcm07XG4gICAgXG4gICAgLy8gVXBkYXRlIGNhcmRTdHVkaW8gd2l0aCBmb3JtIGRhdGFcbiAgICBjYXJkU3R1ZGlvLnNldFNlbGVjdGVkVHlwZShmb3JtRGF0YS5zZWxlY3RlZFR5cGUpO1xuICAgIGNhcmRTdHVkaW8uc2V0Q3VzdG9tQ2FyZFR5cGUoZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUpO1xuICAgIGNhcmRTdHVkaW8uc2V0U2VsZWN0ZWRUb25lKGZvcm1EYXRhLnNlbGVjdGVkVG9uZSk7XG4gICAgY2FyZFN0dWRpby5zZXRUb0ZpZWxkKGZvcm1EYXRhLnRvRmllbGQpO1xuICAgIGNhcmRTdHVkaW8uc2V0RnJvbUZpZWxkKGZvcm1EYXRhLmZyb21GaWVsZCk7XG4gICAgY2FyZFN0dWRpby5zZXRSZWxhdGlvbnNoaXBGaWVsZChmb3JtRGF0YS5yZWxhdGlvbnNoaXBGaWVsZCk7XG4gICAgY2FyZFN0dWRpby5zZXRQcm9tcHQoZm9ybURhdGEucHJvbXB0KTtcbiAgICBjYXJkU3R1ZGlvLnNldEZpbmFsQ2FyZE1lc3NhZ2UoZm9ybURhdGEuZmluYWxDYXJkTWVzc2FnZSk7XG4gICAgY2FyZFN0dWRpby5zZXRJc0hhbmR3cml0dGVuTWVzc2FnZShmb3JtRGF0YS5pc0hhbmR3cml0dGVuTWVzc2FnZSk7XG4gICAgY2FyZFN0dWRpby5zZXRTZWxlY3RlZEFydGlzdGljU3R5bGUoZm9ybURhdGEuc2VsZWN0ZWRBcnRpc3RpY1N0eWxlKTtcbiAgICBjYXJkU3R1ZGlvLnNldEN1c3RvbVN0eWxlRGVzY3JpcHRpb24oZm9ybURhdGEuY3VzdG9tU3R5bGVEZXNjcmlwdGlvbik7XG4gICAgLy8gU2tpcCBzeW5jaW5nIHJlZmVyZW5jZSBpbWFnZXMgZnJvbSBmb3JtIHRvIGNhcmRTdHVkaW9cbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGZsb3cgZnJvbSBjYXJkU3R1ZGlvIC0+IGZvcm0gYWZ0ZXIgdXBsb2Fkc1xuICAgIC8vIGNhcmRTdHVkaW8uc2V0UmVmZXJlbmNlSW1hZ2VzKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlcyk7XG4gICAgLy8gY2FyZFN0dWRpby5zZXRSZWZlcmVuY2VJbWFnZVVybHMoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzKTtcbiAgICBjYXJkU3R1ZGlvLnNldFVzZXJFbWFpbChmb3JtRGF0YS51c2VyRW1haWwpO1xuICAgIGNhcmRTdHVkaW8uc2V0U2VsZWN0ZWRJbWFnZU1vZGVsKGZvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbCk7XG4gICAgY2FyZFN0dWRpby5zZXRTZWxlY3RlZERyYWZ0TW9kZWwoZm9ybURhdGEuc2VsZWN0ZWREcmFmdE1vZGVsKTtcbiAgICBjYXJkU3R1ZGlvLnNldFNlbGVjdGVkUGFwZXJTaXplKGZvcm1EYXRhLnNlbGVjdGVkUGFwZXJTaXplKTtcbiAgICBjYXJkU3R1ZGlvLnNldE51bWJlck9mQ2FyZHMoZm9ybURhdGEubnVtYmVyT2ZDYXJkcyk7XG4gICAgY2FyZFN0dWRpby5zZXRJc0Zyb250QmFja09ubHkoZm9ybURhdGEuaXNGcm9udEJhY2tPbmx5KTtcbiAgfSwgW2NhcmRGb3JtLmZvcm1EYXRhLCBjYXJkRm9ybS5pc0luaXRpYWxMb2FkQ29tcGxldGVdKTtcblxuICAvLyBBdXRvLWNvbXBsZXRlIHN0ZXAgMSBvbmNlIHVzZXIgbWFrZXMgc2VsZWN0aW9uc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYXJkRm9ybS52YWxpZGF0ZVN0ZXAoMSkgJiYgIXdpemFyZFN0YXRlLmNvbXBsZXRlZFN0ZXBzLmluY2x1ZGVzKDEpKSB7XG4gICAgICB3aXphcmRTdGF0ZS5tYXJrU3RlcENvbXBsZXRlZCgxKTtcbiAgICB9XG4gIH0sIFtjYXJkRm9ybS5mb3JtRGF0YS5zZWxlY3RlZFR5cGUsIGNhcmRGb3JtLmZvcm1EYXRhLnNlbGVjdGVkVG9uZSwgY2FyZEZvcm0uZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUsIHdpemFyZFN0YXRlXSk7XG5cbiAgLy8gQXV0by1jb21wbGV0ZSBzdGVwIDQgb25jZSBlbWFpbCBpcyB2YWxpZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYXJkRm9ybS52YWxpZGF0ZVN0ZXAoNCkgJiYgIXdpemFyZFN0YXRlLmNvbXBsZXRlZFN0ZXBzLmluY2x1ZGVzKDQpKSB7XG4gICAgICB3aXphcmRTdGF0ZS5tYXJrU3RlcENvbXBsZXRlZCg0KTtcbiAgICB9XG4gIH0sIFtjYXJkRm9ybS5mb3JtRGF0YS51c2VyRW1haWwsIHdpemFyZFN0YXRlXSk7XG5cbiAgLy8gQXV0by1hZHZhbmNlIHRvIFN0ZXAgNiB3aGVuIGZpbmFsIGNhcmQgZ2VuZXJhdGlvbiBzdGFydHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FyZFN0dWRpby5pc0dlbmVyYXRpbmdGaW5hbENhcmQgJiYgd2l6YXJkU3RhdGUuY3VycmVudFN0ZXAgPCA2KSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBBdXRvLWFkdmFuY2luZyB0byBTdGVwIDY6IEZpbmFsIEdlbmVyYXRpb24nKTtcbiAgICAgIGlmICghd2l6YXJkU3RhdGUuY29tcGxldGVkU3RlcHMuaW5jbHVkZXMoNSkpIHtcbiAgICAgICAgd2l6YXJkU3RhdGUubWFya1N0ZXBDb21wbGV0ZWQoNSk7XG4gICAgICB9XG4gICAgICB3aXphcmRTdGF0ZS51cGRhdGVDdXJyZW50U3RlcCg2KTtcbiAgICB9XG4gIH0sIFtjYXJkU3R1ZGlvLmlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCwgd2l6YXJkU3RhdGVdKTtcblxuICAvLyBTeW5jIHJlZmVyZW5jZSBpbWFnZXMgZnJvbSBjYXJkU3R1ZGlvIHRvIGZvcm0gd2hlbiB0aGV5IGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FyZEZvcm0uaXNJbml0aWFsTG9hZENvbXBsZXRlKSByZXR1cm47XG4gICAgXG4gICAgLy8gU3luYyBpZiBjYXJkU3R1ZGlvIGhhcyBpbWFnZXMgYnV0IGZvcm0gZG9lc24ndCwgb3IgaWYgcGhvdG9SZWZlcmVuY2VzIGNoYW5nZWRcbiAgICBjb25zdCBzaG91bGRTeW5jID0gKFxuICAgICAgKGNhcmRTdHVkaW8ucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgXG4gICAgICAgY2FyZEZvcm0uZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCAhPT0gY2FyZFN0dWRpby5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoKSB8fFxuICAgICAgKGNhcmRTdHVkaW8ucGhvdG9SZWZlcmVuY2VzICYmIGNhcmRTdHVkaW8ucGhvdG9SZWZlcmVuY2VzICE9PSBjYXJkRm9ybS5mb3JtRGF0YS5waG90b1JlZmVyZW5jZXMpXG4gICAgKTtcbiAgICBcbiAgICBpZiAoc2hvdWxkU3luYykge1xuICAgICAgY2FyZEZvcm0udXBkYXRlRm9ybURhdGEoe1xuICAgICAgICByZWZlcmVuY2VJbWFnZXM6IGNhcmRTdHVkaW8ucmVmZXJlbmNlSW1hZ2VzLFxuICAgICAgICByZWZlcmVuY2VJbWFnZVVybHM6IGNhcmRTdHVkaW8ucmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgICAgICBwaG90b1JlZmVyZW5jZXM6IGNhcmRTdHVkaW8ucGhvdG9SZWZlcmVuY2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjYXJkU3R1ZGlvLnJlZmVyZW5jZUltYWdlVXJscywgY2FyZFN0dWRpby5yZWZlcmVuY2VJbWFnZXMsIGNhcmRTdHVkaW8ucGhvdG9SZWZlcmVuY2VzLCBjYXJkRm9ybS5pc0luaXRpYWxMb2FkQ29tcGxldGVdKTtcblxuICByZXR1cm4gbnVsbDtcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDYXJkV2l6YXJkRWZmZWN0cyIsImNhcmRTdHVkaW8iLCJjYXJkRm9ybSIsImNhcmRIaXN0b3J5Iiwid2l6YXJkU3RhdGUiLCJ1cGRhdGVXaXphcmRTdGF0ZSIsImlzUmVzdW1pbmdEcmFmdCIsImlzUmVzdG9yaW5nSm9icyIsImN1cnJlbnREcmFmdFNlc3Npb25JZCIsInNldEN1cnJlbnREcmFmdFNlc3Npb25JZCIsImxhc3RTYXZlZERyYWZ0Q291bnQiLCJzZXRMYXN0U2F2ZWREcmFmdENvdW50IiwicmVzdG9yZVBlbmRpbmdKb2JzIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnRTZXNzaW9uIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRyYWZ0Q2FyZHMiLCJsZW5ndGgiLCJkcmFmdEFnZSIsIkRhdGUiLCJub3ciLCJzYXZlZEF0IiwiZ2V0VGltZSIsInR3b0hvdXJzIiwic2V0RHJhZnRDYXJkcyIsInNldElzRHJhZnRNb2RlIiwiZm9ybURhdGEiLCJ1cGRhdGVGb3JtRGF0YSIsImlkIiwicmVtb3ZlSXRlbSIsInJlbW92ZURyYWZ0U2Vzc2lvbiIsImNoZWNrUGVuZGluZ0pvYnMiLCJpc0dlbmVyYXRpbmciLCJnZW5lcmF0aW9uUHJvZ3Jlc3MiLCJpc0dlbmVyYXRpbmdGaW5hbENhcmQiLCJpIiwiY29tcGxldGVkU3RlcHMiLCJpbmNsdWRlcyIsIm1hcmtTdGVwQ29tcGxldGVkIiwidXBkYXRlQ3VycmVudFN0ZXAiLCJpc0RyYWZ0TW9kZSIsImN1cnJlbnRTdGVwIiwiaXNJbml0aWFsTG9hZENvbXBsZXRlIiwic2VsZWN0ZWRUeXBlIiwic2VsZWN0ZWRUb25lIiwiaXNDYXJkQ29tcGxldGVkIiwiaGFzQ2FyZHMiLCJzaG91bGRTYXZlIiwidmFsaWREcmFmdHMiLCJmaWx0ZXIiLCJjYXJkIiwic2VsZWN0ZWREcmFmdEluZGV4Iiwic2Vzc2lvbklkIiwic2F2ZURyYWZ0U2Vzc2lvbiIsInVuZGVmaW5lZCIsImdlbmVyYXRlZENhcmQiLCJhZGRDb21wbGV0ZWRDYXJkIiwic2V0U2VsZWN0ZWRUeXBlIiwic2V0Q3VzdG9tQ2FyZFR5cGUiLCJjdXN0b21DYXJkVHlwZSIsInNldFNlbGVjdGVkVG9uZSIsInNldFRvRmllbGQiLCJ0b0ZpZWxkIiwic2V0RnJvbUZpZWxkIiwiZnJvbUZpZWxkIiwic2V0UmVsYXRpb25zaGlwRmllbGQiLCJyZWxhdGlvbnNoaXBGaWVsZCIsInNldFByb21wdCIsInByb21wdCIsInNldEZpbmFsQ2FyZE1lc3NhZ2UiLCJmaW5hbENhcmRNZXNzYWdlIiwic2V0SXNIYW5kd3JpdHRlbk1lc3NhZ2UiLCJpc0hhbmR3cml0dGVuTWVzc2FnZSIsInNldFNlbGVjdGVkQXJ0aXN0aWNTdHlsZSIsInNlbGVjdGVkQXJ0aXN0aWNTdHlsZSIsInNldEN1c3RvbVN0eWxlRGVzY3JpcHRpb24iLCJjdXN0b21TdHlsZURlc2NyaXB0aW9uIiwic2V0VXNlckVtYWlsIiwidXNlckVtYWlsIiwic2V0U2VsZWN0ZWRJbWFnZU1vZGVsIiwic2VsZWN0ZWRJbWFnZU1vZGVsIiwic2V0U2VsZWN0ZWREcmFmdE1vZGVsIiwic2VsZWN0ZWREcmFmdE1vZGVsIiwic2V0U2VsZWN0ZWRQYXBlclNpemUiLCJzZWxlY3RlZFBhcGVyU2l6ZSIsInNldE51bWJlck9mQ2FyZHMiLCJudW1iZXJPZkNhcmRzIiwic2V0SXNGcm9udEJhY2tPbmx5IiwiaXNGcm9udEJhY2tPbmx5IiwidmFsaWRhdGVTdGVwIiwic2hvdWxkU3luYyIsInJlZmVyZW5jZUltYWdlVXJscyIsInBob3RvUmVmZXJlbmNlcyIsInJlZmVyZW5jZUltYWdlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/wizard/CardWizardEffects.tsx\n"));

/***/ })

});
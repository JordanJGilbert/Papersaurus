"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useCardGeneration.ts":
/*!***********************************************!*\
  !*** ./hooks/cardStudio/useCardGeneration.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardGeneration: function() { return /* binding */ useCardGeneration; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/promptGenerator */ \"(app-pages-browser)/./lib/promptGenerator.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./hooks/cardStudio/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ useCardGeneration auto */ \n\n\n\n\n\nfunction useCardGeneration(props) {\n    const [isGenerating, setIsGenerating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generatedCard, setGeneratedCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generatedCards, setGeneratedCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedCardIndex, setSelectedCardIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isCardCompleted, setIsCardCompleted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [currentCardId, setCurrentCardId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Helper to clear progress interval\n    const clearProgressInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressInterval) {\n            clearInterval(progressInterval);\n            setProgressInterval(null);\n        }\n    }, [\n        progressInterval\n    ]);\n    // Handle final card completion\n    const handleFinalCardCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cardData)=>{\n        console.log(\"\\uD83C\\uDFAF handleFinalCardCompletion called with cardData:\", cardData);\n        console.log(\"\\uD83C\\uDFAF Current userEmail state:\", props.userEmail);\n        console.log(\"\\uD83C\\uDFAF Current states:\", {\n            isGenerating,\n            isCardCompleted,\n            generatedCard: generatedCard ? \"Present\" : \"None\",\n            progressPercentage\n        });\n        let cardWithQR = {\n            ...cardData\n        };\n        // Ensure the card has a valid createdAt date\n        if (!cardWithQR.createdAt) {\n            cardWithQR.createdAt = new Date();\n        } else if (typeof cardWithQR.createdAt === \"string\" || typeof cardWithQR.createdAt === \"number\") {\n            cardWithQR.createdAt = new Date(cardWithQR.createdAt);\n        }\n        // Ensure the card has a valid ID\n        if (!cardWithQR.id) {\n            cardWithQR.id = \"card-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n        }\n        console.log(\"\\uD83D\\uDD04 Final card data prepared:\", cardWithQR);\n        // Note: QR code overlay is now handled automatically by the backend\n        console.log(\"✅ Card completion processing finished - QR codes handled by backend\");\n        console.log(\"\\uD83C\\uDFAF Setting final card state:\", cardWithQR);\n        // Set the card states\n        setGeneratedCard(cardWithQR);\n        setGeneratedCards([\n            cardWithQR\n        ]);\n        setSelectedCardIndex(0);\n        setIsCardCompleted(true);\n        setIsGenerating(false);\n        props.setIsGeneratingFinalCard(false);\n        props.setIsDraftMode(false);\n        props.setDraftCompletionShown(false);\n        props.setDraftCompletionCount(0);\n        console.log(\"\\uD83C\\uDFAF Card states updated - isCardCompleted:\", true, \"generatedCard:\", cardWithQR);\n        // Don't clear the progress message here - it will be set by the WebSocket handler\n        // setGenerationProgress(\"\");\n        clearProgressInterval(); // Clear time-based progress\n        setProgressPercentage(100); // Ensure 100% on completion\n        // Scroll to card preview\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.scrollToCardPreview)();\n        // Capture generation time from backend\n        if (cardData.generationTimeSeconds) {\n            setGenerationDuration(cardData.generationTimeSeconds);\n        }\n        // Stop elapsed time tracking\n        props.stopElapsedTimeTracking();\n        // Set final progress after all states are updated\n        // Use a timeout to ensure React has processed all state updates\n        setTimeout(()=>{\n            setProgressPercentage(100);\n            setGenerationProgress(\"Generation complete! (100%)\");\n        }, 100);\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Your card is ready!\");\n        // Show email confirmation toast if email is provided\n        if (props.userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"✉️ Card sent to \".concat(props.userEmail), {\n                duration: 5000\n            });\n        }\n        // Email notifications are handled by the backend\n        console.log(\"\\uD83D\\uDCE7 Email sending disabled - backend handles email notifications\");\n        console.log(\"✅ Final card completion process finished successfully\");\n        console.log(\"✅ Final states:\", {\n            isCardCompleted: true,\n            generatedCard: cardWithQR,\n            progressPercentage: 100\n        });\n    }, [\n        props,\n        isGenerating,\n        isCardCompleted,\n        generatedCard,\n        progressPercentage\n    ]);\n    // Main card generation function\n    const handleGenerateCardAsync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const { userEmail, selectedType, customCardType, selectedTone, selectedArtisticStyle, customStyleDescription, selectedImageModel, referenceImageUrls, prompt, toField, fromField, finalCardMessage, isHandwrittenMessage, isFrontBackOnly, selectedPaperSize, numberOfCards, saveJobToStorage, subscribeToJob, startElapsedTimeTracking, setCurrentJobId, setIsDraftMode, setDraftCards, setSelectedDraftIndex, setIsGeneratingFinalCard, setPreviewingDraftIndex, setDraftCompletionShown, setDraftCompletionCount } = props;\n        if (!userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter your email address\");\n            return;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(userEmail)) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter a valid email address\");\n            return;\n        }\n        // Validate custom style if selected\n        if (selectedArtisticStyle === \"custom\" && !customStyleDescription.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom artistic style\");\n            return;\n        }\n        // Validate reference images with model compatibility\n        if (referenceImageUrls.length > 0 && selectedImageModel !== \"gpt-image-1\") {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Reference photos are only supported with GPT Image 1 model. Please switch to GPT Image 1 in Advanced Options or remove reference photos.\");\n            return;\n        }\n        // Clear all draft mode states to prevent UI conflicts\n        setIsDraftMode(false);\n        setDraftCards([\n            null,\n            null,\n            null,\n            null,\n            null\n        ]);\n        setSelectedDraftIndex(-1);\n        setIsGeneratingFinalCard(false);\n        setPreviewingDraftIndex(-1);\n        setDraftCompletionShown(false);\n        setDraftCompletionCount(0);\n        // Clear any existing card states\n        setGeneratedCards([]);\n        setGeneratedCard(null);\n        setSelectedCardIndex(0);\n        setCurrentCardId(null);\n        setIsCardCompleted(false);\n        // Stop any existing timers first\n        props.stopElapsedTimeTracking();\n        // Clear any existing progress interval\n        clearProgressInterval();\n        setIsGenerating(true);\n        startElapsedTimeTracking();\n        setGenerationProgress(\"Creating your personalized card...\");\n        setProgressPercentage(0);\n        // Simple time-based progress - increases by ~1.1% per second (90 seconds to reach 100%)\n        const interval = setInterval(()=>{\n            setProgressPercentage((prev)=>{\n                const newProgress = prev + 1.1;\n                return newProgress >= 95 ? 95 : newProgress; // Cap at 95% until completion\n            });\n        }, 1000); // Update every second\n        setProgressInterval(interval);\n        try {\n            // Create job tracking\n            const jobId = (0,uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n            setCurrentJobId(jobId);\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = _constants__WEBPACK_IMPORTED_MODULE_3__.cardTones.find((tone)=>tone.id === selectedTone);\n            let messageContent = finalCardMessage;\n            // Handle message generation if needed\n            if (isHandwrittenMessage) {\n                messageContent = \"[Blank space for handwritten message]\";\n            } else if (!messageContent.trim() && !isFrontBackOnly) {\n                setGenerationProgress(\"✍️ Writing the perfect message...\");\n                const autoMessagePrompt = \"Create a heartfelt message for a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nCard Theme/Description: \"').concat(prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"), '\"\\n').concat(toField ? \"Recipient: \".concat(toField) : \"Recipient: [not specified]\", \"\\n\").concat(fromField ? \"Sender: \".concat(fromField) : \"Sender: [not specified]\", \"\\n\\nInstructions:\\n- Write a message that feels personal and genuine\\n- Keep it concise but meaningful (2-4 sentences ideal)\\n- Make it feel authentic, not generic\\n- Keep content family-friendly and appropriate for all ages\\n- \").concat(fromField ? 'End the message with a signature line like \"Love, '.concat(fromField, '\" or \"- ').concat(fromField, '\" or similar, naturally integrated into the message.') : \"\", \"\\n\\nReturn ONLY the message text that should appear inside the card.\\n\\nIMPORTANT: Wrap your final message in <MESSAGE> </MESSAGE> tags.\");\n                const generatedMessage = await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.chatWithAI)(autoMessagePrompt, {\n                    model: \"gemini-2.5-pro\",\n                    includeThoughts: false\n                });\n                if (generatedMessage === null || generatedMessage === void 0 ? void 0 : generatedMessage.trim()) {\n                    const messageMatch = generatedMessage.match(/<MESSAGE>([\\s\\S]*?)<\\/MESSAGE>/);\n                    if (messageMatch && messageMatch[1]) {\n                        messageContent = messageMatch[1].trim();\n                    }\n                }\n            }\n            // Generate style and paper config\n            const selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_3__.artisticStyles.find((style)=>style.id === selectedArtisticStyle);\n            const styleModifier = selectedArtisticStyle === \"custom\" ? customStyleDescription : (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n            const paperConfig = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize) || _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes[0];\n            setGenerationProgress(\"\\uD83C\\uDFA8 Creating artistic vision for your card...\");\n            // Use PromptGenerator for card prompts\n            const cardConfig = {\n                cardType: selectedType,\n                customCardType: customCardType,\n                tone: selectedTone,\n                toneDescription: (selectedToneObj === null || selectedToneObj === void 0 ? void 0 : selectedToneObj.description.toLowerCase()) || \"heartfelt and sincere\",\n                theme: prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"),\n                toField: toField,\n                fromField: fromField,\n                message: messageContent,\n                isHandwrittenMessage: isHandwrittenMessage,\n                artisticStyle: selectedStyle,\n                referenceImageUrls: referenceImageUrls,\n                photoAnalyses: props.photoAnalyses,\n                isFrontBackOnly: isFrontBackOnly,\n                selectedImageModel: selectedImageModel\n            };\n            const generatedPrompts = _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.generateCardPrompts(cardConfig);\n            // Apply reference photo enhancements for GPT-1\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-1\") {\n                generatedPrompts.frontCover = _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.enhancePromptWithReferencePhotos(generatedPrompts.frontCover, true, selectedImageModel);\n            }\n            const formattedPrompts = {\n                frontCover: generatedPrompts.frontCover,\n                backCover: generatedPrompts.backCover,\n                ...isFrontBackOnly ? {} : {\n                    leftInterior: generatedPrompts.leftInterior,\n                    rightInterior: generatedPrompts.rightInterior\n                }\n            };\n            if (!formattedPrompts || !formattedPrompts.frontCover) {\n                throw new Error(\"Failed to generate image prompts\");\n            }\n            // Save job data\n            const jobData = {\n                prompt: prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"),\n                selectedType,\n                customCardType,\n                selectedTone,\n                finalCardMessage: messageContent,\n                toField,\n                fromField,\n                userEmail,\n                selectedArtisticStyle,\n                customStyleDescription,\n                selectedImageModel,\n                isFrontBackOnly,\n                numberOfCards,\n                selectedPaperSize,\n                prompts: formattedPrompts,\n                paperConfig\n            };\n            saveJobToStorage(jobId, jobData);\n            setGenerationProgress(\"\\uD83D\\uDE80 Starting background generation...\");\n            // Prepare input images for reference photo support\n            const inputImages = [];\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-image-1\") {\n                inputImages.push(...referenceImageUrls);\n            }\n            const response = await fetch(\"/api/generate-card-async\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobId,\n                    prompts: formattedPrompts,\n                    config: {\n                        userNumber: \"+17145986105\",\n                        modelVersion: selectedImageModel,\n                        aspectRatio: paperConfig.aspectRatio,\n                        quality: \"high\",\n                        outputFormat: \"jpeg\",\n                        outputCompression: 100,\n                        moderation: \"low\",\n                        dimensions: paperConfig.dimensions,\n                        isFrontBackOnly,\n                        userEmail,\n                        cardType: cardTypeForPrompt,\n                        toField,\n                        fromField,\n                        isDraftMode: false,\n                        ...inputImages.length > 0 && {\n                            input_images: inputImages,\n                            input_images_mode: \"front_cover_only\"\n                        }\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.status !== \"processing\") {\n                throw new Error(result.message || \"Failed to start card generation\");\n            }\n            setGenerationProgress(\"✨ Bringing your vision to life...\");\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Card generation started!\");\n            // Subscribe to WebSocket updates for real-time progress\n            subscribeToJob(jobId);\n        } catch (error) {\n            console.error(\"Card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate card. Please try again.\");\n            if (currentCardId) {\n                props.removeJobFromStorage(currentCardId);\n                setCurrentCardId(null);\n            }\n            setIsGenerating(false);\n            setGenerationProgress(\"\");\n            setProgressPercentage(0);\n            props.stopElapsedTimeTracking();\n            clearProgressInterval(); // Clear time-based progress on error\n        }\n    }, [\n        props,\n        currentCardId,\n        clearProgressInterval\n    ]);\n    return {\n        isGenerating,\n        setIsGenerating,\n        generatedCard,\n        setGeneratedCard,\n        generatedCards,\n        setGeneratedCards,\n        selectedCardIndex,\n        setSelectedCardIndex,\n        isCardCompleted,\n        setIsCardCompleted,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        currentCardId,\n        setCurrentCardId,\n        generationDuration,\n        setGenerationDuration,\n        handleGenerateCardAsync,\n        handleFinalCardCompletion,\n        clearProgressInterval\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlQ2FyZEdlbmVyYXRpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7dUVBRThDO0FBQ2Y7QUFDSztBQUNnQztBQUM4QjtBQUNyQjtBQXdDdEUsU0FBU1csa0JBQWtCQyxLQUEwQjtJQUMxRCxNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHZCwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNlLGVBQWVDLGlCQUFpQixHQUFHaEIsK0NBQVFBLENBQXVCO0lBQ3pFLE1BQU0sQ0FBQ2lCLGdCQUFnQkMsa0JBQWtCLEdBQUdsQiwrQ0FBUUEsQ0FBa0IsRUFBRTtJQUN4RSxNQUFNLENBQUNtQixtQkFBbUJDLHFCQUFxQixHQUFHcEIsK0NBQVFBLENBQVM7SUFDbkUsTUFBTSxDQUFDcUIsaUJBQWlCQyxtQkFBbUIsR0FBR3RCLCtDQUFRQSxDQUFVO0lBQ2hFLE1BQU0sQ0FBQ3VCLG9CQUFvQkMsc0JBQXNCLEdBQUd4QiwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUN5QixlQUFlQyxpQkFBaUIsR0FBRzFCLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUMyQixvQkFBb0JDLHNCQUFzQixHQUFHNUIsK0NBQVFBLENBQWdCO0lBRTVFLG9DQUFvQztJQUNwQyxNQUFNNkIsd0JBQXdCNUIsa0RBQVdBLENBQUM7UUFDeEMsSUFBSTZCLGtCQUFrQjtZQUNwQkMsY0FBY0Q7WUFDZEUsb0JBQW9CO1FBQ3RCO0lBQ0YsR0FBRztRQUFDRjtLQUFpQjtJQUVyQiwrQkFBK0I7SUFDL0IsTUFBTUcsNEJBQTRCaEMsa0RBQVdBLENBQUMsT0FBT2lDO1FBQ25EQyxRQUFRQyxHQUFHLENBQUMsZ0VBQXNERjtRQUNsRUMsUUFBUUMsR0FBRyxDQUFDLHlDQUErQnhCLE1BQU15QixTQUFTO1FBQzFERixRQUFRQyxHQUFHLENBQUMsZ0NBQXNCO1lBQ2hDdkI7WUFDQVE7WUFDQU4sZUFBZUEsZ0JBQWdCLFlBQVk7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QixtQkFBbUI7d0JBQ3JCLENBQUM7b0JBQ0g7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ2xCLFNBQVNtQixFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSXhCLE1BQU0saUJBQWlDLE9BQWhCSyxTQUFTb0IsTUFBTTtZQUNsRDtZQUVBLE1BQU1DLFNBQVMsTUFBTXJCLFNBQVNzQixJQUFJO1lBRWxDLElBQUlELE9BQU9ELE1BQU0sS0FBSyxjQUFjO2dCQUNsQyxNQUFNLElBQUl6QixNQUFNMEIsT0FBT3JDLE9BQU8sSUFBSTtZQUNwQztZQUVBMUYsc0JBQXNCO1lBQ3RCdEIseUNBQUtBLENBQUNzRCxPQUFPLENBQUM7WUFFZCx3REFBd0Q7WUFDeERvQixlQUFlYztRQUVqQixFQUFFLE9BQU9SLE9BQU87WUFDZC9DLFFBQVErQyxLQUFLLENBQUMsMEJBQTBCQTtZQUN4Q2hGLHlDQUFLQSxDQUFDZ0YsS0FBSyxDQUFDO1lBRVosSUFBSXpELGVBQWU7Z0JBQ2pCYixNQUFNNkksb0JBQW9CLENBQUNoSTtnQkFDM0JDLGlCQUFpQjtZQUNuQjtZQUVBWixnQkFBZ0I7WUFDaEJVLHNCQUFzQjtZQUN0QjRCLHNCQUFzQjtZQUN0QnhDLE1BQU0wQyx1QkFBdUI7WUFDN0J6Qix5QkFBeUIscUNBQXFDO1FBQ2hFO0lBQ0YsR0FBRztRQUFDakI7UUFBT2E7UUFBZUk7S0FBc0I7SUFFaEQsT0FBTztRQUNMaEI7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQWM7UUFDQWM7UUFDQTNCO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0ErQjtRQUNBMUI7UUFDQUo7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlQ2FyZEdlbmVyYXRpb24udHM/MDVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJzb25uZXJcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgUHJvbXB0R2VuZXJhdG9yLCBDYXJkQ29uZmlnIH0gZnJvbSAnQC9saWIvcHJvbXB0R2VuZXJhdG9yJztcbmltcG9ydCB7IEdlbmVyYXRlZENhcmQsIGNhcmRUb25lcywgYXJ0aXN0aWNTdHlsZXMsIHBhcGVyU2l6ZXMsIFBob3RvQW5hbHlzaXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjaGF0V2l0aEFJLCBzZW5kVGhhbmtZb3VFbWFpbCwgc2Nyb2xsVG9DYXJkUHJldmlldyB9IGZyb20gJy4vdXRpbHMnO1xuXG5pbnRlcmZhY2UgQ2FyZEdlbmVyYXRpb25Qcm9wcyB7XG4gIC8vIEZvcm0gZGF0YVxuICBzZWxlY3RlZFR5cGU6IHN0cmluZztcbiAgY3VzdG9tQ2FyZFR5cGU6IHN0cmluZztcbiAgc2VsZWN0ZWRUb25lOiBzdHJpbmc7XG4gIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZTogc3RyaW5nO1xuICBjdXN0b21TdHlsZURlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHNlbGVjdGVkSW1hZ2VNb2RlbDogc3RyaW5nO1xuICBzZWxlY3RlZFBhcGVyU2l6ZTogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbiAgdG9GaWVsZDogc3RyaW5nO1xuICBmcm9tRmllbGQ6IHN0cmluZztcbiAgdXNlckVtYWlsOiBzdHJpbmc7XG4gIGZpbmFsQ2FyZE1lc3NhZ2U6IHN0cmluZztcbiAgaXNIYW5kd3JpdHRlbk1lc3NhZ2U6IGJvb2xlYW47XG4gIGlzRnJvbnRCYWNrT25seTogYm9vbGVhbjtcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBzdHJpbmdbXTtcbiAgcGhvdG9BbmFseXNlcz86IFBob3RvQW5hbHlzaXNbXTtcbiAgbnVtYmVyT2ZDYXJkczogbnVtYmVyO1xuICBcbiAgLy8gSm9iIG1hbmFnZW1lbnRcbiAgc2F2ZUpvYlRvU3RvcmFnZTogKGpvYklkOiBzdHJpbmcsIGpvYkRhdGE6IGFueSkgPT4gdm9pZDtcbiAgcmVtb3ZlSm9iRnJvbVN0b3JhZ2U6IChqb2JJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzdWJzY3JpYmVUb0pvYjogKGpvYklkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZzogKCkgPT4gdm9pZDtcbiAgc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmc6ICgpID0+IHZvaWQ7XG4gIHNldEN1cnJlbnRKb2JJZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBcbiAgLy8gRHJhZnQgc3RhdGUgc2V0dGVyc1xuICBzZXRJc0RyYWZ0TW9kZTogKHZhbHVlOiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXREcmFmdENhcmRzOiAodmFsdWU6IGFueSkgPT4gdm9pZDtcbiAgc2V0U2VsZWN0ZWREcmFmdEluZGV4OiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcbiAgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkOiAodmFsdWU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldFByZXZpZXdpbmdEcmFmdEluZGV4OiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcbiAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd246ICh2YWx1ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RHJhZnRDb21wbGV0aW9uQ291bnQ6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FyZEdlbmVyYXRpb24ocHJvcHM6IENhcmRHZW5lcmF0aW9uUHJvcHMpIHtcbiAgY29uc3QgW2lzR2VuZXJhdGluZywgc2V0SXNHZW5lcmF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2dlbmVyYXRlZENhcmQsIHNldEdlbmVyYXRlZENhcmRdID0gdXNlU3RhdGU8R2VuZXJhdGVkQ2FyZCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZ2VuZXJhdGVkQ2FyZHMsIHNldEdlbmVyYXRlZENhcmRzXSA9IHVzZVN0YXRlPEdlbmVyYXRlZENhcmRbXT4oW10pO1xuICBjb25zdCBbc2VsZWN0ZWRDYXJkSW5kZXgsIHNldFNlbGVjdGVkQ2FyZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtpc0NhcmRDb21wbGV0ZWQsIHNldElzQ2FyZENvbXBsZXRlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uUHJvZ3Jlc3MsIHNldEdlbmVyYXRpb25Qcm9ncmVzc10gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBjb25zdCBbY3VycmVudENhcmRJZCwgc2V0Q3VycmVudENhcmRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRpb25EdXJhdGlvbiwgc2V0R2VuZXJhdGlvbkR1cmF0aW9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBcbiAgLy8gSGVscGVyIHRvIGNsZWFyIHByb2dyZXNzIGludGVydmFsXG4gIGNvbnN0IGNsZWFyUHJvZ3Jlc3NJbnRlcnZhbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocHJvZ3Jlc3NJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChwcm9ncmVzc0ludGVydmFsKTtcbiAgICAgIHNldFByb2dyZXNzSW50ZXJ2YWwobnVsbCk7XG4gICAgfVxuICB9LCBbcHJvZ3Jlc3NJbnRlcnZhbF0pO1xuXG4gIC8vIEhhbmRsZSBmaW5hbCBjYXJkIGNvbXBsZXRpb25cbiAgY29uc3QgaGFuZGxlRmluYWxDYXJkQ29tcGxldGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChjYXJkRGF0YTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/Cfjq8gaGFuZGxlRmluYWxDYXJkQ29tcGxldGlvbiBjYWxsZWQgd2l0aCBjYXJkRGF0YTonLCBjYXJkRGF0YSk7XG4gICAgY29uc29sZS5sb2coJ/Cfjq8gQ3VycmVudCB1c2VyRW1haWwgc3RhdGU6JywgcHJvcHMudXNlckVtYWlsKTtcbiAgICBjb25zb2xlLmxvZygn8J+OryBDdXJyZW50IHN0YXRlczonLCB7XG4gICAgICBpc0dlbmVyYXRpbmcsXG4gICAgICBpc0NhcmRDb21wbGV0ZWQsXG4gICAgICBnZW5lcmF0ZWRDYXJkOiBnZW5lcmF0ZWRDYXJkID8gJ1ByZXNlbnQnIDogJ05vbmUnLFxuICAgICAgcHJvZ3Jlc3NQZXJjZW50YWdlXG4gICAgfSk7XG4gICAgbGV0IGNhcmRXaXRoUVIgPSB7IC4uLmNhcmREYXRhIH07XG4gICAgXG4gICAgLy8gRW5zdXJlIHRoZSBjYXJkIGhhcyBhIHZhbGlkIGNyZWF0ZWRBdCBkYXRlXG4gICAgaWYgKCFjYXJkV2l0aFFSLmNyZWF0ZWRBdCkge1xuICAgICAgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhcmRXaXRoUVIuY3JlYXRlZEF0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPT09ICdudW1iZXInKSB7XG4gICAgICBjYXJkV2l0aFFSLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKGNhcmRXaXRoUVIuY3JlYXRlZEF0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIHRoZSBjYXJkIGhhcyBhIHZhbGlkIElEXG4gICAgaWYgKCFjYXJkV2l0aFFSLmlkKSB7XG4gICAgICBjYXJkV2l0aFFSLmlkID0gYGNhcmQtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+UhCBGaW5hbCBjYXJkIGRhdGEgcHJlcGFyZWQ6JywgY2FyZFdpdGhRUik7XG4gICAgXG4gICAgLy8gTm90ZTogUVIgY29kZSBvdmVybGF5IGlzIG5vdyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJhY2tlbmRcbiAgICBjb25zb2xlLmxvZygn4pyFIENhcmQgY29tcGxldGlvbiBwcm9jZXNzaW5nIGZpbmlzaGVkIC0gUVIgY29kZXMgaGFuZGxlZCBieSBiYWNrZW5kJyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfjq8gU2V0dGluZyBmaW5hbCBjYXJkIHN0YXRlOicsIGNhcmRXaXRoUVIpO1xuICAgIFxuICAgIC8vIFNldCB0aGUgY2FyZCBzdGF0ZXNcbiAgICBzZXRHZW5lcmF0ZWRDYXJkKGNhcmRXaXRoUVIpO1xuICAgIHNldEdlbmVyYXRlZENhcmRzKFtjYXJkV2l0aFFSXSk7XG4gICAgc2V0U2VsZWN0ZWRDYXJkSW5kZXgoMCk7XG4gICAgc2V0SXNDYXJkQ29tcGxldGVkKHRydWUpO1xuICAgIHNldElzR2VuZXJhdGluZyhmYWxzZSk7XG4gICAgcHJvcHMuc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkKGZhbHNlKTtcbiAgICBwcm9wcy5zZXRJc0RyYWZ0TW9kZShmYWxzZSk7XG4gICAgcHJvcHMuc2V0RHJhZnRDb21wbGV0aW9uU2hvd24oZmFsc2UpO1xuICAgIHByb3BzLnNldERyYWZ0Q29tcGxldGlvbkNvdW50KDApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46vIENhcmQgc3RhdGVzIHVwZGF0ZWQgLSBpc0NhcmRDb21wbGV0ZWQ6JywgdHJ1ZSwgJ2dlbmVyYXRlZENhcmQ6JywgY2FyZFdpdGhRUik7XG4gICAgLy8gRG9uJ3QgY2xlYXIgdGhlIHByb2dyZXNzIG1lc3NhZ2UgaGVyZSAtIGl0IHdpbGwgYmUgc2V0IGJ5IHRoZSBXZWJTb2NrZXQgaGFuZGxlclxuICAgIC8vIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlwiKTtcbiAgICBjbGVhclByb2dyZXNzSW50ZXJ2YWwoKTsgLy8gQ2xlYXIgdGltZS1iYXNlZCBwcm9ncmVzc1xuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgxMDApOyAvLyBFbnN1cmUgMTAwJSBvbiBjb21wbGV0aW9uXG4gICAgXG4gICAgLy8gU2Nyb2xsIHRvIGNhcmQgcHJldmlld1xuICAgIHNjcm9sbFRvQ2FyZFByZXZpZXcoKTtcbiAgICBcbiAgICAvLyBDYXB0dXJlIGdlbmVyYXRpb24gdGltZSBmcm9tIGJhY2tlbmRcbiAgICBpZiAoY2FyZERhdGEuZ2VuZXJhdGlvblRpbWVTZWNvbmRzKSB7XG4gICAgICBzZXRHZW5lcmF0aW9uRHVyYXRpb24oY2FyZERhdGEuZ2VuZXJhdGlvblRpbWVTZWNvbmRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcCBlbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgICBwcm9wcy5zdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgIFxuICAgIC8vIFNldCBmaW5hbCBwcm9ncmVzcyBhZnRlciBhbGwgc3RhdGVzIGFyZSB1cGRhdGVkXG4gICAgLy8gVXNlIGEgdGltZW91dCB0byBlbnN1cmUgUmVhY3QgaGFzIHByb2Nlc3NlZCBhbGwgc3RhdGUgdXBkYXRlc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDEwMCk7XG4gICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCJHZW5lcmF0aW9uIGNvbXBsZXRlISAoMTAwJSlcIik7XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICB0b2FzdC5zdWNjZXNzKFwi8J+OiSBZb3VyIGNhcmQgaXMgcmVhZHkhXCIpO1xuICAgIFxuICAgIC8vIFNob3cgZW1haWwgY29uZmlybWF0aW9uIHRvYXN0IGlmIGVtYWlsIGlzIHByb3ZpZGVkXG4gICAgaWYgKHByb3BzLnVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoYOKcie+4jyBDYXJkIHNlbnQgdG8gJHtwcm9wcy51c2VyRW1haWx9YCwge1xuICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbWFpbCBub3RpZmljYXRpb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBiYWNrZW5kXG4gICAgY29uc29sZS5sb2coJ/Cfk6cgRW1haWwgc2VuZGluZyBkaXNhYmxlZCAtIGJhY2tlbmQgaGFuZGxlcyBlbWFpbCBub3RpZmljYXRpb25zJyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBGaW5hbCBjYXJkIGNvbXBsZXRpb24gcHJvY2VzcyBmaW5pc2hlZCBzdWNjZXNzZnVsbHknKTtcbiAgICBjb25zb2xlLmxvZygn4pyFIEZpbmFsIHN0YXRlczonLCB7XG4gICAgICBpc0NhcmRDb21wbGV0ZWQ6IHRydWUsXG4gICAgICBnZW5lcmF0ZWRDYXJkOiBjYXJkV2l0aFFSLFxuICAgICAgcHJvZ3Jlc3NQZXJjZW50YWdlOiAxMDBcbiAgICB9KTtcbiAgfSwgW3Byb3BzLCBpc0dlbmVyYXRpbmcsIGlzQ2FyZENvbXBsZXRlZCwgZ2VuZXJhdGVkQ2FyZCwgcHJvZ3Jlc3NQZXJjZW50YWdlXSk7XG5cbiAgLy8gTWFpbiBjYXJkIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgY29uc3QgaGFuZGxlR2VuZXJhdGVDYXJkQXN5bmMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdXNlckVtYWlsLFxuICAgICAgc2VsZWN0ZWRUeXBlLFxuICAgICAgY3VzdG9tQ2FyZFR5cGUsXG4gICAgICBzZWxlY3RlZFRvbmUsXG4gICAgICBzZWxlY3RlZEFydGlzdGljU3R5bGUsXG4gICAgICBjdXN0b21TdHlsZURlc2NyaXB0aW9uLFxuICAgICAgc2VsZWN0ZWRJbWFnZU1vZGVsLFxuICAgICAgcmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgICAgcHJvbXB0LFxuICAgICAgdG9GaWVsZCxcbiAgICAgIGZyb21GaWVsZCxcbiAgICAgIGZpbmFsQ2FyZE1lc3NhZ2UsXG4gICAgICBpc0hhbmR3cml0dGVuTWVzc2FnZSxcbiAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgIHNlbGVjdGVkUGFwZXJTaXplLFxuICAgICAgbnVtYmVyT2ZDYXJkcyxcbiAgICAgIHNhdmVKb2JUb1N0b3JhZ2UsXG4gICAgICBzdWJzY3JpYmVUb0pvYixcbiAgICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICAgIHNldEN1cnJlbnRKb2JJZCxcbiAgICAgIHNldElzRHJhZnRNb2RlLFxuICAgICAgc2V0RHJhZnRDYXJkcyxcbiAgICAgIHNldFNlbGVjdGVkRHJhZnRJbmRleCxcbiAgICAgIHNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZCxcbiAgICAgIHNldFByZXZpZXdpbmdEcmFmdEluZGV4LFxuICAgICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24sXG4gICAgICBzZXREcmFmdENvbXBsZXRpb25Db3VudFxuICAgIH0gPSBwcm9wcztcblxuICAgIGlmICghdXNlckVtYWlsLnRyaW0oKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZW50ZXIgeW91ciBlbWFpbCBhZGRyZXNzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIGVtYWlsIHZhbGlkYXRpb25cbiAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QodXNlckVtYWlsKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGN1c3RvbSBzdHlsZSBpZiBzZWxlY3RlZFxuICAgIGlmIChzZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiY3VzdG9tXCIgJiYgIWN1c3RvbVN0eWxlRGVzY3JpcHRpb24udHJpbSgpKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSBkZXNjcmliZSB5b3VyIGN1c3RvbSBhcnRpc3RpYyBzdHlsZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSByZWZlcmVuY2UgaW1hZ2VzIHdpdGggbW9kZWwgY29tcGF0aWJpbGl0eVxuICAgIGlmIChyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEltYWdlTW9kZWwgIT09IFwiZ3B0LWltYWdlLTFcIikge1xuICAgICAgdG9hc3QuZXJyb3IoXCJSZWZlcmVuY2UgcGhvdG9zIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIEdQVCBJbWFnZSAxIG1vZGVsLiBQbGVhc2Ugc3dpdGNoIHRvIEdQVCBJbWFnZSAxIGluIEFkdmFuY2VkIE9wdGlvbnMgb3IgcmVtb3ZlIHJlZmVyZW5jZSBwaG90b3MuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFsbCBkcmFmdCBtb2RlIHN0YXRlcyB0byBwcmV2ZW50IFVJIGNvbmZsaWN0c1xuICAgIHNldElzRHJhZnRNb2RlKGZhbHNlKTtcbiAgICBzZXREcmFmdENhcmRzKFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSk7XG4gICAgc2V0U2VsZWN0ZWREcmFmdEluZGV4KC0xKTtcbiAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQoZmFsc2UpO1xuICAgIHNldFByZXZpZXdpbmdEcmFmdEluZGV4KC0xKTtcbiAgICBzZXREcmFmdENvbXBsZXRpb25TaG93bihmYWxzZSk7XG4gICAgc2V0RHJhZnRDb21wbGV0aW9uQ291bnQoMCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGNhcmQgc3RhdGVzXG4gICAgc2V0R2VuZXJhdGVkQ2FyZHMoW10pO1xuICAgIHNldEdlbmVyYXRlZENhcmQobnVsbCk7XG4gICAgc2V0U2VsZWN0ZWRDYXJkSW5kZXgoMCk7XG4gICAgc2V0Q3VycmVudENhcmRJZChudWxsKTtcbiAgICBzZXRJc0NhcmRDb21wbGV0ZWQoZmFsc2UpO1xuXG4gICAgLy8gU3RvcCBhbnkgZXhpc3RpbmcgdGltZXJzIGZpcnN0XG4gICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcHJvZ3Jlc3MgaW50ZXJ2YWxcbiAgICBjbGVhclByb2dyZXNzSW50ZXJ2YWwoKTtcbiAgICBcbiAgICBzZXRJc0dlbmVyYXRpbmcodHJ1ZSk7XG4gICAgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiQ3JlYXRpbmcgeW91ciBwZXJzb25hbGl6ZWQgY2FyZC4uLlwiKTtcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMCk7XG4gICAgXG4gICAgLy8gU2ltcGxlIHRpbWUtYmFzZWQgcHJvZ3Jlc3MgLSBpbmNyZWFzZXMgYnkgfjEuMSUgcGVyIHNlY29uZCAoOTAgc2Vjb25kcyB0byByZWFjaCAxMDAlKVxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKHByZXYgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9ncmVzcyA9IHByZXYgKyAxLjE7XG4gICAgICAgIHJldHVybiBuZXdQcm9ncmVzcyA+PSA5NSA/IDk1IDogbmV3UHJvZ3Jlc3M7IC8vIENhcCBhdCA5NSUgdW50aWwgY29tcGxldGlvblxuICAgICAgfSk7XG4gICAgfSwgMTAwMCk7IC8vIFVwZGF0ZSBldmVyeSBzZWNvbmRcbiAgICBcbiAgICBzZXRQcm9ncmVzc0ludGVydmFsKGludGVydmFsKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgam9iIHRyYWNraW5nXG4gICAgICBjb25zdCBqb2JJZCA9IHV1aWR2NCgpO1xuICAgICAgc2V0Q3VycmVudEpvYklkKGpvYklkKTtcbiAgICAgIFxuICAgICAgY29uc3QgY2FyZFR5cGVGb3JQcm9tcHQgPSBzZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBjdXN0b21DYXJkVHlwZSA6IHNlbGVjdGVkVHlwZTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVG9uZU9iaiA9IGNhcmRUb25lcy5maW5kKHRvbmUgPT4gdG9uZS5pZCA9PT0gc2VsZWN0ZWRUb25lKTtcbiAgICAgIGxldCBtZXNzYWdlQ29udGVudCA9IGZpbmFsQ2FyZE1lc3NhZ2U7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBtZXNzYWdlIGdlbmVyYXRpb24gaWYgbmVlZGVkXG4gICAgICBpZiAoaXNIYW5kd3JpdHRlbk1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZUNvbnRlbnQgPSBcIltCbGFuayBzcGFjZSBmb3IgaGFuZHdyaXR0ZW4gbWVzc2FnZV1cIjtcbiAgICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VDb250ZW50LnRyaW0oKSAmJiAhaXNGcm9udEJhY2tPbmx5KSB7XG4gICAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIuKcje+4jyBXcml0aW5nIHRoZSBwZXJmZWN0IG1lc3NhZ2UuLi5cIik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhdXRvTWVzc2FnZVByb21wdCA9IGBDcmVhdGUgYSBoZWFydGZlbHQgbWVzc2FnZSBmb3IgYSAke2NhcmRUeXBlRm9yUHJvbXB0fSBncmVldGluZyBjYXJkLlxuXG5DYXJkIFRoZW1lL0Rlc2NyaXB0aW9uOiBcIiR7cHJvbXB0IHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkYH1cIlxuJHt0b0ZpZWxkID8gYFJlY2lwaWVudDogJHt0b0ZpZWxkfWAgOiBcIlJlY2lwaWVudDogW25vdCBzcGVjaWZpZWRdXCJ9XG4ke2Zyb21GaWVsZCA/IGBTZW5kZXI6ICR7ZnJvbUZpZWxkfWAgOiBcIlNlbmRlcjogW25vdCBzcGVjaWZpZWRdXCJ9XG5cbkluc3RydWN0aW9uczpcbi0gV3JpdGUgYSBtZXNzYWdlIHRoYXQgZmVlbHMgcGVyc29uYWwgYW5kIGdlbnVpbmVcbi0gS2VlcCBpdCBjb25jaXNlIGJ1dCBtZWFuaW5nZnVsICgyLTQgc2VudGVuY2VzIGlkZWFsKVxuLSBNYWtlIGl0IGZlZWwgYXV0aGVudGljLCBub3QgZ2VuZXJpY1xuLSBLZWVwIGNvbnRlbnQgZmFtaWx5LWZyaWVuZGx5IGFuZCBhcHByb3ByaWF0ZSBmb3IgYWxsIGFnZXNcbi0gJHtmcm9tRmllbGQgPyBgRW5kIHRoZSBtZXNzYWdlIHdpdGggYSBzaWduYXR1cmUgbGluZSBsaWtlIFwiTG92ZSwgJHtmcm9tRmllbGR9XCIgb3IgXCItICR7ZnJvbUZpZWxkfVwiIG9yIHNpbWlsYXIsIG5hdHVyYWxseSBpbnRlZ3JhdGVkIGludG8gdGhlIG1lc3NhZ2UuYCA6IFwiXCJ9XG5cblJldHVybiBPTkxZIHRoZSBtZXNzYWdlIHRleHQgdGhhdCBzaG91bGQgYXBwZWFyIGluc2lkZSB0aGUgY2FyZC5cblxuSU1QT1JUQU5UOiBXcmFwIHlvdXIgZmluYWwgbWVzc2FnZSBpbiA8TUVTU0FHRT4gPC9NRVNTQUdFPiB0YWdzLmA7XG5cbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkTWVzc2FnZSA9IGF3YWl0IGNoYXRXaXRoQUkoYXV0b01lc3NhZ2VQcm9tcHQsIHtcbiAgICAgICAgICBtb2RlbDogXCJnZW1pbmktMi41LXByb1wiLFxuICAgICAgICAgIGluY2x1ZGVUaG91Z2h0czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VuZXJhdGVkTWVzc2FnZT8udHJpbSgpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZU1hdGNoID0gZ2VuZXJhdGVkTWVzc2FnZS5tYXRjaCgvPE1FU1NBR0U+KFtcXHNcXFNdKj8pPFxcL01FU1NBR0U+Lyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2VNYXRjaCAmJiBtZXNzYWdlTWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50ID0gbWVzc2FnZU1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgc3R5bGUgYW5kIHBhcGVyIGNvbmZpZ1xuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHlsZSA9IGFydGlzdGljU3R5bGVzLmZpbmQoc3R5bGUgPT4gc3R5bGUuaWQgPT09IHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSk7XG4gICAgICBjb25zdCBzdHlsZU1vZGlmaWVyID0gc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiIFxuICAgICAgICA/IGN1c3RvbVN0eWxlRGVzY3JpcHRpb24gXG4gICAgICAgIDogc2VsZWN0ZWRTdHlsZT8ucHJvbXB0TW9kaWZpZXIgfHwgXCJcIjtcblxuICAgICAgY29uc3QgcGFwZXJDb25maWcgPSBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSkgfHwgcGFwZXJTaXplc1swXTtcblxuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi8J+OqCBDcmVhdGluZyBhcnRpc3RpYyB2aXNpb24gZm9yIHlvdXIgY2FyZC4uLlwiKTtcblxuICAgICAgLy8gVXNlIFByb21wdEdlbmVyYXRvciBmb3IgY2FyZCBwcm9tcHRzXG4gICAgICBjb25zdCBjYXJkQ29uZmlnOiBDYXJkQ29uZmlnID0ge1xuICAgICAgICBjYXJkVHlwZTogc2VsZWN0ZWRUeXBlLFxuICAgICAgICBjdXN0b21DYXJkVHlwZTogY3VzdG9tQ2FyZFR5cGUsXG4gICAgICAgIHRvbmU6IHNlbGVjdGVkVG9uZSxcbiAgICAgICAgdG9uZURlc2NyaXB0aW9uOiBzZWxlY3RlZFRvbmVPYmo/LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkgfHwgXCJoZWFydGZlbHQgYW5kIHNpbmNlcmVcIixcbiAgICAgICAgdGhlbWU6IHByb21wdCB8fCBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZGAsXG4gICAgICAgIHRvRmllbGQ6IHRvRmllbGQsXG4gICAgICAgIGZyb21GaWVsZDogZnJvbUZpZWxkLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgaXNIYW5kd3JpdHRlbk1lc3NhZ2U6IGlzSGFuZHdyaXR0ZW5NZXNzYWdlLFxuICAgICAgICBhcnRpc3RpY1N0eWxlOiBzZWxlY3RlZFN0eWxlLFxuICAgICAgICByZWZlcmVuY2VJbWFnZVVybHM6IHJlZmVyZW5jZUltYWdlVXJscyxcbiAgICAgICAgcGhvdG9BbmFseXNlczogcHJvcHMucGhvdG9BbmFseXNlcyxcbiAgICAgICAgaXNGcm9udEJhY2tPbmx5OiBpc0Zyb250QmFja09ubHksXG4gICAgICAgIHNlbGVjdGVkSW1hZ2VNb2RlbDogc2VsZWN0ZWRJbWFnZU1vZGVsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBnZW5lcmF0ZWRQcm9tcHRzID0gUHJvbXB0R2VuZXJhdG9yLmdlbmVyYXRlQ2FyZFByb21wdHMoY2FyZENvbmZpZyk7XG5cbiAgICAgIC8vIEFwcGx5IHJlZmVyZW5jZSBwaG90byBlbmhhbmNlbWVudHMgZm9yIEdQVC0xXG4gICAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJbWFnZU1vZGVsID09PSBcImdwdC0xXCIpIHtcbiAgICAgICAgZ2VuZXJhdGVkUHJvbXB0cy5mcm9udENvdmVyID0gUHJvbXB0R2VuZXJhdG9yLmVuaGFuY2VQcm9tcHRXaXRoUmVmZXJlbmNlUGhvdG9zKFxuICAgICAgICAgIGdlbmVyYXRlZFByb21wdHMuZnJvbnRDb3ZlciwgXG4gICAgICAgICAgdHJ1ZSwgXG4gICAgICAgICAgc2VsZWN0ZWRJbWFnZU1vZGVsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlZFByb21wdHMgPSB7XG4gICAgICAgIGZyb250Q292ZXI6IGdlbmVyYXRlZFByb21wdHMuZnJvbnRDb3ZlcixcbiAgICAgICAgYmFja0NvdmVyOiBnZW5lcmF0ZWRQcm9tcHRzLmJhY2tDb3ZlcixcbiAgICAgICAgLi4uKGlzRnJvbnRCYWNrT25seSA/IHt9IDoge1xuICAgICAgICAgIGxlZnRJbnRlcmlvcjogZ2VuZXJhdGVkUHJvbXB0cy5sZWZ0SW50ZXJpb3IsXG4gICAgICAgICAgcmlnaHRJbnRlcmlvcjogZ2VuZXJhdGVkUHJvbXB0cy5yaWdodEludGVyaW9yXG4gICAgICAgIH0pXG4gICAgICB9O1xuXG4gICAgICBpZiAoIWZvcm1hdHRlZFByb21wdHMgfHwgIWZvcm1hdHRlZFByb21wdHMuZnJvbnRDb3Zlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgaW1hZ2UgcHJvbXB0c1wiKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSBqb2IgZGF0YVxuICAgICAgY29uc3Qgam9iRGF0YSA9IHtcbiAgICAgICAgcHJvbXB0OiBwcm9tcHQgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmRgLFxuICAgICAgICBzZWxlY3RlZFR5cGUsXG4gICAgICAgIGN1c3RvbUNhcmRUeXBlLFxuICAgICAgICBzZWxlY3RlZFRvbmUsXG4gICAgICAgIGZpbmFsQ2FyZE1lc3NhZ2U6IG1lc3NhZ2VDb250ZW50LFxuICAgICAgICB0b0ZpZWxkLFxuICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlLFxuICAgICAgICBjdXN0b21TdHlsZURlc2NyaXB0aW9uLFxuICAgICAgICBzZWxlY3RlZEltYWdlTW9kZWwsXG4gICAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgICAgbnVtYmVyT2ZDYXJkcyxcbiAgICAgICAgc2VsZWN0ZWRQYXBlclNpemUsXG4gICAgICAgIHByb21wdHM6IGZvcm1hdHRlZFByb21wdHMsXG4gICAgICAgIHBhcGVyQ29uZmlnXG4gICAgICB9O1xuICAgICAgXG4gICAgICBzYXZlSm9iVG9TdG9yYWdlKGpvYklkLCBqb2JEYXRhKTtcbiAgICAgIFxuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi8J+agCBTdGFydGluZyBiYWNrZ3JvdW5kIGdlbmVyYXRpb24uLi5cIik7XG4gICAgICBcbiAgICAgIC8vIFByZXBhcmUgaW5wdXQgaW1hZ2VzIGZvciByZWZlcmVuY2UgcGhvdG8gc3VwcG9ydFxuICAgICAgY29uc3QgaW5wdXRJbWFnZXM6IHN0cmluZ1tdID0gW107XG4gICAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJbWFnZU1vZGVsID09PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgICAgaW5wdXRJbWFnZXMucHVzaCguLi5yZWZlcmVuY2VJbWFnZVVybHMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2dlbmVyYXRlLWNhcmQtYXN5bmMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGpvYklkLFxuICAgICAgICAgIHByb21wdHM6IGZvcm1hdHRlZFByb21wdHMsXG4gICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICB1c2VyTnVtYmVyOiBcIisxNzE0NTk4NjEwNVwiLFxuICAgICAgICAgICAgbW9kZWxWZXJzaW9uOiBzZWxlY3RlZEltYWdlTW9kZWwsXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogcGFwZXJDb25maWcuYXNwZWN0UmF0aW8sXG4gICAgICAgICAgICBxdWFsaXR5OiBcImhpZ2hcIixcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdDogXCJqcGVnXCIsXG4gICAgICAgICAgICBvdXRwdXRDb21wcmVzc2lvbjogMTAwLFxuICAgICAgICAgICAgbW9kZXJhdGlvbjogXCJsb3dcIixcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhcGVyQ29uZmlnLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBpc0Zyb250QmFja09ubHksXG4gICAgICAgICAgICB1c2VyRW1haWwsXG4gICAgICAgICAgICBjYXJkVHlwZTogY2FyZFR5cGVGb3JQcm9tcHQsXG4gICAgICAgICAgICB0b0ZpZWxkLFxuICAgICAgICAgICAgZnJvbUZpZWxkLFxuICAgICAgICAgICAgaXNEcmFmdE1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLi4uKGlucHV0SW1hZ2VzLmxlbmd0aCA+IDAgJiYgeyBcbiAgICAgICAgICAgICAgaW5wdXRfaW1hZ2VzOiBpbnB1dEltYWdlcyxcbiAgICAgICAgICAgICAgaW5wdXRfaW1hZ2VzX21vZGU6IFwiZnJvbnRfY292ZXJfb25seVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gJ3Byb2Nlc3NpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHN0YXJ0IGNhcmQgZ2VuZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCLinKggQnJpbmdpbmcgeW91ciB2aXNpb24gdG8gbGlmZS4uLlwiKTtcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoXCLwn46JIENhcmQgZ2VuZXJhdGlvbiBzdGFydGVkIVwiKTtcbiAgICAgIFxuICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlNvY2tldCB1cGRhdGVzIGZvciByZWFsLXRpbWUgcHJvZ3Jlc3NcbiAgICAgIHN1YnNjcmliZVRvSm9iKGpvYklkKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYXJkIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FyZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50Q2FyZElkKSB7XG4gICAgICAgIHByb3BzLnJlbW92ZUpvYkZyb21TdG9yYWdlKGN1cnJlbnRDYXJkSWQpO1xuICAgICAgICBzZXRDdXJyZW50Q2FyZElkKG51bGwpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0dlbmVyYXRpbmcoZmFsc2UpO1xuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiXCIpO1xuICAgICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDApO1xuICAgICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICAgIGNsZWFyUHJvZ3Jlc3NJbnRlcnZhbCgpOyAvLyBDbGVhciB0aW1lLWJhc2VkIHByb2dyZXNzIG9uIGVycm9yXG4gICAgfVxuICB9LCBbcHJvcHMsIGN1cnJlbnRDYXJkSWQsIGNsZWFyUHJvZ3Jlc3NJbnRlcnZhbF0pO1xuXG4gIHJldHVybiB7XG4gICAgaXNHZW5lcmF0aW5nLFxuICAgIHNldElzR2VuZXJhdGluZyxcbiAgICBnZW5lcmF0ZWRDYXJkLFxuICAgIHNldEdlbmVyYXRlZENhcmQsXG4gICAgZ2VuZXJhdGVkQ2FyZHMsXG4gICAgc2V0R2VuZXJhdGVkQ2FyZHMsXG4gICAgc2VsZWN0ZWRDYXJkSW5kZXgsXG4gICAgc2V0U2VsZWN0ZWRDYXJkSW5kZXgsXG4gICAgaXNDYXJkQ29tcGxldGVkLFxuICAgIHNldElzQ2FyZENvbXBsZXRlZCxcbiAgICBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzLFxuICAgIHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgY3VycmVudENhcmRJZCxcbiAgICBzZXRDdXJyZW50Q2FyZElkLFxuICAgIGdlbmVyYXRpb25EdXJhdGlvbixcbiAgICBzZXRHZW5lcmF0aW9uRHVyYXRpb24sXG4gICAgaGFuZGxlR2VuZXJhdGVDYXJkQXN5bmMsXG4gICAgaGFuZGxlRmluYWxDYXJkQ29tcGxldGlvbixcbiAgICBjbGVhclByb2dyZXNzSW50ZXJ2YWxcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInRvYXN0IiwidjQiLCJ1dWlkdjQiLCJQcm9tcHRHZW5lcmF0b3IiLCJjYXJkVG9uZXMiLCJhcnRpc3RpY1N0eWxlcyIsInBhcGVyU2l6ZXMiLCJjaGF0V2l0aEFJIiwic2Nyb2xsVG9DYXJkUHJldmlldyIsInVzZUNhcmRHZW5lcmF0aW9uIiwicHJvcHMiLCJpc0dlbmVyYXRpbmciLCJzZXRJc0dlbmVyYXRpbmciLCJnZW5lcmF0ZWRDYXJkIiwic2V0R2VuZXJhdGVkQ2FyZCIsImdlbmVyYXRlZENhcmRzIiwic2V0R2VuZXJhdGVkQ2FyZHMiLCJzZWxlY3RlZENhcmRJbmRleCIsInNldFNlbGVjdGVkQ2FyZEluZGV4IiwiaXNDYXJkQ29tcGxldGVkIiwic2V0SXNDYXJkQ29tcGxldGVkIiwiZ2VuZXJhdGlvblByb2dyZXNzIiwic2V0R2VuZXJhdGlvblByb2dyZXNzIiwiY3VycmVudENhcmRJZCIsInNldEN1cnJlbnRDYXJkSWQiLCJnZW5lcmF0aW9uRHVyYXRpb24iLCJzZXRHZW5lcmF0aW9uRHVyYXRpb24iLCJjbGVhclByb2dyZXNzSW50ZXJ2YWwiLCJwcm9ncmVzc0ludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInNldFByb2dyZXNzSW50ZXJ2YWwiLCJoYW5kbGVGaW5hbENhcmRDb21wbGV0aW9uIiwiY2FyZERhdGEiLCJjb25zb2xlIiwibG9nIiwidXNlckVtYWlsIiwicHJvZ3Jlc3NQZXJjZW50YWdlIiwiY2FyZFdpdGhRUiIsImNyZWF0ZWRBdCIsIkRhdGUiLCJpZCIsIk1hdGgiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZCIsInNldElzRHJhZnRNb2RlIiwic2V0RHJhZnRDb21wbGV0aW9uU2hvd24iLCJzZXREcmFmdENvbXBsZXRpb25Db3VudCIsInNldFByb2dyZXNzUGVyY2VudGFnZSIsImdlbmVyYXRpb25UaW1lU2Vjb25kcyIsInN0b3BFbGFwc2VkVGltZVRyYWNraW5nIiwic2V0VGltZW91dCIsInN1Y2Nlc3MiLCJ0cmltIiwiZHVyYXRpb24iLCJoYW5kbGVHZW5lcmF0ZUNhcmRBc3luYyIsInNlbGVjdGVkVHlwZSIsImN1c3RvbUNhcmRUeXBlIiwic2VsZWN0ZWRUb25lIiwic2VsZWN0ZWRBcnRpc3RpY1N0eWxlIiwiY3VzdG9tU3R5bGVEZXNjcmlwdGlvbiIsInNlbGVjdGVkSW1hZ2VNb2RlbCIsInJlZmVyZW5jZUltYWdlVXJscyIsInByb21wdCIsInRvRmllbGQiLCJmcm9tRmllbGQiLCJmaW5hbENhcmRNZXNzYWdlIiwiaXNIYW5kd3JpdHRlbk1lc3NhZ2UiLCJpc0Zyb250QmFja09ubHkiLCJzZWxlY3RlZFBhcGVyU2l6ZSIsIm51bWJlck9mQ2FyZHMiLCJzYXZlSm9iVG9TdG9yYWdlIiwic3Vic2NyaWJlVG9Kb2IiLCJzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmciLCJzZXRDdXJyZW50Sm9iSWQiLCJzZXREcmFmdENhcmRzIiwic2V0U2VsZWN0ZWREcmFmdEluZGV4Iiwic2V0UHJldmlld2luZ0RyYWZ0SW5kZXgiLCJlcnJvciIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwibGVuZ3RoIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJuZXdQcm9ncmVzcyIsImpvYklkIiwiY2FyZFR5cGVGb3JQcm9tcHQiLCJzZWxlY3RlZFRvbmVPYmoiLCJmaW5kIiwidG9uZSIsIm1lc3NhZ2VDb250ZW50IiwiYXV0b01lc3NhZ2VQcm9tcHQiLCJnZW5lcmF0ZWRNZXNzYWdlIiwibW9kZWwiLCJpbmNsdWRlVGhvdWdodHMiLCJtZXNzYWdlTWF0Y2giLCJtYXRjaCIsInNlbGVjdGVkU3R5bGUiLCJzdHlsZSIsInN0eWxlTW9kaWZpZXIiLCJwcm9tcHRNb2RpZmllciIsInBhcGVyQ29uZmlnIiwic2l6ZSIsImNhcmRDb25maWciLCJjYXJkVHlwZSIsInRvbmVEZXNjcmlwdGlvbiIsImRlc2NyaXB0aW9uIiwidG9Mb3dlckNhc2UiLCJ0aGVtZSIsIm1lc3NhZ2UiLCJhcnRpc3RpY1N0eWxlIiwicGhvdG9BbmFseXNlcyIsImdlbmVyYXRlZFByb21wdHMiLCJnZW5lcmF0ZUNhcmRQcm9tcHRzIiwiZnJvbnRDb3ZlciIsImVuaGFuY2VQcm9tcHRXaXRoUmVmZXJlbmNlUGhvdG9zIiwiZm9ybWF0dGVkUHJvbXB0cyIsImJhY2tDb3ZlciIsImxlZnRJbnRlcmlvciIsInJpZ2h0SW50ZXJpb3IiLCJFcnJvciIsImpvYkRhdGEiLCJwcm9tcHRzIiwiaW5wdXRJbWFnZXMiLCJwdXNoIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbmZpZyIsInVzZXJOdW1iZXIiLCJtb2RlbFZlcnNpb24iLCJhc3BlY3RSYXRpbyIsInF1YWxpdHkiLCJvdXRwdXRGb3JtYXQiLCJvdXRwdXRDb21wcmVzc2lvbiIsIm1vZGVyYXRpb24iLCJkaW1lbnNpb25zIiwiaXNEcmFmdE1vZGUiLCJpbnB1dF9pbWFnZXMiLCJpbnB1dF9pbWFnZXNfbW9kZSIsIm9rIiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsInJlbW92ZUpvYkZyb21TdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useCardGeneration.ts\n"));

/***/ })

});
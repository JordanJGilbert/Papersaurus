"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardCache.ts":
/*!*******************************!*\
  !*** ./hooks/useCardCache.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardCache: function() { return /* binding */ useCardCache; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CACHE_KEY = \"vibecarding_template_cache\";\nconst IMAGE_CACHE_KEY = \"vibecarding_image_cache\";\nconst CACHE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst IMAGE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nconst BACKEND_API_BASE_URL = \"https://vibecarding.com\" || 0;\nconst MAX_CONCURRENT_IMAGES = 3; // Netflix-style: Very conservative concurrent loads\n// Use the regular list endpoint - it's fast enough and always current\nconst CARDS_LIST_URL = \"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list\");\n// Global cache state\nlet globalCache = null;\nlet isPreloading = false;\nconst cacheListeners = new Set();\nconst notifyListeners = ()=>{\n    cacheListeners.forEach((listener)=>listener());\n};\nconst useCardCache = ()=>{\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalCache);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Subscribe to cache updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updateCache = ()=>setCache(globalCache);\n        cacheListeners.add(updateCache);\n        return ()=>cacheListeners.delete(updateCache);\n    }, []);\n    // Load from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!globalCache) {\n            try {\n                const stored = localStorage.getItem(CACHE_KEY);\n                if (stored) {\n                    const parsed = JSON.parse(stored);\n                    const isExpired = Date.now() - parsed.lastFetched > CACHE_DURATION;\n                    if (!isExpired) {\n                        globalCache = parsed;\n                        setCache(parsed);\n                        console.log(\"\\uD83D\\uDCE6 Loaded cached template cards:\", parsed.cards.length);\n                    } else {\n                        localStorage.removeItem(CACHE_KEY);\n                        console.log(\"\\uD83D\\uDDD1️ Expired cache removed\");\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to load cache:\", error);\n                localStorage.removeItem(CACHE_KEY);\n            }\n        }\n    }, []);\n    const loadCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, search = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        // If we have complete cache and no search, return cached data immediately\n        if (!search && (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) && !reset) {\n            const startIndex = (page - 1) * 40;\n            const endIndex = startIndex + 40;\n            return globalCache.cards.slice(startIndex, endIndex);\n        }\n        // For searches or when no cache, fetch from list endpoint\n        if (!search && (reset || !globalCache)) {\n            try {\n                // Fetch all cards with a large per_page to get everything at once\n                const response = await fetch(\"\".concat(CARDS_LIST_URL, \"?per_page=1000&template_mode=true\"));\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data.status === \"success\" && data.cards && Array.isArray(data.cards)) {\n                        var _data_pagination;\n                        // Update global cache\n                        globalCache = {\n                            cards: data.cards,\n                            totalCount: ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.total) || data.cards.length,\n                            lastFetched: Date.now(),\n                            isComplete: true\n                        };\n                        // Save to localStorage\n                        try {\n                            localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                        } catch (error) {\n                            console.warn(\"Failed to save cache to localStorage:\", error);\n                        }\n                        notifyListeners();\n                        // Return requested page\n                        const startIndex = (page - 1) * 40;\n                        const endIndex = startIndex + 40;\n                        return data.cards.slice(startIndex, endIndex);\n                    }\n                }\n            } catch (error) {\n                console.warn(\"List endpoint failed, falling back to paginated API:\", error);\n            }\n        }\n        // Fallback to original paginated API\n        setIsLoading(true);\n        setError(null);\n        try {\n            const params = new URLSearchParams({\n                page: page.toString(),\n                per_page: \"40\",\n                ...search && {\n                    search\n                },\n                template_mode: \"true\"\n            });\n            const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?\").concat(params));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\") {\n                const newCards = data.cards;\n                // Update global cache for non-search queries\n                if (!search) {\n                    if (reset || !globalCache) {\n                        globalCache = {\n                            cards: newCards,\n                            totalCount: data.pagination.total,\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    } else {\n                        // Append to existing cache\n                        const existingIds = new Set(globalCache.cards.map((card)=>card.id));\n                        const uniqueNewCards = newCards.filter((card)=>!existingIds.has(card.id));\n                        globalCache = {\n                            ...globalCache,\n                            cards: [\n                                ...globalCache.cards,\n                                ...uniqueNewCards\n                            ],\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    }\n                    // Save to localStorage\n                    try {\n                        localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                    } catch (error) {\n                        console.warn(\"Failed to save cache to localStorage:\", error);\n                    }\n                    notifyListeners();\n                }\n                return newCards;\n            } else {\n                throw new Error(data.message || \"Failed to load cards\");\n            }\n        } catch (error) {\n            console.error(\"Error loading cards:\", error);\n            setError(error instanceof Error ? error.message : \"Failed to load cards\");\n            return [];\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    const preloadAllCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isPreloading) {\n            return;\n        }\n        // Check if we already have a complete cache that's fresh\n        if (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) {\n            const cacheAge = Date.now() - globalCache.lastFetched;\n            if (cacheAge < CACHE_DURATION) {\n                console.log(\"⚡ Using fresh cached template data:\", globalCache.cards.length, \"cards\");\n                // No image preloading - instant response like reference site\n                console.log(\"⚡ Using fresh cached data, no preloading needed\");\n                return;\n            }\n        }\n        isPreloading = true;\n        console.log(\"\\uD83D\\uDE80 Starting immediate template preload on page load...\");\n        try {\n            // Load all cards from list endpoint (always current!)\n            const response = await fetch(\"\".concat(CARDS_LIST_URL, \"?per_page=1000&template_mode=true\"));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\" && data.cards && Array.isArray(data.cards)) {\n                var _data_pagination;\n                // Update global cache with all cards at once\n                globalCache = {\n                    cards: data.cards,\n                    totalCount: ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.total) || data.cards.length,\n                    lastFetched: Date.now(),\n                    isComplete: true // We have all cards!\n                };\n                // Save to localStorage\n                try {\n                    localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                } catch (error) {\n                    console.warn(\"Failed to save cache to localStorage:\", error);\n                }\n                notifyListeners();\n                console.log(\"✅ Page load template preload complete:\", data.cards.length, \"cards\");\n                // Ultra-simple: No image preloading, let browser lazy loading handle it\n                console.log(\"✅ Cards loaded, letting browser handle image loading\");\n            }\n        } catch (error) {\n            console.error(\"❌ Static preload failed, falling back to paginated:\", error);\n            // Fallback to old method if static fails\n            await preloadAllCardsLegacy();\n        } finally{\n            isPreloading = false;\n        }\n    }, []);\n    // Legacy preload method as fallback\n    const preloadAllCardsLegacy = async ()=>{\n        try {\n            let page = 1;\n            let hasMore = true;\n            let allCards = [];\n            while(hasMore && page <= 5){\n                var _data_pagination;\n                const cards = await loadCards(page, \"\", page === 1);\n                allCards = page === 1 ? cards : [\n                    ...allCards,\n                    ...cards\n                ];\n                // Check if we have more pages\n                const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?page=\").concat(page, \"&per_page=40&template_mode=true\"));\n                const data = await response.json();\n                hasMore = ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.has_next) || false;\n                page++;\n            }\n            console.log(\"✅ Legacy preload complete:\", allCards.length, \"cards\");\n            await preloadImages(allCards.slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Legacy preload failed:\", error);\n        }\n    };\n    const preloadImages = async (cards)=>{\n        // Disabled for instant loading like reference site\n        console.log(\"\\uD83D\\uDE80 Skipping image preloading for instant response\");\n        return;\n    };\n    const getCachedCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, itemsPerPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n        if (!globalCache) return [];\n        const startIndex = (page - 1) * itemsPerPage;\n        const endIndex = startIndex + itemsPerPage;\n        return globalCache.cards.slice(startIndex, endIndex);\n    }, []);\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalCache = null;\n        localStorage.removeItem(CACHE_KEY);\n        setCache(null);\n        notifyListeners();\n    }, []);\n    return {\n        cache,\n        isLoading,\n        error,\n        loadCards,\n        preloadAllCards,\n        getCachedCards,\n        clearCache,\n        hasCache: !!globalCache,\n        isComplete: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) || false,\n        totalCards: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.totalCount) || 0\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRDYWNoZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFzQnpELE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGlCQUFpQixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQ3BELE1BQU1DLHVCQUF1QixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQzFELE1BQU1DLHVCQUF1QkMseUJBQXVDLElBQUk7QUFDeEUsTUFBTUcsd0JBQXdCLEdBQUcsb0RBQW9EO0FBRXJGLHNFQUFzRTtBQUN0RSxNQUFNQyxpQkFBaUIsR0FBd0IsT0FBckJMLHNCQUFxQjtBQUUvQyxxQkFBcUI7QUFDckIsSUFBSU0sY0FBZ0M7QUFDcEMsSUFBSUMsZUFBZTtBQUNuQixNQUFNQyxpQkFBa0MsSUFBSUM7QUFFNUMsTUFBTUMsa0JBQWtCO0lBQ3RCRixlQUFlRyxPQUFPLENBQUNDLENBQUFBLFdBQVlBO0FBQ3JDO0FBRU8sTUFBTUMsZUFBZTtJQUMxQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFtQmE7SUFDckQsTUFBTSxDQUFDVSxXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixPQUFPQyxTQUFTLEdBQUcxQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsNkJBQTZCO0lBQzdCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU0wQixjQUFjLElBQU1MLFNBQVNUO1FBQ25DRSxlQUFlYSxHQUFHLENBQUNEO1FBQ25CLE9BQU8sSUFBTVosZUFBZWMsTUFBTSxDQUFDRjtJQUNyQyxHQUFHLEVBQUU7SUFFTCxrQ0FBa0M7SUFDbEMxQixnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ1ksYUFBYTtZQUNoQixJQUFJO2dCQUNGLE1BQU1pQixTQUFTQyxhQUFhQyxPQUFPLENBQUM3QjtnQkFDcEMsSUFBSTJCLFFBQVE7b0JBQ1YsTUFBTUcsU0FBb0JDLEtBQUtDLEtBQUss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QyxHQUFHLENBQUMsOEJBQThCK0MsU0FBUzdDLE1BQU0sRUFBRTtZQUMzRCxNQUFNOEMsY0FBY0QsU0FBU3BDLEtBQUssQ0FBQyxHQUFHO1FBRXhDLEVBQUUsT0FBTzNCLE9BQU87WUFDZGUsUUFBUWYsS0FBSyxDQUFDLDRCQUE0QkE7UUFDNUM7SUFDRjtJQUVBLE1BQU1nRSxnQkFBZ0IsT0FBTy9DO1FBQzNCLG1EQUFtRDtRQUNuREYsUUFBUUMsR0FBRyxDQUFDO1FBQ1o7SUFDRjtJQUVBLE1BQU1pRCxpQkFBaUJ4RixrREFBV0EsQ0FBQztZQUFDNEMsd0VBQWUsR0FBRzZDLGdGQUF1QjtRQUMzRSxJQUFJLENBQUM5RSxhQUFhLE9BQU8sRUFBRTtRQUUzQixNQUFNcUMsYUFBYSxDQUFDSixPQUFPLEtBQUs2QztRQUNoQyxNQUFNeEMsV0FBV0QsYUFBYXlDO1FBQzlCLE9BQU85RSxZQUFZNkIsS0FBSyxDQUFDVSxLQUFLLENBQUNGLFlBQVlDO0lBQzdDLEdBQUcsRUFBRTtJQUVMLE1BQU15QyxhQUFhMUYsa0RBQVdBLENBQUM7UUFDN0JXLGNBQWM7UUFDZGtCLGFBQWFhLFVBQVUsQ0FBQ3pDO1FBQ3hCbUIsU0FBUztRQUNUTDtJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFDTEk7UUFDQUU7UUFDQUU7UUFDQW9CO1FBQ0F1QztRQUNBTTtRQUNBRTtRQUNBQyxVQUFVLENBQUMsQ0FBQ2hGO1FBQ1pvQyxZQUFZcEMsQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhb0MsVUFBVSxLQUFJO1FBQ3ZDNkMsWUFBWWpGLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYWdELFVBQVUsS0FBSTtJQUN6QztBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlQ2FyZENhY2hlLnRzP2RjOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBHYWxsZXJ5Q2FyZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBmcm9udENvdmVyOiBzdHJpbmc7XG4gIGJhY2tDb3Zlcj86IHN0cmluZztcbiAgbGVmdFBhZ2U/OiBzdHJpbmc7XG4gIHJpZ2h0UGFnZT86IHN0cmluZztcbiAgY3JlYXRlZEF0OiBudW1iZXI7XG4gIGNyZWF0ZWRBdEZvcm1hdHRlZDogc3RyaW5nO1xuICBzaGFyZVVybD86IHN0cmluZztcbiAgaGFzSW1hZ2VzOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ2FyZENhY2hlIHtcbiAgY2FyZHM6IEdhbGxlcnlDYXJkW107XG4gIHRvdGFsQ291bnQ6IG51bWJlcjtcbiAgbGFzdEZldGNoZWQ6IG51bWJlcjtcbiAgaXNDb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ3ZpYmVjYXJkaW5nX3RlbXBsYXRlX2NhY2hlJztcbmNvbnN0IElNQUdFX0NBQ0hFX0tFWSA9ICd2aWJlY2FyZGluZ19pbWFnZV9jYWNoZSc7XG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IDEwICogNjAgKiAxMDAwOyAvLyAxMCBtaW51dGVzXG5jb25zdCBJTUFHRV9DQUNIRV9EVVJBVElPTiA9IDMwICogNjAgKiAxMDAwOyAvLyAzMCBtaW51dGVzXG5jb25zdCBCQUNLRU5EX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfQVBJX1VSTCB8fCAnaHR0cHM6Ly92aWJlY2FyZGluZy5jb20nO1xuY29uc3QgTUFYX0NPTkNVUlJFTlRfSU1BR0VTID0gMzsgLy8gTmV0ZmxpeC1zdHlsZTogVmVyeSBjb25zZXJ2YXRpdmUgY29uY3VycmVudCBsb2Fkc1xuXG4vLyBVc2UgdGhlIHJlZ3VsYXIgbGlzdCBlbmRwb2ludCAtIGl0J3MgZmFzdCBlbm91Z2ggYW5kIGFsd2F5cyBjdXJyZW50XG5jb25zdCBDQVJEU19MSVNUX1VSTCA9IGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9hcGkvY2FyZHMvbGlzdGA7XG5cbi8vIEdsb2JhbCBjYWNoZSBzdGF0ZVxubGV0IGdsb2JhbENhY2hlOiBDYXJkQ2FjaGUgfCBudWxsID0gbnVsbDtcbmxldCBpc1ByZWxvYWRpbmcgPSBmYWxzZTtcbmNvbnN0IGNhY2hlTGlzdGVuZXJzOiBTZXQ8KCkgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG5cbmNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgY2FjaGVMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VDYXJkQ2FjaGUgPSAoKSA9PiB7XG4gIGNvbnN0IFtjYWNoZSwgc2V0Q2FjaGVdID0gdXNlU3RhdGU8Q2FyZENhY2hlIHwgbnVsbD4oZ2xvYmFsQ2FjaGUpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjYWNoZSB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlQ2FjaGUgPSAoKSA9PiBzZXRDYWNoZShnbG9iYWxDYWNoZSk7XG4gICAgY2FjaGVMaXN0ZW5lcnMuYWRkKHVwZGF0ZUNhY2hlKTtcbiAgICByZXR1cm4gKCkgPT4gY2FjaGVMaXN0ZW5lcnMuZGVsZXRlKHVwZGF0ZUNhY2hlKTtcbiAgfSwgW10pO1xuXG4gIC8vIExvYWQgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWdsb2JhbENhY2hlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShDQUNIRV9LRVkpO1xuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkOiBDYXJkQ2FjaGUgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgY29uc3QgaXNFeHBpcmVkID0gRGF0ZS5ub3coKSAtIHBhcnNlZC5sYXN0RmV0Y2hlZCA+IENBQ0hFX0RVUkFUSU9OO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNFeHBpcmVkKSB7XG4gICAgICAgICAgICBnbG9iYWxDYWNoZSA9IHBhcnNlZDtcbiAgICAgICAgICAgIHNldENhY2hlKHBhcnNlZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBMb2FkZWQgY2FjaGVkIHRlbXBsYXRlIGNhcmRzOicsIHBhcnNlZC5jYXJkcy5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShDQUNIRV9LRVkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfl5HvuI8gRXhwaXJlZCBjYWNoZSByZW1vdmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBjYWNoZTonLCBlcnJvcik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKENBQ0hFX0tFWSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgbG9hZENhcmRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKHBhZ2U6IG51bWJlciA9IDEsIHNlYXJjaDogc3RyaW5nID0gJycsIHJlc2V0OiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEdhbGxlcnlDYXJkW10+ID0+IHtcbiAgICAvLyBJZiB3ZSBoYXZlIGNvbXBsZXRlIGNhY2hlIGFuZCBubyBzZWFyY2gsIHJldHVybiBjYWNoZWQgZGF0YSBpbW1lZGlhdGVseVxuICAgIGlmICghc2VhcmNoICYmIGdsb2JhbENhY2hlPy5pc0NvbXBsZXRlICYmICFyZXNldCkge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChwYWdlIC0gMSkgKiA0MDtcbiAgICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDQwO1xuICAgICAgcmV0dXJuIGdsb2JhbENhY2hlLmNhcmRzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBGb3Igc2VhcmNoZXMgb3Igd2hlbiBubyBjYWNoZSwgZmV0Y2ggZnJvbSBsaXN0IGVuZHBvaW50XG4gICAgaWYgKCFzZWFyY2ggJiYgKHJlc2V0IHx8ICFnbG9iYWxDYWNoZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCBjYXJkcyB3aXRoIGEgbGFyZ2UgcGVyX3BhZ2UgdG8gZ2V0IGV2ZXJ5dGhpbmcgYXQgb25jZVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0NBUkRTX0xJU1RfVVJMfT9wZXJfcGFnZT0xMDAwJnRlbXBsYXRlX21vZGU9dHJ1ZWApO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIGRhdGEuY2FyZHMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmNhcmRzKSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZVxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUgPSB7XG4gICAgICAgICAgICAgIGNhcmRzOiBkYXRhLmNhcmRzLFxuICAgICAgICAgICAgICB0b3RhbENvdW50OiBkYXRhLnBhZ2luYXRpb24/LnRvdGFsIHx8IGRhdGEuY2FyZHMubGVuZ3RoLFxuICAgICAgICAgICAgICBsYXN0RmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZ2xvYmFsQ2FjaGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgY2FjaGUgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiByZXF1ZXN0ZWQgcGFnZVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChwYWdlIC0gMSkgKiA0MDtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDQwO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuY2FyZHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdMaXN0IGVuZHBvaW50IGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIHBhZ2luYXRlZCBBUEk6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIG9yaWdpbmFsIHBhZ2luYXRlZCBBUElcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIHBhZ2U6IHBhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgcGVyX3BhZ2U6ICc0MCcsXG4gICAgICAgIC4uLihzZWFyY2ggJiYgeyBzZWFyY2ggfSksXG4gICAgICAgIHRlbXBsYXRlX21vZGU6ICd0cnVlJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L2FwaS9jYXJkcy9saXN0PyR7cGFyYW1zfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhcmRzID0gZGF0YS5jYXJkcyBhcyBHYWxsZXJ5Q2FyZFtdO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZSBmb3Igbm9uLXNlYXJjaCBxdWVyaWVzXG4gICAgICAgIGlmICghc2VhcmNoKSB7XG4gICAgICAgICAgaWYgKHJlc2V0IHx8ICFnbG9iYWxDYWNoZSkge1xuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUgPSB7XG4gICAgICAgICAgICAgIGNhcmRzOiBuZXdDYXJkcyxcbiAgICAgICAgICAgICAgdG90YWxDb3VudDogZGF0YS5wYWdpbmF0aW9uLnRvdGFsLFxuICAgICAgICAgICAgICBsYXN0RmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZTogIWRhdGEucGFnaW5hdGlvbi5oYXNfbmV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIGV4aXN0aW5nIGNhY2hlXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQoZ2xvYmFsQ2FjaGUuY2FyZHMubWFwKGNhcmQgPT4gY2FyZC5pZCkpO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmV3Q2FyZHMgPSBuZXdDYXJkcy5maWx0ZXIoY2FyZCA9PiAhZXhpc3RpbmdJZHMuaGFzKGNhcmQuaWQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUgPSB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbENhY2hlLFxuICAgICAgICAgICAgICBjYXJkczogWy4uLmdsb2JhbENhY2hlLmNhcmRzLCAuLi51bmlxdWVOZXdDYXJkc10sXG4gICAgICAgICAgICAgIGxhc3RGZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBpc0NvbXBsZXRlOiAhZGF0YS5wYWdpbmF0aW9uLmhhc19uZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZ2xvYmFsQ2FjaGUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0NhcmRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGxvYWQgY2FyZHMnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBjYXJkczonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9hZCBjYXJkcycpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHByZWxvYWRBbGxDYXJkcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNQcmVsb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGNvbXBsZXRlIGNhY2hlIHRoYXQncyBmcmVzaFxuICAgIGlmIChnbG9iYWxDYWNoZT8uaXNDb21wbGV0ZSkge1xuICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gZ2xvYmFsQ2FjaGUubGFzdEZldGNoZWQ7XG4gICAgICBpZiAoY2FjaGVBZ2UgPCBDQUNIRV9EVVJBVElPTikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFVzaW5nIGZyZXNoIGNhY2hlZCB0ZW1wbGF0ZSBkYXRhOicsIGdsb2JhbENhY2hlLmNhcmRzLmxlbmd0aCwgJ2NhcmRzJyk7XG4gICAgICAgIC8vIE5vIGltYWdlIHByZWxvYWRpbmcgLSBpbnN0YW50IHJlc3BvbnNlIGxpa2UgcmVmZXJlbmNlIHNpdGVcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBVc2luZyBmcmVzaCBjYWNoZWQgZGF0YSwgbm8gcHJlbG9hZGluZyBuZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzUHJlbG9hZGluZyA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgaW1tZWRpYXRlIHRlbXBsYXRlIHByZWxvYWQgb24gcGFnZSBsb2FkLi4uJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCBhbGwgY2FyZHMgZnJvbSBsaXN0IGVuZHBvaW50IChhbHdheXMgY3VycmVudCEpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0NBUkRTX0xJU1RfVVJMfT9wZXJfcGFnZT0xMDAwJnRlbXBsYXRlX21vZGU9dHJ1ZWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJyAmJiBkYXRhLmNhcmRzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jYXJkcykpIHtcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZSB3aXRoIGFsbCBjYXJkcyBhdCBvbmNlXG4gICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgIGNhcmRzOiBkYXRhLmNhcmRzLFxuICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEucGFnaW5hdGlvbj8udG90YWwgfHwgZGF0YS5jYXJkcy5sZW5ndGgsXG4gICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZSAvLyBXZSBoYXZlIGFsbCBjYXJkcyFcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZ2xvYmFsQ2FjaGUpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIGNhY2hlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUGFnZSBsb2FkIHRlbXBsYXRlIHByZWxvYWQgY29tcGxldGU6JywgZGF0YS5jYXJkcy5sZW5ndGgsICdjYXJkcycpO1xuICAgICAgICBcbiAgICAgICAgLy8gVWx0cmEtc2ltcGxlOiBObyBpbWFnZSBwcmVsb2FkaW5nLCBsZXQgYnJvd3NlciBsYXp5IGxvYWRpbmcgaGFuZGxlIGl0XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ2FyZHMgbG9hZGVkLCBsZXR0aW5nIGJyb3dzZXIgaGFuZGxlIGltYWdlIGxvYWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgU3RhdGljIHByZWxvYWQgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gcGFnaW5hdGVkOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG9sZCBtZXRob2QgaWYgc3RhdGljIGZhaWxzXG4gICAgICBhd2FpdCBwcmVsb2FkQWxsQ2FyZHNMZWdhY3koKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNQcmVsb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gTGVnYWN5IHByZWxvYWQgbWV0aG9kIGFzIGZhbGxiYWNrXG4gIGNvbnN0IHByZWxvYWRBbGxDYXJkc0xlZ2FjeSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHBhZ2UgPSAxO1xuICAgICAgbGV0IGhhc01vcmUgPSB0cnVlO1xuICAgICAgbGV0IGFsbENhcmRzOiBHYWxsZXJ5Q2FyZFtdID0gW107XG5cbiAgICAgIHdoaWxlIChoYXNNb3JlICYmIHBhZ2UgPD0gNSkgeyAvLyBMaW1pdCB0byA1IHBhZ2VzIG1heFxuICAgICAgICBjb25zdCBjYXJkcyA9IGF3YWl0IGxvYWRDYXJkcyhwYWdlLCAnJywgcGFnZSA9PT0gMSk7XG4gICAgICAgIGFsbENhcmRzID0gcGFnZSA9PT0gMSA/IGNhcmRzIDogWy4uLmFsbENhcmRzLCAuLi5jYXJkc107XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG1vcmUgcGFnZXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQUNLRU5EX0FQSV9CQVNFX1VSTH0vYXBpL2NhcmRzL2xpc3Q/cGFnZT0ke3BhZ2V9JnBlcl9wYWdlPTQwJnRlbXBsYXRlX21vZGU9dHJ1ZWApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBoYXNNb3JlID0gZGF0YS5wYWdpbmF0aW9uPy5oYXNfbmV4dCB8fCBmYWxzZTtcbiAgICAgICAgcGFnZSsrO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIExlZ2FjeSBwcmVsb2FkIGNvbXBsZXRlOicsIGFsbENhcmRzLmxlbmd0aCwgJ2NhcmRzJyk7XG4gICAgICBhd2FpdCBwcmVsb2FkSW1hZ2VzKGFsbENhcmRzLnNsaWNlKDAsIDIwKSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIExlZ2FjeSBwcmVsb2FkIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHByZWxvYWRJbWFnZXMgPSBhc3luYyAoY2FyZHM6IEdhbGxlcnlDYXJkW10pID0+IHtcbiAgICAvLyBEaXNhYmxlZCBmb3IgaW5zdGFudCBsb2FkaW5nIGxpa2UgcmVmZXJlbmNlIHNpdGVcbiAgICBjb25zb2xlLmxvZygn8J+agCBTa2lwcGluZyBpbWFnZSBwcmVsb2FkaW5nIGZvciBpbnN0YW50IHJlc3BvbnNlJyk7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIGNvbnN0IGdldENhY2hlZENhcmRzID0gdXNlQ2FsbGJhY2soKHBhZ2U6IG51bWJlciA9IDEsIGl0ZW1zUGVyUGFnZTogbnVtYmVyID0gNDApOiBHYWxsZXJ5Q2FyZFtdID0+IHtcbiAgICBpZiAoIWdsb2JhbENhY2hlKSByZXR1cm4gW107XG4gICAgXG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IChwYWdlIC0gMSkgKiBpdGVtc1BlclBhZ2U7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgaXRlbXNQZXJQYWdlO1xuICAgIHJldHVybiBnbG9iYWxDYWNoZS5jYXJkcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhckNhY2hlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGdsb2JhbENhY2hlID0gbnVsbDtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShDQUNIRV9LRVkpO1xuICAgIHNldENhY2hlKG51bGwpO1xuICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYWNoZSxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgbG9hZENhcmRzLFxuICAgIHByZWxvYWRBbGxDYXJkcyxcbiAgICBnZXRDYWNoZWRDYXJkcyxcbiAgICBjbGVhckNhY2hlLFxuICAgIGhhc0NhY2hlOiAhIWdsb2JhbENhY2hlLFxuICAgIGlzQ29tcGxldGU6IGdsb2JhbENhY2hlPy5pc0NvbXBsZXRlIHx8IGZhbHNlLFxuICAgIHRvdGFsQ2FyZHM6IGdsb2JhbENhY2hlPy50b3RhbENvdW50IHx8IDBcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJDQUNIRV9LRVkiLCJJTUFHRV9DQUNIRV9LRVkiLCJDQUNIRV9EVVJBVElPTiIsIklNQUdFX0NBQ0hFX0RVUkFUSU9OIiwiQkFDS0VORF9BUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9BUElfVVJMIiwiTUFYX0NPTkNVUlJFTlRfSU1BR0VTIiwiQ0FSRFNfTElTVF9VUkwiLCJnbG9iYWxDYWNoZSIsImlzUHJlbG9hZGluZyIsImNhY2hlTGlzdGVuZXJzIiwiU2V0Iiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwidXNlQ2FyZENhY2hlIiwiY2FjaGUiLCJzZXRDYWNoZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ1cGRhdGVDYWNoZSIsImFkZCIsImRlbGV0ZSIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJpc0V4cGlyZWQiLCJEYXRlIiwibm93IiwibGFzdEZldGNoZWQiLCJjb25zb2xlIiwibG9nIiwiY2FyZHMiLCJsZW5ndGgiLCJyZW1vdmVJdGVtIiwibG9hZENhcmRzIiwicGFnZSIsInNlYXJjaCIsInJlc2V0IiwiaXNDb21wbGV0ZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInNsaWNlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiZGF0YSIsImpzb24iLCJzdGF0dXMiLCJBcnJheSIsImlzQXJyYXkiLCJ0b3RhbENvdW50IiwicGFnaW5hdGlvbiIsInRvdGFsIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIndhcm4iLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwidGVtcGxhdGVfbW9kZSIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm5ld0NhcmRzIiwiaGFzX25leHQiLCJleGlzdGluZ0lkcyIsIm1hcCIsImNhcmQiLCJpZCIsInVuaXF1ZU5ld0NhcmRzIiwiZmlsdGVyIiwiaGFzIiwibWVzc2FnZSIsInByZWxvYWRBbGxDYXJkcyIsImNhY2hlQWdlIiwicHJlbG9hZEFsbENhcmRzTGVnYWN5IiwiaGFzTW9yZSIsImFsbENhcmRzIiwicHJlbG9hZEltYWdlcyIsImdldENhY2hlZENhcmRzIiwiaXRlbXNQZXJQYWdlIiwiY2xlYXJDYWNoZSIsImhhc0NhY2hlIiwidG90YWxDYXJkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardCache.ts\n"));

/***/ })

});
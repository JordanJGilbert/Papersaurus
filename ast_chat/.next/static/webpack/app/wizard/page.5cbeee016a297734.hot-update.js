"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/wizard/page",{

/***/ "(app-pages-browser)/./hooks/useCardStudio.ts":
/*!********************************!*\
  !*** ./hooks/useCardStudio.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardStudio: function() { return /* binding */ useCardStudio; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* __next_internal_client_entry_do_not_use__ useCardStudio auto */ \n\n\n// Configuration for the backend API endpoint\nconst BACKEND_API_BASE_URL = \"https://vibecarding.com\" || 0;\n// Helper function to format countdown as MM:SS\nconst formatCountdown = (seconds)=>{\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return \"\".concat(minutes, \":\").concat(remainingSeconds.toString().padStart(2, \"0\"));\n};\n// Helper function to format generation time\nconst formatGenerationTime = (durationSeconds)=>{\n    const minutes = Math.floor(durationSeconds / 60);\n    const seconds = Math.floor(durationSeconds % 60);\n    if (minutes > 0) {\n        return \"\".concat(minutes, \"m \").concat(seconds, \"s\");\n    }\n    return \"\".concat(seconds, \"s\");\n};\n// Email Helper Function\nasync function sendThankYouEmail(toEmail, cardType, cardUrl) {\n    if (!toEmail.trim()) return;\n    try {\n        // Create HTML email body\n        const htmlBody = '\\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;\">\\n        <div style=\"text-align: center; margin-bottom: 30px;\">\\n          <h1 style=\"color: #2563eb; margin-bottom: 10px;\">\\uD83C\\uDF89 Your Card is Ready!</h1>\\n        </div>\\n        \\n        <p style=\"font-size: 16px; line-height: 1.6; margin-bottom: 20px;\">Hi there!</p>\\n        \\n        <p style=\"font-size: 16px; line-height: 1.6; margin-bottom: 20px;\">\\n          Thank you for using VibeCarding to create your beautiful <strong>'.concat(cardType, '</strong> card!\\n        </p>\\n        \\n        <p style=\"font-size: 16px; line-height: 1.6; margin-bottom: 20px;\">\\n          We hope you love how it turned out. Your card has been generated and is ready for printing or sharing.\\n        </p>\\n        \\n        <div style=\"text-align: center; margin: 30px 0;\">\\n          <a href=\"').concat(cardUrl, '\" style=\"background-color: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;\">\\n            View Your Card\\n          </a>\\n        </div>\\n        \\n        <p style=\"font-size: 16px; line-height: 1.6; margin-bottom: 20px;\">\\n          If you have any questions or feedback, feel free to reach out to us.\\n        </p>\\n        \\n        <p style=\"font-size: 16px; line-height: 1.6; margin-bottom: 20px;\">\\n          Happy card making!\\n        </p>\\n        \\n        <div style=\"margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280;\">\\n          <p style=\"margin-bottom: 5px;\"><strong>Best regards,</strong></p>\\n          <p style=\"margin-bottom: 5px;\">The VibeCarding Team</p>\\n          <p style=\"margin: 0;\">\\n            <a href=\"mailto:vibecarding@ast.engineer\" style=\"color: #2563eb; text-decoration: none;\">vibecarding@ast.engineer</a>\\n          </p>\\n        </div>\\n      </div>\\n    ');\n        // Plain text fallback\n        const textBody = \"Hi there!\\n\\nThank you for using VibeCarding to create your beautiful \".concat(cardType, \" card!\\n\\nWe hope you love how it turned out. Your card has been generated and is ready for printing or sharing.\\n\\nView your card: \").concat(cardUrl, \"\\n\\nIf you have any questions or feedback, feel free to reach out to us.\\n\\nHappy card making!\\n\\nBest regards,\\nThe VibeCarding Team\\nvibecarding@ast.engineer\");\n        // Send to user\n        const userResponse = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/send_email_nodejs_style\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json; charset=utf-8\"\n            },\n            body: JSON.stringify({\n                to: toEmail,\n                from: \"vibecarding@ast.engineer\",\n                subject: \"Your \".concat(cardType, \" card is ready!\"),\n                body: htmlBody,\n                text: textBody,\n                html: htmlBody\n            })\n        });\n        // Send copy to jordan@ast.engineer\n        const adminResponse = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/send_email_nodejs_style\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                to: \"jordan@ast.engineer\",\n                from: \"vibecarding@ast.engineer\",\n                subject: \"Card Created - \".concat(cardType, \" for \").concat(toEmail),\n                body: '<div style=\"font-family: Arial, sans-serif; padding: 20px;\">\\n          <h3 style=\"color: #2563eb;\">New Card Created on VibeCarding</h3>\\n          <p><strong>User:</strong> '.concat(toEmail, \"</p>\\n          <p><strong>Card Type:</strong> \").concat(cardType, '</p>\\n          <p><strong>Card URL:</strong> <a href=\"').concat(cardUrl, '\">').concat(cardUrl, '</a></p>\\n          <p style=\"margin-top: 20px; color: #6b7280; font-size: 14px;\">\\n            This is an automated notification of card creation activity.\\n          </p>\\n        </div>'),\n                text: \"New card created on VibeCarding:\\n\\nUser: \".concat(toEmail, \"\\nCard Type: \").concat(cardType, \"\\nCard URL: \").concat(cardUrl, \"\\n\\nThis is an automated notification of card creation activity.\")\n            })\n        });\n        if (userResponse.ok) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"✉️ Thank you email sent!\");\n        }\n    } catch (error) {\n        console.error(\"Failed to send thank you email:\", error);\n    // Don't show error toast - this is a nice-to-have feature\n    }\n}\n// Chat Helper Function\nasync function chatWithAI(userMessage) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { systemPrompt = null, model = \"gemini-2.5-pro\", includeThoughts = false, jsonSchema = null, attachments = [] // Default to empty array\n     } = options;\n    try {\n        const response = await fetch(\"/internal/call_mcp_tool\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                tool_name: \"ai_chat\",\n                arguments: {\n                    messages: userMessage,\n                    system_prompt: systemPrompt,\n                    model: model,\n                    include_thoughts: includeThoughts,\n                    json_schema: jsonSchema,\n                    ...attachments.length > 0 && {\n                        attachments\n                    } // Only include if there are attachments\n                }\n            })\n        });\n        if (!response.ok) throw new Error(\"HTTP \".concat(response.status));\n        const data = await response.json();\n        if (data.error && data.error !== \"None\" && data.error !== null) {\n            throw new Error(data.error);\n        }\n        let result;\n        if (typeof data.result === \"string\") {\n            try {\n                result = JSON.parse(data.result);\n            } catch (e) {\n                result = {\n                    status: \"error\",\n                    message: \"Invalid JSON response\"\n                };\n            }\n        } else {\n            result = data.result;\n        }\n        if (result.status === \"error\") {\n            throw new Error(result.message);\n        }\n        return result.response;\n    } catch (error) {\n        console.error(\"AI chat failed:\", error);\n        throw error;\n    }\n}\n// Card tone/style options\nconst cardTones = [\n    {\n        id: \"funny\",\n        label: \"\\uD83D\\uDE04 Funny\",\n        description: \"Humorous and lighthearted\"\n    },\n    {\n        id: \"genz-humor\",\n        label: \"\\uD83D\\uDC80 GenZ Humor\",\n        description: \"Internet memes, chaotic energy, and unhinged vibes\"\n    },\n    {\n        id: \"romantic\",\n        label: \"\\uD83D\\uDC95 Romantic\",\n        description: \"Sweet and loving\"\n    },\n    {\n        id: \"professional\",\n        label: \"\\uD83D\\uDC54 Professional\",\n        description: \"Formal and business-appropriate\"\n    },\n    {\n        id: \"heartfelt\",\n        label: \"❤️ Heartfelt\",\n        description: \"Sincere and emotional\"\n    },\n    {\n        id: \"playful\",\n        label: \"\\uD83C\\uDF89 Playful\",\n        description: \"Fun and energetic\"\n    },\n    {\n        id: \"elegant\",\n        label: \"✨ Elegant\",\n        description: \"Sophisticated and refined\"\n    },\n    {\n        id: \"casual\",\n        label: \"\\uD83D\\uDE0A Casual\",\n        description: \"Relaxed and friendly\"\n    },\n    {\n        id: \"inspirational\",\n        label: \"\\uD83C\\uDF1F Inspirational\",\n        description: \"Motivating and uplifting\"\n    },\n    {\n        id: \"quirky\",\n        label: \"\\uD83E\\uDD2A Quirky\",\n        description: \"Unique and unconventional\"\n    },\n    {\n        id: \"traditional\",\n        label: \"\\uD83C\\uDFAD Traditional\",\n        description: \"Classic and timeless\"\n    }\n];\n// Curated artistic styles for beautiful cards\nconst artisticStyles = [\n    {\n        id: \"ai-smart-style\",\n        label: \"✨ Smart Style\",\n        description: \"Let our experts choose the perfect style for your card\",\n        promptModifier: \"\"\n    },\n    {\n        id: \"custom\",\n        label: \"✨ Custom Style\",\n        description: \"Define your own unique artistic style\",\n        promptModifier: \"\"\n    },\n    {\n        id: \"watercolor\",\n        label: \"\\uD83C\\uDFA8 Watercolor\",\n        description: \"Soft, flowing paint effects (our personal favorite)\",\n        promptModifier: \"in watercolor painting style, with soft flowing colors, artistic brush strokes, paper texture, and organic paint bleeds\"\n    },\n    {\n        id: \"minimalist\",\n        label: \"✨ Minimalist\",\n        description: \"Clean, simple, elegant design\",\n        promptModifier: \"in minimalist style with clean lines, simple shapes, plenty of white space, sophisticated typography, and elegant simplicity\"\n    },\n    {\n        id: \"botanical\",\n        label: \"\\uD83C\\uDF3F Botanical\",\n        description: \"Beautiful flowers and nature elements\",\n        promptModifier: \"in botanical illustration style with detailed flowers, leaves, and natural elements, soft organic shapes, elegant floral arrangements, and nature-inspired designs perfect for greeting cards\"\n    },\n    {\n        id: \"comic-book\",\n        label: \"\\uD83D\\uDCA5 Comic Book\",\n        description: \"Bold graphic novel style\",\n        promptModifier: \"in comic book art style with bold outlines, vibrant colors, dynamic poses, speech bubble aesthetics, halftone patterns, and superhero comic book visual elements that create an exciting and energetic feel\"\n    },\n    {\n        id: \"dreamy-fantasy\",\n        label: \"\\uD83C\\uDF38 Dreamy Fantasy\",\n        description: \"Enchanting anime-inspired art\",\n        promptModifier: \"in dreamy fantasy anime style, with soft pastels, magical atmosphere, detailed nature elements, whimsical characters, and enchanting fairy-tale qualities\"\n    },\n    {\n        id: \"art-deco\",\n        label: \"✨ Art Deco\",\n        description: \"Elegant 1920s geometric luxury\",\n        promptModifier: \"in vintage Art Deco style with geometric patterns, gold accents, elegant typography, luxurious details, and 1920s glamour\"\n    },\n    {\n        id: \"vintage-illustration\",\n        label: \"\\uD83D\\uDCDA Vintage Illustration\",\n        description: \"Classic storybook charm\",\n        promptModifier: \"in vintage illustration style like classic children's books, with warm nostalgic colors, charming characters, whimsical details, and timeless fairy-tale aesthetics\"\n    },\n    {\n        id: \"modern-geometric\",\n        label: \"\\uD83D\\uDD37 Modern Geometric\",\n        description: \"Clean contemporary shapes\",\n        promptModifier: \"in modern geometric style with clean shapes, contemporary design elements, balanced compositions, and sophisticated color palettes perfect for modern greeting cards\"\n    },\n    {\n        id: \"soft-pastel\",\n        label: \"\\uD83C\\uDF38 Soft Pastel\",\n        description: \"Gentle, soothing colors\",\n        promptModifier: \"in soft pastel style with gentle colors, dreamy atmosphere, delicate textures, and calming visual elements that create a peaceful and heartwarming feeling\"\n    },\n    {\n        id: \"retro-vintage\",\n        label: \"\\uD83D\\uDCFB Retro Vintage\",\n        description: \"Classic 1950s-60s nostalgia\",\n        promptModifier: \"in retro vintage style with 1950s-60s aesthetics, classic typography, warm nostalgic colors, and mid-century design elements\"\n    }\n];\n// Paper size options\nconst paperSizes = [\n    {\n        id: \"standard\",\n        label: \"5\\xd77 Card (Standard)\",\n        description: \"Standard 5\\xd77 greeting card (10\\xd77 print layout)\",\n        aspectRatio: \"9:16\",\n        dimensions: \"1024x1536\",\n        printWidth: \"10in\",\n        printHeight: \"7in\"\n    },\n    {\n        id: \"compact\",\n        label: \"4\\xd76 Card (Compact)\",\n        description: \"Compact 4\\xd76 greeting card (8\\xd76 print layout)\",\n        aspectRatio: \"2:3\",\n        dimensions: \"768x1152\",\n        printWidth: \"8in\",\n        printHeight: \"6in\"\n    },\n    {\n        id: \"a6\",\n        label: \"A6 Card (4\\xd76)\",\n        description: \"A6 paper size (8.3\\xd75.8 print layout)\",\n        aspectRatio: \"2:3\",\n        dimensions: \"768x1152\",\n        printWidth: \"8.3in\",\n        printHeight: \"5.8in\"\n    }\n];\nfunction useCardStudio() {\n    // All your existing state from page.tsx\n    const [prompt, setPrompt] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [finalCardMessage, setFinalCardMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [toField, setToField] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [fromField, setFromField] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [selectedType, setSelectedType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"birthday\");\n    const [customCardType, setCustomCardType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [selectedTone, setSelectedTone] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"funny\");\n    const [isGenerating, setIsGenerating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generatedCard, setGeneratedCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Multiple cards state\n    const [numberOfCards, setNumberOfCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [generatedCards, setGeneratedCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedCardIndex, setSelectedCardIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Writing assistant state\n    const [isGeneratingMessage, setIsGeneratingMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Advanced options state\n    const [showAdvanced, setShowAdvanced] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [selectedArtisticStyle, setSelectedArtisticStyle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"watercolor\");\n    const [customStyleDescription, setCustomStyleDescription] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [selectedImageModel, setSelectedImageModel] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"gpt-image-1\");\n    // Draft mode specific model selection\n    const [selectedDraftModel, setSelectedDraftModel] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"gpt-image-1\");\n    // Progress tracking state\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [countdown, setCountdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [countdownInterval, setCountdownInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isCardCompleted, setIsCardCompleted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Job tracking state\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Fast preview mode state\n    const [fastPreviewMode, setFastPreviewMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Draft mode state - generate 5 low-quality cards for selection\n    const [isDraftMode, setIsDraftMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draftCards, setDraftCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // Cards in completion order (left to right)\n    const [draftIndexMapping, setDraftIndexMapping] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // Maps display position to original draft index\n    const [selectedDraftIndex, setSelectedDraftIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1); // Display position index\n    const [isGeneratingFinalCard, setIsGeneratingFinalCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [previewingDraftIndex, setPreviewingDraftIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1); // Display position index\n    const [draftCompletionShown, setDraftCompletionShown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draftCompletionCount, setDraftCompletionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0); // Track actual completions\n    // Upload state\n    const [handwritingSample, setHandwritingSample] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [handwritingSampleUrl, setHandwritingSampleUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [referenceImages, setReferenceImages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [referenceImageUrls, setReferenceImageUrls] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [imageTransformation, setImageTransformation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Email state\n    const [userEmail, setUserEmail] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // Card ID for URL generation (generated once per card creation)\n    const [currentCardId, setCurrentCardId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // New options for handwritten messages and single-sided printing\n    const [isHandwrittenMessage, setIsHandwrittenMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isFrontBackOnly, setIsFrontBackOnly] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Paper size options\n    const [selectedPaperSize, setSelectedPaperSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"standard\");\n    // Loading states for each card section\n    const [sectionLoadingStates, setSectionLoadingStates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        frontCover: \"idle\",\n        backCover: \"idle\",\n        leftInterior: \"idle\",\n        rightInterior: \"idle\"\n    });\n    // Clean progress tracking\n    const [progressPercentage, setProgressPercentage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Track if initial load is complete\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Textarea expand state\n    const [isTextareaExpanded, setIsTextareaExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isMessageExpanded, setIsMessageExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Message version control and refinement\n    const [messageHistory, setMessageHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [currentMessageIndex, setCurrentMessageIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);\n    const [refinementPrompt, setRefinementPrompt] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isRefiningMessage, setIsRefiningMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [showRefinementBox, setShowRefinementBox] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Settings menu state\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Template selection state\n    const [showTemplateGallery, setShowTemplateGallery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [templateSearchQuery, setTemplateSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isSearchingTemplates, setIsSearchingTemplates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [aiFilteredCards, setAiFilteredCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchMode, setSearchMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"text\");\n    const [textFilteredCards, setTextFilteredCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [showPrompts, setShowPrompts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Print options state\n    const [printOption, setPrintOption] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"physical\");\n    // Print confirmation dialog state\n    const [showPrintConfirmation, setShowPrintConfirmation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Generation time tracking\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationStartTime, setGenerationStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentElapsedTime, setCurrentElapsedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [elapsedTimeInterval, setElapsedTimeInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Template customization state\n    const [showTemplateCustomization, setShowTemplateCustomization] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [selectedTemplate, setSelectedTemplate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [templateCustomizations, setTemplateCustomizations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        promptChanges: \"\",\n        messageChanges: \"\",\n        useReferenceImage: false,\n        referenceImageFile: null,\n        referenceImageUrls: [],\n        referenceImageTransformation: \"\"\n    });\n    // Job management functions\n    const saveJobToStorage = (jobId, jobData)=>{\n        try {\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify({\n                ...jobData,\n                id: jobId,\n                status: \"processing\",\n                createdAt: Date.now()\n            }));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            if (!pendingJobs.includes(jobId)) {\n                pendingJobs.push(jobId);\n                localStorage.setItem(\"pendingCardJobs\", JSON.stringify(pendingJobs));\n            }\n        } catch (error) {\n            console.error(\"Failed to save job to localStorage:\", error);\n        }\n    };\n    // Helper function to scroll to card preview\n    const scrollToCardPreview = ()=>{\n        setTimeout(()=>{\n            const cardPreviewElement = document.querySelector(\"[data-card-preview]\");\n            if (cardPreviewElement) {\n                cardPreviewElement.scrollIntoView({\n                    behavior: \"smooth\",\n                    block: \"start\"\n                });\n            }\n        }, 500);\n    };\n    // Start elapsed time tracking\n    const startElapsedTimeTracking = (startTime, estimatedTotalSeconds)=>{\n        const start = startTime || Date.now();\n        setGenerationStartTime(start);\n        localStorage.setItem(\"generation-start-time\", start.toString());\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n        }\n        const interval = setInterval(()=>{\n            const elapsed = (Date.now() - start) / 1000;\n            setCurrentElapsedTime(elapsed);\n            const estimatedTotal = estimatedTotalSeconds || (isDraftMode ? 45 : 150);\n            const percentage = Math.min(elapsed / estimatedTotal * 100, 95);\n            setProgressPercentage(percentage);\n        }, 1000);\n        setElapsedTimeInterval(interval);\n    };\n    // Stop elapsed time tracking\n    const stopElapsedTimeTracking = ()=>{\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n            setElapsedTimeInterval(null);\n        }\n        localStorage.removeItem(\"generation-start-time\");\n    };\n    // File upload handler\n    const handleFileUpload = async (file, type)=>{\n        if (!file.type.startsWith(\"image/\")) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please upload an image file\");\n            return;\n        }\n        setIsUploading(true);\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/upload\"), {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Upload failed: \".concat(response.status));\n            const result = await response.json();\n            if (type === \"handwriting\") {\n                setHandwritingSample(file);\n                setHandwritingSampleUrl(result.url);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Handwriting sample uploaded!\");\n            } else {\n                setReferenceImages((prev)=>[\n                        ...prev,\n                        file\n                    ]);\n                setReferenceImageUrls((prev)=>[\n                        ...prev,\n                        result.url\n                    ]);\n                console.log(\"\\uD83D\\uDD0D DEBUG: Reference image uploaded successfully:\", {\n                    fileName: file.name,\n                    url: result.url,\n                    totalImages: referenceImages.length + 1\n                });\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image uploaded! \".concat(referenceImages.length + 1, \" photo\").concat(referenceImages.length + 1 > 1 ? \"s\" : \"\", \" ready for character creation.\"));\n            }\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Upload failed. Please try again.\");\n        } finally{\n            setIsUploading(false);\n        }\n    };\n    const handleRemoveReferenceImage = (index)=>{\n        const removedImage = referenceImages[index];\n        const removedUrl = referenceImageUrls[index];\n        setReferenceImages((prev)=>prev.filter((_, i)=>i !== index));\n        setReferenceImageUrls((prev)=>prev.filter((_, i)=>i !== index));\n        console.log(\"\\uD83D\\uDD0D DEBUG: Reference image removed:\", {\n            fileName: removedImage === null || removedImage === void 0 ? void 0 : removedImage.name,\n            url: removedUrl,\n            remainingImages: referenceImages.length - 1\n        });\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image removed! \".concat(referenceImages.length - 1, \" photo\").concat(referenceImages.length - 1 !== 1 ? \"s\" : \"\", \" remaining.\"));\n    };\n    // Writing Assistant - full function implemented below\n    // Message version control functions\n    const addMessageToHistory = (message)=>{\n        if (message.trim() === \"\") return;\n        const cleanMessage = message.replace(/<\\/?MESSAGE>/g, \"\").trim();\n        if (cleanMessage === \"\") return;\n        const newHistory = messageHistory.slice(0, currentMessageIndex + 1);\n        newHistory.push(cleanMessage);\n        if (newHistory.length > 10) {\n            newHistory.shift();\n        } else {\n            setCurrentMessageIndex(currentMessageIndex + 1);\n        }\n        setMessageHistory(newHistory);\n        setCurrentMessageIndex(newHistory.length - 1);\n    };\n    const undoMessage = ()=>{\n        if (currentMessageIndex > 0) {\n            const newIndex = currentMessageIndex - 1;\n            setCurrentMessageIndex(newIndex);\n            setFinalCardMessage(messageHistory[newIndex]);\n        }\n    };\n    const redoMessage = ()=>{\n        if (currentMessageIndex < messageHistory.length - 1) {\n            const newIndex = currentMessageIndex + 1;\n            setCurrentMessageIndex(newIndex);\n            setFinalCardMessage(messageHistory[newIndex]);\n        }\n    };\n    // Full message generation function (from original page.tsx)\n    const handleGetMessageHelp = async ()=>{\n        // Validate custom card type if selected\n        if (selectedType === \"custom\" && !customCardType.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom card type first!\");\n            return;\n        }\n        setIsGeneratingMessage(true);\n        try {\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = cardTones.find((tone)=>tone.id === selectedTone);\n            const toneDescription = selectedToneObj ? selectedToneObj.description.toLowerCase() : \"heartfelt and sincere\";\n            // Use effective prompt logic here too\n            const effectivePrompt = prompt.trim() || \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(toneDescription, \" style\");\n            const messagePrompt = \"Create a \".concat(toneDescription, \" message for a \").concat(cardTypeForPrompt, ' greeting card.\\n\\nCard Theme/Description: \"').concat(effectivePrompt, '\"\\n').concat(toField ? \"Recipient: \".concat(toField) : \"Recipient: [not specified]\", \"\\n\").concat(fromField ? \"Sender: \".concat(fromField) : \"Sender: [not specified]\", \"\\nCard Tone: \").concat(selectedToneObj ? selectedToneObj.label : \"Heartfelt\", \" - \").concat(toneDescription, \"\\n\\nInstructions:\\n- Write a message that is \").concat(toneDescription, \" and feels personal and genuine\\n- \").concat(toField ? \"Address the message to \".concat(toField, \" directly, using their name naturally\") : \"Write in a way that could be personalized to any recipient\", \"\\n- \").concat(fromField ? \"Write as if \".concat(fromField, \" is personally writing this message\") : \"Write in a \".concat(toneDescription, \" tone\"), \"\\n- Match the \").concat(toneDescription, \" tone and occasion of the \").concat(cardTypeForPrompt, ' card type\\n- Be inspired by the theme: \"').concat(effectivePrompt, '\"\\n- Keep it concise but meaningful (2-4 sentences ideal)\\n- Make it feel authentic, not generic\\n- SAFETY: Never include brand names, character names, trademarked terms, or inappropriate content. If the theme references these, use generic alternatives or focus on the emotions/concepts instead\\n- Keep content family-friendly and appropriate for all ages\\n- ').concat(selectedTone === \"funny\" ? \"Include appropriate humor that fits the occasion\" : \"\", \"\\n- \").concat(selectedTone === \"genz-humor\" ? 'Use GenZ humor with internet slang, memes, and chaotic energy - think \"no cap\", \"periodt\", \"it\\'s giving...\", \"slay\", etc. Be unhinged but endearing' : \"\", \"\\n- \").concat(selectedTone === \"professional\" ? \"Keep it formal and business-appropriate\" : \"\", \"\\n- \").concat(selectedTone === \"romantic\" ? \"Include loving and romantic language\" : \"\", \"\\n- \").concat(selectedTone === \"playful\" ? \"Use fun and energetic language\" : \"\", \"\\n- \").concat(toField && fromField ? \"Show the relationship between \".concat(fromField, \" and \").concat(toField, \" through the \").concat(toneDescription, \" message tone\") : \"\", \"\\n- \").concat(fromField ? 'End the message with a signature line like \"Love, '.concat(fromField, '\" or \"- ').concat(fromField, '\" or similar, naturally integrated into the message.') : \"\", \"\\n\\nReturn ONLY the message text that should appear inside the card - no quotes, no explanations, no markdown formatting (no *bold*, _italics_, or other markdown), just the complete \").concat(toneDescription, \" message in plain text.\\n\\nIMPORTANT: Wrap your final message in <MESSAGE> </MESSAGE> tags. Everything outside these tags will be ignored.\");\n            const generatedMessage = await chatWithAI(messagePrompt, {\n                model: \"gemini-2.5-pro\",\n                includeThoughts: false // Don't include thinking content in message generation\n            });\n            if (generatedMessage === null || generatedMessage === void 0 ? void 0 : generatedMessage.trim()) {\n                // Extract message content between <MESSAGE> tags using regex\n                const messageMatch = generatedMessage.match(/<MESSAGE>([\\s\\S]*?)<\\/MESSAGE>/);\n                let extractedMessage = messageMatch ? messageMatch[1].trim() : generatedMessage.trim();\n                // Ensure no MESSAGE tags are included in the final message\n                extractedMessage = extractedMessage.replace(/<\\/?MESSAGE>/g, \"\").trim();\n                // Add current message to history if it exists and is different\n                if (finalCardMessage.trim() && finalCardMessage.trim() !== extractedMessage) {\n                    addMessageToHistory(finalCardMessage);\n                }\n                setFinalCardMessage(extractedMessage);\n                // Add the new message to history\n                addMessageToHistory(extractedMessage);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"✨ Personalized message created!\");\n            }\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate message. Please try again.\");\n        } finally{\n            setIsGeneratingMessage(false);\n        }\n    };\n    // Main card generation function\n    const handleGenerateCardAsync = async ()=>{\n        if (!userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter your email address\");\n            return;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(userEmail)) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter a valid email address\");\n            return;\n        }\n        // Validate custom style if selected\n        if (selectedArtisticStyle === \"custom\" && !customStyleDescription.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom artistic style\");\n            return;\n        }\n        // Validate reference images with model compatibility\n        if (referenceImageUrls.length > 0 && selectedImageModel !== \"gpt-image-1\") {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Reference photos are only supported with GPT Image 1 model. Please switch to GPT Image 1 in Advanced Options or remove reference photos.\");\n            return;\n        }\n        // Clear all draft mode states to prevent UI conflicts\n        setIsDraftMode(false);\n        setDraftCards([]);\n        setDraftIndexMapping([]);\n        setSelectedDraftIndex(-1);\n        setIsGeneratingFinalCard(false);\n        setPreviewingDraftIndex(-1);\n        setDraftCompletionShown(false);\n        // Clear any existing card states\n        setGeneratedCards([]);\n        setGeneratedCard(null);\n        setSelectedCardIndex(0);\n        setCurrentCardId(null);\n        setIsCardCompleted(false);\n        setIsGenerating(true);\n        startElapsedTimeTracking(undefined, 120);\n        setGenerationProgress(\"Creating your personalized card...\");\n        setProgressPercentage(0);\n        try {\n            // Create job tracking\n            const jobId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            setCurrentJobId(jobId);\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            let messageContent = finalCardMessage;\n            // Handle message generation if needed\n            if (isHandwrittenMessage) {\n                messageContent = \"[Blank space for handwritten message]\";\n            } else if (!messageContent.trim() && !isFrontBackOnly) {\n                setGenerationProgress(\"✍️ Writing the perfect message...\");\n                const autoMessagePrompt = \"Create a heartfelt message for a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nCard Theme/Description: \"').concat(prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"), '\"\\n').concat(toField ? \"Recipient: \".concat(toField) : \"Recipient: [not specified]\", \"\\n\").concat(fromField ? \"Sender: \".concat(fromField) : \"Sender: [not specified]\", \"\\n\\nInstructions:\\n- Write a message that feels personal and genuine\\n- Keep it concise but meaningful (2-4 sentences ideal)\\n- Make it feel authentic, not generic\\n- Keep content family-friendly and appropriate for all ages\\n- \").concat(fromField ? 'End the message with a signature line like \"Love, '.concat(fromField, '\" or \"- ').concat(fromField, '\" or similar, naturally integrated into the message.') : \"\", \"\\n\\nReturn ONLY the message text that should appear inside the card.\\n\\nIMPORTANT: Wrap your final message in <MESSAGE> </MESSAGE> tags.\");\n                const generatedMessage = await chatWithAI(autoMessagePrompt, {\n                    model: \"gemini-2.5-pro\",\n                    includeThoughts: false\n                });\n                if (generatedMessage === null || generatedMessage === void 0 ? void 0 : generatedMessage.trim()) {\n                    const messageMatch = generatedMessage.match(/<MESSAGE>([\\s\\S]*?)<\\/MESSAGE>/);\n                    if (messageMatch && messageMatch[1]) {\n                        messageContent = messageMatch[1].trim();\n                        setFinalCardMessage(messageContent);\n                    }\n                }\n            }\n            // Generate style and paper config\n            const selectedStyle = artisticStyles.find((style)=>style.id === selectedArtisticStyle);\n            const styleModifier = selectedArtisticStyle === \"custom\" ? customStyleDescription : (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n            const paperConfig = paperSizes.find((size)=>size.id === selectedPaperSize) || paperSizes[0];\n            setGenerationProgress(\"\\uD83C\\uDFA8 Creating artistic vision for your card...\");\n            // Generate prompts\n            const promptGenerationQuery = \"Create prompts for a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nTheme: \"').concat(prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"), '\"\\nStyle: ').concat((selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.label) || \"Default\", \"\\n\").concat(toField ? \"To: \".concat(toField) : \"\", \"\\n\").concat(fromField ? \"From: \".concat(fromField) : \"\", \"\\n\").concat(!isFrontBackOnly ? 'Message: \"'.concat(messageContent, '\"') : \"\", \"\\n\").concat(referenceImageUrls.length > 0 ? \"Reference Photos: \".concat(referenceImageUrls.length, \" photo(s) provided for character creation\") : \"\", \"\\n\\nRequirements:\\n- Flat 2D artwork for printing\\n- Full-bleed backgrounds extending to edges\\n- Keep text, faces, and key elements at least 10% away from top/bottom edges\\n- Family-friendly and appropriate for greeting cards\\n- Style: \").concat(styleModifier, '\\n\\nReturn JSON:\\n{\\n  \"frontCover\": \"detailed front cover prompt\",\\n  \"backCover\": \"detailed back cover prompt\"').concat(!isFrontBackOnly ? ',\\n  \"leftInterior\": \"detailed left interior prompt\",\\n  \"rightInterior\": \"detailed right interior prompt\"' : \"\", \"\\n}\");\n            const generatedPrompts = await chatWithAI(promptGenerationQuery, {\n                jsonSchema: {\n                    type: \"object\",\n                    properties: {\n                        frontCover: {\n                            type: \"string\"\n                        },\n                        backCover: {\n                            type: \"string\"\n                        },\n                        ...isFrontBackOnly ? {} : {\n                            leftInterior: {\n                                type: \"string\"\n                            },\n                            rightInterior: {\n                                type: \"string\"\n                            }\n                        }\n                    },\n                    required: [\n                        \"frontCover\",\n                        \"backCover\",\n                        ...isFrontBackOnly ? [] : [\n                            \"leftInterior\",\n                            \"rightInterior\"\n                        ]\n                    ]\n                },\n                model: \"gemini-2.5-pro\",\n                attachments: referenceImageUrls\n            });\n            if (!generatedPrompts || !generatedPrompts.frontCover) {\n                throw new Error(\"Failed to generate image prompts\");\n            }\n            // Save job data\n            const jobData = {\n                prompt: prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"),\n                selectedType,\n                customCardType,\n                selectedTone,\n                finalCardMessage: messageContent,\n                toField,\n                fromField,\n                userEmail,\n                selectedArtisticStyle,\n                customStyleDescription,\n                selectedImageModel,\n                isFrontBackOnly,\n                numberOfCards,\n                selectedPaperSize,\n                prompts: generatedPrompts,\n                paperConfig\n            };\n            saveJobToStorage(jobId, jobData);\n            setGenerationProgress(\"\\uD83D\\uDE80 Starting background generation...\");\n            // Prepare input images for reference photo support\n            const inputImages = [];\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-image-1\") {\n                inputImages.push(...referenceImageUrls);\n            }\n            const response = await fetch(\"/api/generate-card-async\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobId,\n                    prompts: generatedPrompts,\n                    config: {\n                        userNumber: \"+17145986105\",\n                        modelVersion: selectedImageModel,\n                        aspectRatio: paperConfig.aspectRatio,\n                        quality: \"high\",\n                        outputFormat: \"jpeg\",\n                        outputCompression: 100,\n                        moderation: \"low\",\n                        dimensions: paperConfig.dimensions,\n                        isFrontBackOnly,\n                        userEmail,\n                        cardType: cardTypeForPrompt,\n                        toField,\n                        fromField,\n                        isDraftMode: false,\n                        ...inputImages.length > 0 && {\n                            input_images: inputImages,\n                            input_images_mode: \"front_cover_only\"\n                        }\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.status !== \"processing\") {\n                throw new Error(result.message || \"Failed to start card generation\");\n            }\n            setGenerationProgress(\"✨ Bringing your vision to life...\");\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Card generation started!\");\n            // Start polling for completion (we'll add this function next)\n            pollJobStatus(jobId);\n        } catch (error) {\n            console.error(\"Card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate card. Please try again.\");\n            if (currentJobId) {\n                removeJobFromStorage(currentJobId);\n                setCurrentJobId(null);\n            }\n            setIsGenerating(false);\n            setGenerationProgress(\"\");\n            stopElapsedTimeTracking();\n        }\n    };\n    // Draft mode generation - creates 5 front cover variations\n    const handleGenerateDraftCards = async ()=>{\n        if (!userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter your email address\");\n            return;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(userEmail)) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter a valid email address\");\n            return;\n        }\n        // Validate custom style if selected\n        if (selectedArtisticStyle === \"custom\" && !customStyleDescription.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom artistic style\");\n            return;\n        }\n        // Validate reference images with model compatibility\n        if (referenceImageUrls.length > 0 && selectedDraftModel !== \"gpt-image-1\") {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Reference photos are only supported with GPT Image 1 model. Please switch to GPT Image 1 for draft mode or remove reference photos.\");\n            return;\n        }\n        setIsDraftMode(true);\n        setIsGenerating(true);\n        startElapsedTimeTracking(undefined, 45); // 45 seconds for draft mode\n        setGenerationProgress(\"\\uD83C\\uDFA8 Creating 5 front cover variations for you to choose from...\");\n        setProgressPercentage(0);\n        setDraftCards([]);\n        setDraftIndexMapping([]);\n        setSelectedDraftIndex(-1);\n        setDraftCompletionShown(false);\n        // Clear any previous card state to avoid UI conflicts\n        setGeneratedCard(null);\n        setGeneratedCards([]);\n        setIsCardCompleted(false);\n        try {\n            console.log(\"\\uD83D\\uDE80 Starting draft mode generation with 5 variations\");\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = cardTones.find((tone)=>tone.id === selectedTone);\n            const toneDescription = selectedToneObj ? selectedToneObj.description.toLowerCase() : \"heartfelt and sincere\";\n            const effectivePrompt = prompt.trim() || \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(toneDescription, \" style\");\n            // Show specific message for GPT-1 users about quality enforcement\n            if (selectedDraftModel === \"gpt-image-1\") {\n                const styleMessage = selectedArtisticStyle === \"ai-smart-style\" ? \" across 5 curated artistic styles!\" : \" (using low quality for fast previews)!\";\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 Generating 5 front cover variations with GPT-1\".concat(styleMessage));\n            } else {\n                const styleMessage = selectedArtisticStyle === \"ai-smart-style\" ? \" across 5 curated artistic styles!\" : \" for you to choose from!\";\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 Generating 5 front cover variations\".concat(styleMessage));\n            }\n            // Generate 5 draft variations with smart style distribution\n            const draftPromises = Array.from({\n                length: 5\n            }, async (_, index)=>{\n                try {\n                    var _paperSizes_find, _paperSizes_find1;\n                    console.log(\"\\uD83C\\uDFA8 Starting draft variation \".concat(index + 1));\n                    // For smart style, use predefined styles for all 5 variations\n                    let styleOverride = undefined;\n                    let styleLabel = undefined;\n                    if (selectedArtisticStyle === \"ai-smart-style\") {\n                        const predefinedStyles = [\n                            \"watercolor\",\n                            \"botanical\",\n                            \"comic-book\",\n                            \"dreamy-fantasy\",\n                            \"minimalist\"\n                        ];\n                        const styleLabels = [\n                            \"\\uD83C\\uDFA8 Watercolor\",\n                            \"\\uD83C\\uDF3F Botanical\",\n                            \"\\uD83D\\uDCA5 Comic Book\",\n                            \"\\uD83C\\uDF38 Dreamy Fantasy\",\n                            \"✨ Minimalist\"\n                        ];\n                        styleOverride = predefinedStyles[index];\n                        styleLabel = styleLabels[index];\n                        console.log(\"\\uD83C\\uDFA8 Draft \".concat(index + 1, ': Using predefined style \"').concat(styleOverride, '\" (').concat(styleLabel, \")\"));\n                    }\n                    // Generate front cover prompt for this variation\n                    const selectedStyle = artisticStyles.find((style)=>style.id === (styleOverride || selectedArtisticStyle));\n                    const styleModifier = styleOverride && styleOverride === \"custom\" ? customStyleDescription : (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n                    const frontCoverPromptQuery = \"You are an expert AI greeting card designer. Create a front cover prompt for a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nTheme: \"').concat(effectivePrompt, '\"\\nStyle: ').concat((selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.label) || \"Default\", \"\\nTone: \").concat(selectedToneObj ? selectedToneObj.label : \"Heartfelt\", \" - \").concat(toneDescription, \"\\n\").concat(toField ? \"To: \".concat(toField) : \"\", \"\\n\").concat(fromField ? \"From: \".concat(fromField) : \"\", \"\\n\").concat(referenceImageUrls.length > 0 ? \"Reference Photos: I have attached \".concat(referenceImageUrls.length, \" reference photo\").concat(referenceImageUrls.length > 1 ? \"s\" : \"\", \" for character creation.\") : \"\", '\\n\\nFront Cover Requirements:\\n- Include \"').concat(cardTypeForPrompt, '\" greeting text positioned safely in center area (avoid top/bottom 10%)\\n- Use beautiful, readable handwritten cursive script\\n- ').concat(referenceImageUrls.length > 0 ? \"Create cartoon/illustrated characters from reference photos\" : \"Create charming cartoon-style figures if needed\", \"\\n- Be creative and unique, avoid generic designs\\n- Flat 2D artwork for printing\\n- Style: \").concat(styleModifier, \"\\n\\nReturn ONLY the front cover prompt as plain text.\");\n                    const frontCoverPrompt = await chatWithAI(frontCoverPromptQuery, {\n                        model: \"gemini-2.5-pro\",\n                        attachments: referenceImageUrls\n                    });\n                    if (!(frontCoverPrompt === null || frontCoverPrompt === void 0 ? void 0 : frontCoverPrompt.trim())) {\n                        throw new Error(\"Failed to generate front cover prompt\");\n                    }\n                    // Enhance with reference image instructions if available\n                    let enhancedFrontCoverPrompt = frontCoverPrompt.trim();\n                    if (referenceImageUrls.length > 0 && selectedDraftModel === \"gpt-image-1\") {\n                        enhancedFrontCoverPrompt += \"\\n\\nCRITICAL CHARACTER REFERENCE INSTRUCTIONS: I have provided \".concat(referenceImageUrls.length > 1 ? \"multiple reference photos\" : \"a reference photo\", \" as input image\").concat(referenceImageUrls.length > 1 ? \"s\" : \"\", \". You MUST create cartoon/illustrated characters that accurately represent ONLY the people who are actually visible in \").concat(referenceImageUrls.length > 1 ? \"these reference photos\" : \"this reference photo\", \" with high fidelity to their appearance.\");\n                    }\n                    // Generate the image\n                    const jobId = \"draft-\".concat(index, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n                    const inputImages = [];\n                    if (referenceImageUrls.length > 0 && selectedDraftModel === \"gpt-image-1\") {\n                        inputImages.push(...referenceImageUrls);\n                    }\n                    const response = await fetch(\"/api/generate-card-async\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            jobId,\n                            prompts: {\n                                frontCover: enhancedFrontCoverPrompt\n                            },\n                            config: {\n                                userNumber: \"+17145986105\",\n                                modelVersion: selectedDraftModel,\n                                aspectRatio: ((_paperSizes_find = paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find === void 0 ? void 0 : _paperSizes_find.aspectRatio) || \"9:16\",\n                                quality: \"low\",\n                                outputFormat: \"jpeg\",\n                                outputCompression: 100,\n                                moderation: \"low\",\n                                dimensions: ((_paperSizes_find1 = paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find1 === void 0 ? void 0 : _paperSizes_find1.dimensions) || \"1024x1536\",\n                                isFrontBackOnly: true,\n                                userEmail,\n                                cardType: cardTypeForPrompt,\n                                toField,\n                                fromField,\n                                isDraftMode: true,\n                                ...inputImages.length > 0 && {\n                                    input_images: inputImages,\n                                    input_images_mode: \"front_cover_only\"\n                                }\n                            }\n                        })\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Server error: \".concat(response.status));\n                    }\n                    const result = await response.json();\n                    if (result.status !== \"processing\") {\n                        throw new Error(result.message || \"Failed to start draft generation\");\n                    }\n                    console.log(\"✅ Draft variation \".concat(index + 1, \" job started:\"), jobId);\n                    // Store the job with style info for later\n                    saveJobToStorage(jobId, {\n                        isDraft: true,\n                        draftIndex: index,\n                        styleInfo: styleOverride ? {\n                            styleName: styleOverride,\n                            styleLabel: styleLabel\n                        } : undefined,\n                        frontCoverPrompt: enhancedFrontCoverPrompt\n                    });\n                    // Start polling for this specific draft job\n                    console.log(\"\\uD83D\\uDD04 Starting polling for draft job \".concat(jobId));\n                    pollJobStatus(jobId);\n                } catch (error) {\n                    console.error(\"❌ Draft variation \".concat(index + 1, \" failed:\"), error);\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Draft variation \".concat(index + 1, \" failed: \").concat(error instanceof Error ? error.message : \"Unknown error\"));\n                }\n            });\n            // Wait for all draft generations to start (but not complete)\n            await Promise.allSettled(draftPromises);\n            console.log(\"\\uD83D\\uDE80 All draft variations started\");\n        } catch (error) {\n            console.error(\"Draft card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to start draft generation: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n            setIsGenerating(false);\n            setIsDraftMode(false);\n            setDraftCompletionShown(false);\n            setGenerationProgress(\"\");\n            stopElapsedTimeTracking();\n        }\n    };\n    // Check job status\n    const checkJobStatus = async (jobId)=>{\n        try {\n            const response = await fetch(\"/api/job-status/\".concat(jobId));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Failed to check job status:\", error);\n            return null;\n        }\n    };\n    // Poll job status with exponential backoff\n    const pollJobStatus = async function(jobId) {\n        let attempt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        try {\n            const statusResponse = await checkJobStatus(jobId);\n            // Check if this is a draft job\n            const isDraftJob = jobId.startsWith(\"draft-\");\n            const draftIndex = isDraftJob ? parseInt(jobId.split(\"-\")[1]) : -1;\n            if (statusResponse && statusResponse.status === \"completed\") {\n                console.log(\"\\uD83C\\uDF89 Job completed! Card data:\", statusResponse.cardData, \"isDraftJob:\", isDraftJob);\n                if (statusResponse.cardData) {\n                    if (isDraftJob && draftIndex >= 0) {\n                        var _statusResponse_cardData_generatedPrompts;\n                        // Handle draft card completion - no QR code needed for drafts\n                        console.log(\"\\uD83C\\uDFA8 Draft variation \".concat(draftIndex + 1, \" completed!\"));\n                        // Get style info for smart style mode\n                        let styleInfo = undefined;\n                        if (selectedArtisticStyle === \"ai-smart-style\") {\n                            const predefinedStyles = [\n                                \"watercolor\",\n                                \"botanical\",\n                                \"comic-book\",\n                                \"dreamy-fantasy\",\n                                \"minimalist\"\n                            ];\n                            const styleLabels = [\n                                \"\\uD83C\\uDFA8 Watercolor\",\n                                \"\\uD83C\\uDF3F Botanical\",\n                                \"\\uD83D\\uDCA5 Comic Book\",\n                                \"\\uD83C\\uDF38 Dreamy Fantasy\",\n                                \"✨ Minimalist\"\n                            ];\n                            if (draftIndex >= 0 && draftIndex < predefinedStyles.length) {\n                                styleInfo = {\n                                    styleName: predefinedStyles[draftIndex],\n                                    styleLabel: styleLabels[draftIndex]\n                                };\n                            }\n                        }\n                        const draftCard = {\n                            id: \"draft-\".concat(draftIndex + 1, \"-\").concat(Date.now()),\n                            prompt: statusResponse.cardData.prompt || \"Draft Variation \".concat(draftIndex + 1),\n                            frontCover: statusResponse.cardData.frontCover || \"\",\n                            backCover: \"\",\n                            leftPage: \"\",\n                            rightPage: \"\",\n                            createdAt: new Date(),\n                            generatedPrompts: {\n                                frontCover: ((_statusResponse_cardData_generatedPrompts = statusResponse.cardData.generatedPrompts) === null || _statusResponse_cardData_generatedPrompts === void 0 ? void 0 : _statusResponse_cardData_generatedPrompts.frontCover) || \"\"\n                            },\n                            styleInfo: styleInfo\n                        };\n                        // Update draft cards state - populate from left to right as they complete\n                        setDraftCards((prev)=>{\n                            const updated = [\n                                ...prev\n                            ];\n                            updated.push(draftCard); // Add to next available position (left to right)\n                            return updated;\n                        });\n                        // Update mapping to track which display position corresponds to which original draft index\n                        setDraftIndexMapping((prev)=>{\n                            const updatedMapping = [\n                                ...prev\n                            ];\n                            updatedMapping.push(draftIndex); // Map new display position to original draft index\n                            return updatedMapping;\n                        });\n                        // Update progress and check completion\n                        const newCompletedCount = draftCards.length + 1; // +1 because state update is async\n                        console.log(\"\\uD83D\\uDCCA Draft progress: \".concat(newCompletedCount, \"/5 front cover variations complete\"));\n                        // Scroll to draft preview when first card appears\n                        if (newCompletedCount === 1) {\n                            scrollToCardPreview();\n                        }\n                        if (newCompletedCount === 5) {\n                            setIsGenerating(false);\n                            setGenerationProgress(\"\");\n                            setProgressPercentage(100);\n                            stopElapsedTimeTracking();\n                            // Only show completion toast once using a flag, and only if user hasn't moved to final generation\n                            setDraftCompletionShown((prev)=>{\n                                if (!prev && !isGeneratingFinalCard) {\n                                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 All 5 front cover variations ready! Choose your favorite below.\");\n                                    return true;\n                                }\n                                return prev;\n                            });\n                        } else {\n                            setGenerationProgress(\"✨ \".concat(newCompletedCount, \"/5 front cover variations complete... \").concat(newCompletedCount >= 2 ? \"You can select one now to proceed!\" : \"\"));\n                            setProgressPercentage(newCompletedCount / 5 * 100);\n                        }\n                        removeJobFromStorage(jobId);\n                    } else {\n                        // Handle final card completion - apply QR code and full processing\n                        let cardWithQR = {\n                            ...statusResponse.cardData\n                        };\n                        // Ensure the card has a valid createdAt date\n                        if (!cardWithQR.createdAt) {\n                            cardWithQR.createdAt = new Date();\n                        } else if (typeof cardWithQR.createdAt === \"string\" || typeof cardWithQR.createdAt === \"number\") {\n                            cardWithQR.createdAt = new Date(cardWithQR.createdAt);\n                        }\n                        // Ensure the card has a valid ID\n                        if (!cardWithQR.id) {\n                            cardWithQR.id = \"card-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n                        }\n                        console.log(\"\\uD83D\\uDD04 Final card data prepared:\", cardWithQR);\n                        try {\n                            setGenerationProgress(\"✨ Adding interactive QR code to your card...\");\n                            console.log(\"\\uD83D\\uDD04 Starting QR overlay process for final card\");\n                            // Store card data first to get a shareable URL\n                            if (cardWithQR.frontCover) {\n                                try {\n                                    const cardStoreResponse = await fetch(\"/api/cards/store\", {\n                                        method: \"POST\",\n                                        headers: {\n                                            \"Content-Type\": \"application/json\"\n                                        },\n                                        body: JSON.stringify({\n                                            prompt: cardWithQR.prompt || \"\",\n                                            frontCover: cardWithQR.frontCover || \"\",\n                                            backCover: cardWithQR.backCover || \"\",\n                                            leftPage: cardWithQR.leftPage || \"\",\n                                            rightPage: cardWithQR.rightPage || \"\",\n                                            generatedPrompts: cardWithQR.generatedPrompts || null\n                                        })\n                                    });\n                                    if (cardStoreResponse.ok) {\n                                        const cardStoreData = await cardStoreResponse.json();\n                                        const actualShareUrl = cardStoreData.share_url;\n                                        console.log(\"Using actual share URL for QR code:\", actualShareUrl);\n                                        // Apply QR code to back cover using the API-returned URL\n                                        if (cardWithQR.backCover && actualShareUrl) {\n                                            console.log(\"\\uD83D\\uDD04 Applying QR overlay to final card...\");\n                                            const originalBackCover = cardWithQR.backCover;\n                                            // cardWithQR.backCover = await overlayQRCodeOnImage(originalBackCover, actualShareUrl);\n                                            cardWithQR.shareUrl = actualShareUrl;\n                                            console.log(\"✅ QR overlay complete for final card\");\n                                        }\n                                    } else {\n                                        console.warn(\"Failed to store card for sharing, continuing without QR code\");\n                                    }\n                                } catch (error) {\n                                    console.error(\"❌ Failed to store card or overlay QR code:\", error);\n                                // Continue without QR code if there's an error\n                                }\n                            } else {\n                                console.warn(\"No front cover found, skipping QR code process\");\n                            }\n                        } catch (error) {\n                            console.error(\"❌ Error in QR code process:\", error);\n                        // Continue without QR code if there's an error\n                        }\n                        console.log(\"\\uD83C\\uDFAF Setting final card state:\", cardWithQR);\n                        // Set the card states - this is critical!\n                        setGeneratedCard(cardWithQR);\n                        setGeneratedCards([\n                            cardWithQR\n                        ]);\n                        setSelectedCardIndex(0);\n                        setIsCardCompleted(true);\n                        setIsGenerating(false);\n                        setIsGeneratingFinalCard(false);\n                        setIsDraftMode(false);\n                        setDraftCompletionShown(false);\n                        setGenerationProgress(\"\");\n                        // Scroll to card preview\n                        scrollToCardPreview();\n                        // Capture generation time from backend\n                        if (statusResponse.cardData.generationTimeSeconds) {\n                            setGenerationDuration(statusResponse.cardData.generationTimeSeconds);\n                        }\n                        // Stop elapsed time tracking\n                        stopElapsedTimeTracking();\n                        // Set progress to 100%\n                        setProgressPercentage(100);\n                        setGenerationProgress(\"Card generation complete!\");\n                        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Your card is ready!\");\n                        // Send thank you email\n                        if (userEmail.trim()) {\n                            const cardTypeForEmail = selectedType === \"custom\" ? customCardType : selectedType;\n                            sendThankYouEmail(userEmail, cardTypeForEmail, cardWithQR.shareUrl || \"https://vibecarding.com\");\n                        }\n                        console.log(\"✅ Final card completion process finished successfully\");\n                        removeJobFromStorage(jobId);\n                        setCurrentJobId(null);\n                    }\n                } else {\n                    console.error(\"❌ No card data in completed response\");\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"❌ Card generation completed but no data received. Please try again.\");\n                    removeJobFromStorage(jobId);\n                    if (!isDraftJob) {\n                        setCurrentJobId(null);\n                    }\n                }\n            } else if (statusResponse && statusResponse.status === \"failed\") {\n                console.error(\"❌ Job failed:\", statusResponse);\n                if (isDraftJob && draftIndex >= 0) {\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Draft variation \".concat(draftIndex + 1, \" failed. Continuing with others...\"));\n                } else {\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"❌ Card generation failed. Please try again.\");\n                    setIsGenerating(false);\n                    setIsGeneratingFinalCard(false);\n                    stopElapsedTimeTracking();\n                    setGenerationProgress(\"\");\n                    setProgressPercentage(0);\n                    setCurrentJobId(null);\n                }\n                removeJobFromStorage(jobId);\n            } else if (statusResponse && statusResponse.status === \"processing\") {\n                // Continue polling every 3 seconds - near real-time updates for better UX\n                console.log(\"\\uD83D\\uDD04 Job still processing (attempt \".concat(attempt, \"), polling again...\"));\n                setTimeout(()=>pollJobStatus(jobId, attempt + 1), 3000);\n            } else {\n                console.warn(\"⚠️ Unexpected status response:\", statusResponse);\n                // Continue polling in case it's a temporary issue\n                setTimeout(()=>pollJobStatus(jobId, attempt + 1), 5000);\n            }\n        } catch (error) {\n            console.error(\"Failed to poll job status:\", error);\n            // Retry after delay with exponential backoff\n            const delay = Math.min(10000, 3000 * Math.pow(1.5, Math.min(attempt - 1, 5)));\n            setTimeout(()=>pollJobStatus(jobId, attempt + 1), delay);\n        }\n    };\n    // Remove job from storage\n    const removeJobFromStorage = (jobId)=>{\n        try {\n            localStorage.removeItem(\"cardJob_\".concat(jobId));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const updatedJobs = pendingJobs.filter((id)=>id !== jobId);\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(updatedJobs));\n        } catch (error) {\n            console.error(\"Failed to remove job from localStorage:\", error);\n        }\n    };\n    // Generate final high-quality card from selected draft\n    const handleGenerateFinalFromDraft = async (displayIndex)=>{\n        if (displayIndex < 0 || displayIndex >= draftCards.length || !draftCards[displayIndex]) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Invalid draft selection\");\n            return;\n        }\n        // Get the original draft index from the mapping\n        const originalDraftIndex = draftIndexMapping[displayIndex];\n        if (originalDraftIndex === undefined) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Could not find original draft data\");\n            return;\n        }\n        // Stop remaining draft generations to focus on the selected design\n        const remainingDrafts = 5 - draftCards.length;\n        if (remainingDrafts > 0 && isGenerating) {\n            setIsGenerating(false); // Stop the draft generation process\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"\\uD83C\\uDFAF Focusing on your selected design! Skipping \".concat(remainingDrafts, \" remaining variations.\"));\n        }\n        setIsGeneratingFinalCard(true);\n        setSelectedDraftIndex(displayIndex); // Store display index for UI\n        startElapsedTimeTracking(undefined, 120); // 120 seconds for final card generation\n        setGenerationProgress(\"\\uD83C\\uDFA8 Creating high-quality version of your selected design...\");\n        try {\n            var _selectedDraft_generatedPrompts, _paperSizes_find, _paperSizes_find1;\n            const selectedDraft = draftCards[displayIndex];\n            const jobId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            // Generate the missing prompts using the stored frontCover prompt + user info\n            console.log(\"\\uD83D\\uDD04 Generating complete prompts from stored front cover prompt + user info\");\n            // The draft should have at least the frontCover prompt\n            const storedFrontCoverPrompt = (_selectedDraft_generatedPrompts = selectedDraft.generatedPrompts) === null || _selectedDraft_generatedPrompts === void 0 ? void 0 : _selectedDraft_generatedPrompts.frontCover;\n            if (!storedFrontCoverPrompt) {\n                throw new Error(\"Selected draft is missing frontCover prompt\");\n            }\n            console.log(\"✅ Found stored front cover prompt:\", storedFrontCoverPrompt.substring(0, 100) + \"...\");\n            // Now generate the missing 3 prompts using the front cover context + user info\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = cardTones.find((tone)=>tone.id === selectedTone);\n            const toneDescription = selectedToneObj ? selectedToneObj.description.toLowerCase() : \"heartfelt and sincere\";\n            const effectivePrompt = prompt.trim() || \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(toneDescription, \" style\");\n            let messageContent = finalCardMessage;\n            if (isHandwrittenMessage) {\n                messageContent = \"[Blank space for handwritten message]\";\n            }\n            // Get style from the selected draft or fall back to current setting  \n            const draftStyleInfo = selectedDraft.styleInfo;\n            let styleModifier = \"\";\n            if (draftStyleInfo && draftStyleInfo.styleName) {\n                const selectedStyle = artisticStyles.find((style)=>style.id === draftStyleInfo.styleName);\n                styleModifier = (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n            } else {\n                const selectedStyle = artisticStyles.find((style)=>style.id === selectedArtisticStyle);\n                styleModifier = selectedArtisticStyle === \"custom\" ? customStyleDescription : (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n            }\n            const generateOtherPromptsQuery = 'You are creating the remaining prompts for a greeting card. You already have the front cover prompt below.\\n\\nEXISTING FRONT COVER PROMPT:\\n\"'.concat(storedFrontCoverPrompt, '\"\\n\\nCARD CONTEXT:\\n- Type: ').concat(cardTypeForPrompt, '\\n- Theme: \"').concat(effectivePrompt, '\"  \\n- Tone: ').concat(toneDescription, \"\\n\").concat(toField ? \"- To: \".concat(toField) : \"\", \"\\n\").concat(fromField ? \"- From: \".concat(fromField) : \"\", \"\\n\").concat(!isFrontBackOnly ? '- Message: \"'.concat(messageContent, '\"') : \"\", \"\\n\").concat(isHandwrittenMessage ? \"- Note: Include space for handwritten message\" : \"\", \"\\n\\nTASK: Create prompts for the remaining card sections that are visually cohesive with the existing front cover. Use the same color palette, artistic style, lighting, and visual elements from the front cover to create a unified design.\\n\\nRequirements:\\n- Maintain visual continuity with the front cover design\\n- Use the same artistic style: \").concat(styleModifier, '\\n- Keep consistent color palette, lighting, and mood\\n- Full-bleed backgrounds extending to edges\\n- Keep text/faces 0.5\" from left/right edges for safe printing\\n- IMPORTANT: Keep text, faces, and key elements at least 10% away from top/bottom edges\\n\\nGenerate prompts for:\\n\\n1. Back Cover: Create a simple, peaceful design that complements the front cover. Reference subtle elements from the front cover but keep it minimal and serene. NO PEOPLE, just beautiful artistic elements. IMPORTANT: Leave the bottom-right corner area (approximately 1 inch square) completely clear and undecorated for QR code placement.\\n\\n').concat(!isFrontBackOnly ? \"2. Left Interior: Creative decorative art that harmonizes with the front cover style. NO PEOPLE or characters, focus on artistic elements like patterns, landscapes, objects, or abstract art that matches the front cover's mood and style.\\n\\n3. Right Interior: \".concat(isHandwrittenMessage ? \"Design elegant writing space with decorative elements that complement the front cover style. Position decorative elements safely away from edges. NO PEOPLE or characters.\" : 'Include message text: \"'.concat(messageContent, '\" in beautiful handwritten cursive script, integrated into decorative artwork that matches the front cover style. NO PEOPLE or characters.')) : \"\", '\\n\\nReturn JSON:\\n{\\n  \"frontCover\": \"').concat(storedFrontCoverPrompt, '\",\\n  \"backCover\": \"detailed back cover prompt\"').concat(!isFrontBackOnly ? ',\\n  \"leftInterior\": \"detailed left interior prompt\",\\n  \"rightInterior\": \"detailed right interior prompt\"' : \"\", \"\\n}\");\n            const finalPrompts = await chatWithAI(generateOtherPromptsQuery, {\n                jsonSchema: {\n                    type: \"object\",\n                    properties: {\n                        frontCover: {\n                            type: \"string\"\n                        },\n                        backCover: {\n                            type: \"string\"\n                        },\n                        ...isFrontBackOnly ? {} : {\n                            leftInterior: {\n                                type: \"string\"\n                            },\n                            rightInterior: {\n                                type: \"string\"\n                            }\n                        }\n                    },\n                    required: [\n                        \"frontCover\",\n                        \"backCover\",\n                        ...isFrontBackOnly ? [] : [\n                            \"leftInterior\",\n                            \"rightInterior\"\n                        ]\n                    ]\n                },\n                model: \"gemini-2.5-pro\"\n            });\n            if (!finalPrompts || !finalPrompts.frontCover || !finalPrompts.backCover) {\n                throw new Error(\"Failed to generate complete prompts for final card\");\n            }\n            console.log(\"✅ Generated complete prompts for final card:\", {\n                hasFrontCover: !!finalPrompts.frontCover,\n                hasBackCover: !!finalPrompts.backCover,\n                hasLeftInterior: !!finalPrompts.leftInterior,\n                hasRightInterior: !!finalPrompts.rightInterior\n            });\n            // Prepare input images for final generation (reference photos)\n            const inputImages = [];\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-image-1\") {\n                inputImages.push(...referenceImageUrls);\n                console.log(\"\\uD83D\\uDD0D DEBUG: Added reference images to final draft generation:\", referenceImageUrls);\n                console.log(\"\\uD83D\\uDD0D DEBUG: Total input images for final draft generation:\", inputImages.length);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83D\\uDCF8 \".concat(referenceImageUrls.length, \" reference photo\").concat(referenceImageUrls.length > 1 ? \"s\" : \"\", \" applied to final generation!\"));\n            }\n            const response = await fetch(\"/api/generate-card-async\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobId,\n                    prompts: finalPrompts,\n                    config: {\n                        userNumber: \"+17145986105\",\n                        modelVersion: selectedImageModel,\n                        aspectRatio: ((_paperSizes_find = paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find === void 0 ? void 0 : _paperSizes_find.aspectRatio) || \"9:16\",\n                        quality: \"high\",\n                        outputFormat: \"jpeg\",\n                        outputCompression: 100,\n                        moderation: \"low\",\n                        dimensions: ((_paperSizes_find1 = paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find1 === void 0 ? void 0 : _paperSizes_find1.dimensions) || \"1024x1536\",\n                        isFrontBackOnly,\n                        userEmail,\n                        cardType: selectedType === \"custom\" ? customCardType : selectedType,\n                        toField,\n                        fromField,\n                        isDraftMode: false,\n                        ...inputImages.length > 0 && {\n                            input_images: inputImages,\n                            input_images_mode: \"front_cover_only\" // All reference images should go to front cover for character creation\n                        }\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.status !== \"processing\") {\n                throw new Error(result.message || \"Failed to start final card generation\");\n            }\n            setCurrentJobId(jobId);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 Generating high-quality version of your selected design!\");\n            // Poll for completion (reuse existing pollJobStatus)\n            pollJobStatus(jobId);\n        } catch (error) {\n            console.error(\"Final card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate final card. Please try again.\");\n            setIsGeneratingFinalCard(false);\n            setGenerationProgress(\"\");\n            stopElapsedTimeTracking();\n        }\n    };\n    // Recovery function - check for pending jobs on page load\n    const checkPendingJobs = async ()=>{\n        try {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            for (const jobId of pendingJobs){\n                const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n                if (!jobData) continue;\n                const job = JSON.parse(jobData);\n                const statusResponse = await checkJobStatus(jobId);\n                if (statusResponse && statusResponse.status === \"completed\") {\n                    console.log(\"\\uD83C\\uDF89 Job completed while user was away! Card data:\", statusResponse.cardData);\n                    // Handle completed job based on type\n                    if (jobId.startsWith(\"draft-\")) {\n                        // Draft job completion\n                        const draftIndex = parseInt(jobId.split(\"-\")[1]);\n                        if (statusResponse.cardData && draftIndex >= 0) {\n                            var _statusResponse_cardData_generatedPrompts;\n                            const draftCard = {\n                                id: \"draft-\".concat(draftIndex + 1, \"-\").concat(Date.now()),\n                                prompt: statusResponse.cardData.prompt || \"Draft Variation \".concat(draftIndex + 1),\n                                frontCover: statusResponse.cardData.frontCover || \"\",\n                                backCover: \"\",\n                                leftPage: \"\",\n                                rightPage: \"\",\n                                createdAt: new Date(),\n                                generatedPrompts: {\n                                    frontCover: ((_statusResponse_cardData_generatedPrompts = statusResponse.cardData.generatedPrompts) === null || _statusResponse_cardData_generatedPrompts === void 0 ? void 0 : _statusResponse_cardData_generatedPrompts.frontCover) || \"\"\n                                }\n                            };\n                            setDraftCards((prev)=>[\n                                    ...prev,\n                                    draftCard\n                                ]);\n                            setDraftIndexMapping((prev)=>[\n                                    ...prev,\n                                    draftIndex\n                                ]);\n                            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 Draft variation \".concat(draftIndex + 1, \" completed while you were away!\"));\n                        }\n                    } else {\n                        // Regular card completion\n                        if (statusResponse.cardData) {\n                            let cardWithQR = {\n                                ...statusResponse.cardData\n                            };\n                            if (!cardWithQR.createdAt) {\n                                cardWithQR.createdAt = new Date();\n                            } else if (typeof cardWithQR.createdAt === \"string\" || typeof cardWithQR.createdAt === \"number\") {\n                                cardWithQR.createdAt = new Date(cardWithQR.createdAt);\n                            }\n                            if (!cardWithQR.id) {\n                                cardWithQR.id = \"card-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n                            }\n                            setGeneratedCard(cardWithQR);\n                            setGeneratedCards([\n                                cardWithQR\n                            ]);\n                            setSelectedCardIndex(0);\n                            setIsCardCompleted(true);\n                            setIsGenerating(false);\n                            setGenerationProgress(\"\");\n                            if (statusResponse.cardData.generationTimeSeconds) {\n                                setGenerationDuration(statusResponse.cardData.generationTimeSeconds);\n                            }\n                            stopElapsedTimeTracking();\n                            setProgressPercentage(100);\n                            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Your card finished generating while you were away!\");\n                            // Send thank you email using job data\n                            if (job.userEmail && job.userEmail.trim()) {\n                                const cardTypeForEmail = job.selectedType === \"custom\" ? job.customCardType : job.selectedType;\n                                sendThankYouEmail(job.userEmail, cardTypeForEmail, cardWithQR.shareUrl || \"https://vibecarding.com\");\n                            }\n                        }\n                    }\n                    removeJobFromStorage(jobId);\n                } else if (statusResponse && statusResponse.status === \"failed\") {\n                    // Job failed\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"❌ A card generation job failed. Please try again.\");\n                    removeJobFromStorage(jobId);\n                } else if (statusResponse && statusResponse.status === \"processing\") {\n                    // Still processing - restore loading states and start polling\n                    setIsGenerating(true);\n                    setCurrentJobId(jobId);\n                    setGenerationProgress(\"Resuming card generation...\");\n                    // Start elapsed time tracking from when job was originally created\n                    const jobStartTime = job.createdAt ? new Date(job.createdAt).getTime() : Date.now();\n                    startElapsedTimeTracking(jobStartTime);\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"\\uD83D\\uDD04 Resuming card generation where you left off...\");\n                    pollJobStatus(jobId);\n                }\n            }\n        } catch (error) {\n            console.error(\"Failed to check pending jobs:\", error);\n        }\n    };\n    // Return all the state and functions that the UI needs\n    return {\n        // Core state\n        prompt,\n        setPrompt,\n        finalCardMessage,\n        setFinalCardMessage,\n        toField,\n        setToField,\n        fromField,\n        setFromField,\n        selectedType,\n        setSelectedType,\n        customCardType,\n        setCustomCardType,\n        selectedTone,\n        setSelectedTone,\n        isGenerating,\n        setIsGenerating,\n        isGeneratingMessage,\n        setIsGeneratingMessage,\n        generatedCard,\n        setGeneratedCard,\n        numberOfCards,\n        setNumberOfCards,\n        generatedCards,\n        setGeneratedCards,\n        selectedCardIndex,\n        setSelectedCardIndex,\n        // Advanced options\n        showAdvanced,\n        setShowAdvanced,\n        selectedArtisticStyle,\n        setSelectedArtisticStyle,\n        customStyleDescription,\n        setCustomStyleDescription,\n        selectedImageModel,\n        setSelectedImageModel,\n        selectedDraftModel,\n        setSelectedDraftModel,\n        // Draft mode\n        isDraftMode,\n        setIsDraftMode,\n        draftCards,\n        setDraftCards,\n        draftIndexMapping,\n        setDraftIndexMapping,\n        selectedDraftIndex,\n        setSelectedDraftIndex,\n        isGeneratingFinalCard,\n        setIsGeneratingFinalCard,\n        previewingDraftIndex,\n        setPreviewingDraftIndex,\n        draftCompletionShown,\n        setDraftCompletionShown,\n        draftCompletionCount,\n        setDraftCompletionCount,\n        // Progress tracking\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        isCardCompleted,\n        setIsCardCompleted,\n        // Upload and personalization\n        referenceImages,\n        setReferenceImages,\n        referenceImageUrls,\n        setReferenceImageUrls,\n        imageTransformation,\n        setImageTransformation,\n        isUploading,\n        setIsUploading,\n        // Email and settings\n        userEmail,\n        setUserEmail,\n        isHandwrittenMessage,\n        setIsHandwrittenMessage,\n        isFrontBackOnly,\n        setIsFrontBackOnly,\n        selectedPaperSize,\n        setSelectedPaperSize,\n        // UI state\n        isTextareaExpanded,\n        setIsTextareaExpanded,\n        isMessageExpanded,\n        setIsMessageExpanded,\n        showSettings,\n        setShowSettings,\n        showTemplateGallery,\n        setShowTemplateGallery,\n        showPrintConfirmation,\n        setShowPrintConfirmation,\n        // Generation time\n        generationDuration,\n        setGenerationDuration,\n        currentElapsedTime,\n        setCurrentElapsedTime,\n        // Helper functions\n        formatGenerationTime,\n        formatCountdown,\n        sendThankYouEmail,\n        chatWithAI,\n        scrollToCardPreview,\n        // Time tracking functions\n        startElapsedTimeTracking,\n        stopElapsedTimeTracking,\n        // File handling functions\n        handleFileUpload,\n        handleRemoveReferenceImage,\n        // Message functions\n        handleGetMessageHelp,\n        addMessageToHistory,\n        undoMessage,\n        redoMessage,\n        // Job management\n        saveJobToStorage,\n        removeJobFromStorage,\n        checkJobStatus,\n        pollJobStatus,\n        checkPendingJobs,\n        // Main generation functions\n        handleGenerateCardAsync,\n        handleGenerateDraftCards,\n        handleGenerateFinalFromDraft,\n        // Additional state for message refinement\n        messageHistory,\n        setMessageHistory,\n        currentMessageIndex,\n        setCurrentMessageIndex,\n        refinementPrompt,\n        setRefinementPrompt,\n        isRefiningMessage,\n        setIsRefiningMessage,\n        showRefinementBox,\n        setShowRefinementBox,\n        // Template state\n        showTemplateCustomization,\n        setShowTemplateCustomization,\n        selectedTemplate,\n        setSelectedTemplate,\n        templateCustomizations,\n        setTemplateCustomizations,\n        templateSearchQuery,\n        setTemplateSearchQuery,\n        isSearchingTemplates,\n        setIsSearchingTemplates,\n        aiFilteredCards,\n        setAiFilteredCards,\n        searchMode,\n        setSearchMode,\n        textFilteredCards,\n        setTextFilteredCards,\n        showPrompts,\n        setShowPrompts,\n        // Print state\n        printOption,\n        setPrintOption,\n        // Additional draft mode state - removed duplicates\n        // Additional upload state\n        handwritingSample,\n        setHandwritingSample,\n        handwritingSampleUrl,\n        setHandwritingSampleUrl,\n        // Job tracking\n        currentJobId,\n        setCurrentJobId,\n        countdown,\n        setCountdown,\n        countdownInterval,\n        setCountdownInterval,\n        // Section loading states\n        sectionLoadingStates,\n        setSectionLoadingStates,\n        // Fast preview mode\n        fastPreviewMode,\n        setFastPreviewMode,\n        // Additional tracking\n        currentCardId,\n        setCurrentCardId,\n        isInitialLoadComplete,\n        setIsInitialLoadComplete,\n        // Elapsed time tracking\n        generationStartTime,\n        setGenerationStartTime,\n        elapsedTimeInterval,\n        setElapsedTimeInterval,\n        // Constants for UI\n        artisticStyles,\n        paperSizes\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRTdHVkaW8udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7bUVBRXlEO0FBQzFCO0FBQ0s7QUFHcEMsNkNBQTZDO0FBQzdDLE1BQU1JLHVCQUF1QkMseUJBQXVDLElBQUk7QUFnQ3hFLCtDQUErQztBQUMvQyxNQUFNRyxrQkFBa0IsQ0FBQ0M7SUFDdkIsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDSCxVQUFVO0lBQ3JDLE1BQU1JLG1CQUFtQkosVUFBVTtJQUNuQyxPQUFPLEdBQWNJLE9BQVhILFNBQVEsS0FBZ0QsT0FBN0NHLGlCQUFpQkMsUUFBUSxHQUFHQyxRQUFRLENBQUMsR0FBRztBQUMvRDtBQUVBLDRDQUE0QztBQUM1QyxNQUFNQyx1QkFBdUIsQ0FBQ0M7SUFDNUIsTUFBTVAsVUFBVUMsS0FBS0MsS0FBSyxDQUFDSyxrQkFBa0I7SUFDN0MsTUFBTVIsVUFBVUUsS0FBS0MsS0FBSyxDQUFDSyxrQkFBa0I7SUFFN0MsSUFBSVAsVUFBVSxHQUFHO1FBQ2YsT0FBTyxHQUFlRCxPQUFaQyxTQUFRLE1BQVksT0FBUkQsU0FBUTtJQUNoQztJQUNBLE9BQU8sR0FBVyxPQUFSQSxTQUFRO0FBQ3BCO0FBRUEsd0JBQXdCO0FBQ3hCLGVBQWVTLGtCQUFrQkMsT0FBZSxFQUFFQyxRQUFnQixFQUFFQyxPQUFlO0lBQ2pGLElBQUksQ0FBQ0YsUUFBUUcsSUFBSSxJQUFJO0lBRXJCLElBQUk7UUFDRix5QkFBeUI7UUFDekIsTUFBTUMsV0FBVyxnakJBaUJBRixPQVJ3REQsVUFBUyxrVkFRekQsT0FBUkMsU0FBUTtRQXVCekIsc0JBQXNCO1FBQ3RCLE1BQU1HLFdBQVcseUVBTUhILE9BSnlDRCxVQUFTLHdJQUkxQyxPQUFSQyxTQUFRO1FBVXRCLGVBQWU7UUFDZixNQUFNSSxlQUFlLE1BQU1DLE1BQU0sR0FBd0IsT0FBckJ0QixzQkFBcUIsNkJBQTJCO1lBQ2xGdUIsUUFBUTtZQUNSQyxTQUFTO2dCQUNQLGdCQUFn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QztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBLGlCQUFpQjtRQUNqQjZCO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0E3QjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBLGNBQWM7UUFDZEM7UUFDQUM7UUFFQSxtREFBbUQ7UUFFbkQsMEJBQTBCO1FBQzFCL0Q7UUFDQUM7UUFDQUM7UUFDQUM7UUFFQSxlQUFlO1FBQ2Z2QjtRQUNBQztRQUNBUDtRQUNBQztRQUNBQztRQUNBQztRQUVBLHlCQUF5QjtRQUN6QjZDO1FBQ0FDO1FBRUEsb0JBQW9CO1FBQ3BCekM7UUFDQUM7UUFFQSxzQkFBc0I7UUFDdEIrQjtRQUNBQztRQUNBZTtRQUNBQztRQUVBLHdCQUF3QjtRQUN4QnFDO1FBQ0FDO1FBQ0FHO1FBQ0FDO1FBRUEsbUJBQW1CO1FBQ25Cako7UUFDQUU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNhcmRTdHVkaW8udHM/NGNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSBcInNvbm5lclwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgKiBhcyBRUkNvZGUgZnJvbSAncXJjb2RlJztcblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIGJhY2tlbmQgQVBJIGVuZHBvaW50XG5jb25zdCBCQUNLRU5EX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfQVBJX1VSTCB8fCAnaHR0cHM6Ly92aWJlY2FyZGluZy5jb20nO1xuXG5pbnRlcmZhY2UgR2VuZXJhdGVkQ2FyZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBmcm9udENvdmVyOiBzdHJpbmc7ICAgICAgLy8gUG9ydHJhaXQgaW1hZ2UgLSB3aGF0IHJlY2lwaWVudHMgc2VlIGZpcnN0XG4gIGJhY2tDb3Zlcjogc3RyaW5nOyAgICAgICAvLyBQb3J0cmFpdCBpbWFnZSAtIGJhY2sgb2YgdGhlIGNhcmRcbiAgbGVmdFBhZ2U6IHN0cmluZzsgICAgICAgIC8vIFBvcnRyYWl0IGltYWdlIC0gbGVmdCBpbnRlcmlvciAoZGVjb3JhdGl2ZSBhcnQpXG4gIHJpZ2h0UGFnZTogc3RyaW5nOyAgICAgICAvLyBQb3J0cmFpdCBpbWFnZSAtIHJpZ2h0IGludGVyaW9yIChtZXNzYWdlIGFyZWEpXG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgc2hhcmVVcmw/OiBzdHJpbmc7ICAgICAgIC8vIFNoYXJlYWJsZSBVUkwgZm9yIHRoZSBjYXJkXG4gIC8vIFN0b3JlIHRoZSBhY3R1YWwgcHJvbXB0cyBzZW50IHRvIGltYWdlIGdlbmVyYXRpb25cbiAgZ2VuZXJhdGVkUHJvbXB0cz86IHtcbiAgICBmcm9udENvdmVyPzogc3RyaW5nO1xuICAgIGJhY2tDb3Zlcj86IHN0cmluZztcbiAgICBsZWZ0SW50ZXJpb3I/OiBzdHJpbmc7XG4gICAgcmlnaHRJbnRlcmlvcj86IHN0cmluZztcbiAgfTtcbiAgLy8gVGh1bWJuYWlsIFVSTHMgZm9yIGZhc3RlciBsb2FkaW5nXG4gIHRodW1ibmFpbHM/OiB7XG4gICAgZnJvbnRDb3Zlcj86IHN0cmluZztcbiAgICBiYWNrQ292ZXI/OiBzdHJpbmc7XG4gICAgbGVmdFBhZ2U/OiBzdHJpbmc7XG4gICAgcmlnaHRQYWdlPzogc3RyaW5nO1xuICB9O1xuICAvLyBTdHlsZSBpbmZvcm1hdGlvbiBmb3Igc21hcnQgc3R5bGUgbW9kZVxuICBzdHlsZUluZm8/OiB7XG4gICAgc3R5bGVOYW1lPzogc3RyaW5nO1xuICAgIHN0eWxlTGFiZWw/OiBzdHJpbmc7XG4gIH07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgY291bnRkb3duIGFzIE1NOlNTXG5jb25zdCBmb3JtYXRDb3VudGRvd24gPSAoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgY29uc3QgcmVtYWluaW5nU2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcbiAgcmV0dXJuIGAke21pbnV0ZXN9OiR7cmVtYWluaW5nU2Vjb25kcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgZ2VuZXJhdGlvbiB0aW1lXG5jb25zdCBmb3JtYXRHZW5lcmF0aW9uVGltZSA9IChkdXJhdGlvblNlY29uZHM6IG51bWJlcikgPT4ge1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihkdXJhdGlvblNlY29uZHMgLyA2MCk7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKGR1cmF0aW9uU2Vjb25kcyAlIDYwKTtcbiAgXG4gIGlmIChtaW51dGVzID4gMCkge1xuICAgIHJldHVybiBgJHttaW51dGVzfW0gJHtzZWNvbmRzfXNgO1xuICB9XG4gIHJldHVybiBgJHtzZWNvbmRzfXNgO1xufTtcblxuLy8gRW1haWwgSGVscGVyIEZ1bmN0aW9uXG5hc3luYyBmdW5jdGlvbiBzZW5kVGhhbmtZb3VFbWFpbCh0b0VtYWlsOiBzdHJpbmcsIGNhcmRUeXBlOiBzdHJpbmcsIGNhcmRVcmw6IHN0cmluZykge1xuICBpZiAoIXRvRW1haWwudHJpbSgpKSByZXR1cm47XG4gIFxuICB0cnkge1xuICAgIC8vIENyZWF0ZSBIVE1MIGVtYWlsIGJvZHlcbiAgICBjb25zdCBodG1sQm9keSA9IGBcbiAgICAgIDxkaXYgc3R5bGU9XCJmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7IG1heC13aWR0aDogNjAwcHg7IG1hcmdpbjogMCBhdXRvOyBwYWRkaW5nOiAyMHB4OyBjb2xvcjogIzMzMztcIj5cbiAgICAgICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMzBweDtcIj5cbiAgICAgICAgICA8aDEgc3R5bGU9XCJjb2xvcjogIzI1NjNlYjsgbWFyZ2luLWJvdHRvbTogMTBweDtcIj7wn46JIFlvdXIgQ2FyZCBpcyBSZWFkeSE8L2gxPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxwIHN0eWxlPVwiZm9udC1zaXplOiAxNnB4OyBsaW5lLWhlaWdodDogMS42OyBtYXJnaW4tYm90dG9tOiAyMHB4O1wiPkhpIHRoZXJlITwvcD5cbiAgICAgICAgXG4gICAgICAgIDxwIHN0eWxlPVwiZm9udC1zaXplOiAxNnB4OyBsaW5lLWhlaWdodDogMS42OyBtYXJnaW4tYm90dG9tOiAyMHB4O1wiPlxuICAgICAgICAgIFRoYW5rIHlvdSBmb3IgdXNpbmcgVmliZUNhcmRpbmcgdG8gY3JlYXRlIHlvdXIgYmVhdXRpZnVsIDxzdHJvbmc+JHtjYXJkVHlwZX08L3N0cm9uZz4gY2FyZCFcbiAgICAgICAgPC9wPlxuICAgICAgICBcbiAgICAgICAgPHAgc3R5bGU9XCJmb250LXNpemU6IDE2cHg7IGxpbmUtaGVpZ2h0OiAxLjY7IG1hcmdpbi1ib3R0b206IDIwcHg7XCI+XG4gICAgICAgICAgV2UgaG9wZSB5b3UgbG92ZSBob3cgaXQgdHVybmVkIG91dC4gWW91ciBjYXJkIGhhcyBiZWVuIGdlbmVyYXRlZCBhbmQgaXMgcmVhZHkgZm9yIHByaW50aW5nIG9yIHNoYXJpbmcuXG4gICAgICAgIDwvcD5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IG1hcmdpbjogMzBweCAwO1wiPlxuICAgICAgICAgIDxhIGhyZWY9XCIke2NhcmRVcmx9XCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjMjU2M2ViOyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDEycHggMjRweDsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBib3JkZXItcmFkaXVzOiA2cHg7IGZvbnQtd2VpZ2h0OiBib2xkOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XCI+XG4gICAgICAgICAgICBWaWV3IFlvdXIgQ2FyZFxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8cCBzdHlsZT1cImZvbnQtc2l6ZTogMTZweDsgbGluZS1oZWlnaHQ6IDEuNjsgbWFyZ2luLWJvdHRvbTogMjBweDtcIj5cbiAgICAgICAgICBJZiB5b3UgaGF2ZSBhbnkgcXVlc3Rpb25zIG9yIGZlZWRiYWNrLCBmZWVsIGZyZWUgdG8gcmVhY2ggb3V0IHRvIHVzLlxuICAgICAgICA8L3A+XG4gICAgICAgIFxuICAgICAgICA8cCBzdHlsZT1cImZvbnQtc2l6ZTogMTZweDsgbGluZS1oZWlnaHQ6IDEuNjsgbWFyZ2luLWJvdHRvbTogMjBweDtcIj5cbiAgICAgICAgICBIYXBweSBjYXJkIG1ha2luZyFcbiAgICAgICAgPC9wPlxuICAgICAgICBcbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDQwcHg7IHBhZGRpbmctdG9wOiAyMHB4OyBib3JkZXItdG9wOiAxcHggc29saWQgI2U1ZTdlYjsgY29sb3I6ICM2YjcyODA7XCI+XG4gICAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiA1cHg7XCI+PHN0cm9uZz5CZXN0IHJlZ2FyZHMsPC9zdHJvbmc+PC9wPlxuICAgICAgICAgIDxwIHN0eWxlPVwibWFyZ2luLWJvdHRvbTogNXB4O1wiPlRoZSBWaWJlQ2FyZGluZyBUZWFtPC9wPlxuICAgICAgICAgIDxwIHN0eWxlPVwibWFyZ2luOiAwO1wiPlxuICAgICAgICAgICAgPGEgaHJlZj1cIm1haWx0bzp2aWJlY2FyZGluZ0Bhc3QuZW5naW5lZXJcIiBzdHlsZT1cImNvbG9yOiAjMjU2M2ViOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7XCI+dmliZWNhcmRpbmdAYXN0LmVuZ2luZWVyPC9hPlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuXG4gICAgLy8gUGxhaW4gdGV4dCBmYWxsYmFja1xuICAgIGNvbnN0IHRleHRCb2R5ID0gYEhpIHRoZXJlIVxuXG5UaGFuayB5b3UgZm9yIHVzaW5nIFZpYmVDYXJkaW5nIHRvIGNyZWF0ZSB5b3VyIGJlYXV0aWZ1bCAke2NhcmRUeXBlfSBjYXJkIVxuXG5XZSBob3BlIHlvdSBsb3ZlIGhvdyBpdCB0dXJuZWQgb3V0LiBZb3VyIGNhcmQgaGFzIGJlZW4gZ2VuZXJhdGVkIGFuZCBpcyByZWFkeSBmb3IgcHJpbnRpbmcgb3Igc2hhcmluZy5cblxuVmlldyB5b3VyIGNhcmQ6ICR7Y2FyZFVybH1cblxuSWYgeW91IGhhdmUgYW55IHF1ZXN0aW9ucyBvciBmZWVkYmFjaywgZmVlbCBmcmVlIHRvIHJlYWNoIG91dCB0byB1cy5cblxuSGFwcHkgY2FyZCBtYWtpbmchXG5cbkJlc3QgcmVnYXJkcyxcblRoZSBWaWJlQ2FyZGluZyBUZWFtXG52aWJlY2FyZGluZ0Bhc3QuZW5naW5lZXJgO1xuXG4gICAgLy8gU2VuZCB0byB1c2VyXG4gICAgY29uc3QgdXNlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L3NlbmRfZW1haWxfbm9kZWpzX3N0eWxlYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7IFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0bzogdG9FbWFpbCxcbiAgICAgICAgZnJvbTogJ3ZpYmVjYXJkaW5nQGFzdC5lbmdpbmVlcicsXG4gICAgICAgIHN1YmplY3Q6IGBZb3VyICR7Y2FyZFR5cGV9IGNhcmQgaXMgcmVhZHkhYCxcbiAgICAgICAgYm9keTogaHRtbEJvZHksXG4gICAgICAgIHRleHQ6IHRleHRCb2R5LFxuICAgICAgICBodG1sOiBodG1sQm9keVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIC8vIFNlbmQgY29weSB0byBqb3JkYW5AYXN0LmVuZ2luZWVyXG4gICAgY29uc3QgYWRtaW5SZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9zZW5kX2VtYWlsX25vZGVqc19zdHlsZWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHRvOiAnam9yZGFuQGFzdC5lbmdpbmVlcicsXG4gICAgICAgIGZyb206ICd2aWJlY2FyZGluZ0Bhc3QuZW5naW5lZXInLFxuICAgICAgICBzdWJqZWN0OiBgQ2FyZCBDcmVhdGVkIC0gJHtjYXJkVHlwZX0gZm9yICR7dG9FbWFpbH1gLFxuICAgICAgICBib2R5OiBgPGRpdiBzdHlsZT1cImZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjsgcGFkZGluZzogMjBweDtcIj5cbiAgICAgICAgICA8aDMgc3R5bGU9XCJjb2xvcjogIzI1NjNlYjtcIj5OZXcgQ2FyZCBDcmVhdGVkIG9uIFZpYmVDYXJkaW5nPC9oMz5cbiAgICAgICAgICA8cD48c3Ryb25nPlVzZXI6PC9zdHJvbmc+ICR7dG9FbWFpbH08L3A+XG4gICAgICAgICAgPHA+PHN0cm9uZz5DYXJkIFR5cGU6PC9zdHJvbmc+ICR7Y2FyZFR5cGV9PC9wPlxuICAgICAgICAgIDxwPjxzdHJvbmc+Q2FyZCBVUkw6PC9zdHJvbmc+IDxhIGhyZWY9XCIke2NhcmRVcmx9XCI+JHtjYXJkVXJsfTwvYT48L3A+XG4gICAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW4tdG9wOiAyMHB4OyBjb2xvcjogIzZiNzI4MDsgZm9udC1zaXplOiAxNHB4O1wiPlxuICAgICAgICAgICAgVGhpcyBpcyBhbiBhdXRvbWF0ZWQgbm90aWZpY2F0aW9uIG9mIGNhcmQgY3JlYXRpb24gYWN0aXZpdHkuXG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5gLFxuICAgICAgICB0ZXh0OiBgTmV3IGNhcmQgY3JlYXRlZCBvbiBWaWJlQ2FyZGluZzpcblxuVXNlcjogJHt0b0VtYWlsfVxuQ2FyZCBUeXBlOiAke2NhcmRUeXBlfVxuQ2FyZCBVUkw6ICR7Y2FyZFVybH1cblxuVGhpcyBpcyBhbiBhdXRvbWF0ZWQgbm90aWZpY2F0aW9uIG9mIGNhcmQgY3JlYXRpb24gYWN0aXZpdHkuYFxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmICh1c2VyUmVzcG9uc2Uub2spIHtcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoXCLinInvuI8gVGhhbmsgeW91IGVtYWlsIHNlbnQhXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCB0aGFuayB5b3UgZW1haWw6JywgZXJyb3IpO1xuICAgIC8vIERvbid0IHNob3cgZXJyb3IgdG9hc3QgLSB0aGlzIGlzIGEgbmljZS10by1oYXZlIGZlYXR1cmVcbiAgfVxufVxuXG4vLyBDaGF0IEhlbHBlciBGdW5jdGlvblxuYXN5bmMgZnVuY3Rpb24gY2hhdFdpdGhBSSh1c2VyTWVzc2FnZTogc3RyaW5nLCBvcHRpb25zOiB7XG4gIHN5c3RlbVByb21wdD86IHN0cmluZyB8IG51bGw7XG4gIG1vZGVsPzogc3RyaW5nO1xuICBpbmNsdWRlVGhvdWdodHM/OiBib29sZWFuO1xuICBqc29uU2NoZW1hPzogYW55O1xuICBhdHRhY2htZW50cz86IHN0cmluZ1tdOyAgLy8gQWRkIHN1cHBvcnQgZm9yIGltYWdlIGF0dGFjaG1lbnRzXG59ID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHN5c3RlbVByb21wdCA9IG51bGwsXG4gICAgbW9kZWwgPSAnZ2VtaW5pLTIuNS1wcm8nLFxuICAgIGluY2x1ZGVUaG91Z2h0cyA9IGZhbHNlLCAgLy8gRGVmYXVsdCB0byBmYWxzZSB0byBhdm9pZCB0aGlua2luZyBjb250ZW50IGluIHJlc3BvbnNlc1xuICAgIGpzb25TY2hlbWEgPSBudWxsLFxuICAgIGF0dGFjaG1lbnRzID0gW10gIC8vIERlZmF1bHQgdG8gZW1wdHkgYXJyYXlcbiAgfSA9IG9wdGlvbnM7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9pbnRlcm5hbC9jYWxsX21jcF90b29sJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdG9vbF9uYW1lOiAnYWlfY2hhdCcsXG4gICAgICAgIGFyZ3VtZW50czoge1xuICAgICAgICAgIG1lc3NhZ2VzOiB1c2VyTWVzc2FnZSxcbiAgICAgICAgICBzeXN0ZW1fcHJvbXB0OiBzeXN0ZW1Qcm9tcHQsXG4gICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgIGluY2x1ZGVfdGhvdWdodHM6IGluY2x1ZGVUaG91Z2h0cyxcbiAgICAgICAgICBqc29uX3NjaGVtYToganNvblNjaGVtYSxcbiAgICAgICAgICAuLi4oYXR0YWNobWVudHMubGVuZ3RoID4gMCAmJiB7IGF0dGFjaG1lbnRzIH0pICAvLyBPbmx5IGluY2x1ZGUgaWYgdGhlcmUgYXJlIGF0dGFjaG1lbnRzXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKGRhdGEuZXJyb3IgJiYgZGF0YS5lcnJvciAhPT0gXCJOb25lXCIgJiYgZGF0YS5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgZGF0YS5yZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEucmVzdWx0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXN1bHQgPSB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiByZXNwb25zZScgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGF0YS5yZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0LnJlc3BvbnNlO1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FJIGNoYXQgZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBDYXJkIHRvbmUvc3R5bGUgb3B0aW9uc1xuY29uc3QgY2FyZFRvbmVzID0gW1xuICB7IGlkOiBcImZ1bm55XCIsIGxhYmVsOiBcIvCfmIQgRnVubnlcIiwgZGVzY3JpcHRpb246IFwiSHVtb3JvdXMgYW5kIGxpZ2h0aGVhcnRlZFwiIH0sXG4gIHsgaWQ6IFwiZ2Vuei1odW1vclwiLCBsYWJlbDogXCLwn5KAIEdlblogSHVtb3JcIiwgZGVzY3JpcHRpb246IFwiSW50ZXJuZXQgbWVtZXMsIGNoYW90aWMgZW5lcmd5LCBhbmQgdW5oaW5nZWQgdmliZXNcIiB9LFxuICB7IGlkOiBcInJvbWFudGljXCIsIGxhYmVsOiBcIvCfkpUgUm9tYW50aWNcIiwgZGVzY3JpcHRpb246IFwiU3dlZXQgYW5kIGxvdmluZ1wiIH0sXG4gIHsgaWQ6IFwicHJvZmVzc2lvbmFsXCIsIGxhYmVsOiBcIvCfkZQgUHJvZmVzc2lvbmFsXCIsIGRlc2NyaXB0aW9uOiBcIkZvcm1hbCBhbmQgYnVzaW5lc3MtYXBwcm9wcmlhdGVcIiB9LFxuICB7IGlkOiBcImhlYXJ0ZmVsdFwiLCBsYWJlbDogXCLinaTvuI8gSGVhcnRmZWx0XCIsIGRlc2NyaXB0aW9uOiBcIlNpbmNlcmUgYW5kIGVtb3Rpb25hbFwiIH0sXG4gIHsgaWQ6IFwicGxheWZ1bFwiLCBsYWJlbDogXCLwn46JIFBsYXlmdWxcIiwgZGVzY3JpcHRpb246IFwiRnVuIGFuZCBlbmVyZ2V0aWNcIiB9LFxuICB7IGlkOiBcImVsZWdhbnRcIiwgbGFiZWw6IFwi4pyoIEVsZWdhbnRcIiwgZGVzY3JpcHRpb246IFwiU29waGlzdGljYXRlZCBhbmQgcmVmaW5lZFwiIH0sXG4gIHsgaWQ6IFwiY2FzdWFsXCIsIGxhYmVsOiBcIvCfmIogQ2FzdWFsXCIsIGRlc2NyaXB0aW9uOiBcIlJlbGF4ZWQgYW5kIGZyaWVuZGx5XCIgfSxcbiAgeyBpZDogXCJpbnNwaXJhdGlvbmFsXCIsIGxhYmVsOiBcIvCfjJ8gSW5zcGlyYXRpb25hbFwiLCBkZXNjcmlwdGlvbjogXCJNb3RpdmF0aW5nIGFuZCB1cGxpZnRpbmdcIiB9LFxuICB7IGlkOiBcInF1aXJreVwiLCBsYWJlbDogXCLwn6SqIFF1aXJreVwiLCBkZXNjcmlwdGlvbjogXCJVbmlxdWUgYW5kIHVuY29udmVudGlvbmFsXCIgfSxcbiAgeyBpZDogXCJ0cmFkaXRpb25hbFwiLCBsYWJlbDogXCLwn46tIFRyYWRpdGlvbmFsXCIsIGRlc2NyaXB0aW9uOiBcIkNsYXNzaWMgYW5kIHRpbWVsZXNzXCIgfSxcbl07XG5cbi8vIEN1cmF0ZWQgYXJ0aXN0aWMgc3R5bGVzIGZvciBiZWF1dGlmdWwgY2FyZHNcbmNvbnN0IGFydGlzdGljU3R5bGVzID0gW1xuICB7XG4gICAgaWQ6IFwiYWktc21hcnQtc3R5bGVcIiwgXG4gICAgbGFiZWw6IFwi4pyoIFNtYXJ0IFN0eWxlXCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkxldCBvdXIgZXhwZXJ0cyBjaG9vc2UgdGhlIHBlcmZlY3Qgc3R5bGUgZm9yIHlvdXIgY2FyZFwiLFxuICAgIHByb21wdE1vZGlmaWVyOiBcIlwiXG4gIH0sXG4gIHtcbiAgICBpZDogXCJjdXN0b21cIiwgXG4gICAgbGFiZWw6IFwi4pyoIEN1c3RvbSBTdHlsZVwiLCBcbiAgICBkZXNjcmlwdGlvbjogXCJEZWZpbmUgeW91ciBvd24gdW5pcXVlIGFydGlzdGljIHN0eWxlXCIsXG4gICAgcHJvbXB0TW9kaWZpZXI6IFwiXCJcbiAgfSxcbiAgeyBcbiAgICBpZDogXCJ3YXRlcmNvbG9yXCIsIFxuICAgIGxhYmVsOiBcIvCfjqggV2F0ZXJjb2xvclwiLCBcbiAgICBkZXNjcmlwdGlvbjogXCJTb2Z0LCBmbG93aW5nIHBhaW50IGVmZmVjdHMgKG91ciBwZXJzb25hbCBmYXZvcml0ZSlcIixcbiAgICBwcm9tcHRNb2RpZmllcjogXCJpbiB3YXRlcmNvbG9yIHBhaW50aW5nIHN0eWxlLCB3aXRoIHNvZnQgZmxvd2luZyBjb2xvcnMsIGFydGlzdGljIGJydXNoIHN0cm9rZXMsIHBhcGVyIHRleHR1cmUsIGFuZCBvcmdhbmljIHBhaW50IGJsZWVkc1wiXG4gIH0sXG4gIHtcbiAgICBpZDogXCJtaW5pbWFsaXN0XCIsIFxuICAgIGxhYmVsOiBcIuKcqCBNaW5pbWFsaXN0XCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkNsZWFuLCBzaW1wbGUsIGVsZWdhbnQgZGVzaWduXCIsXG4gICAgcHJvbXB0TW9kaWZpZXI6IFwiaW4gbWluaW1hbGlzdCBzdHlsZSB3aXRoIGNsZWFuIGxpbmVzLCBzaW1wbGUgc2hhcGVzLCBwbGVudHkgb2Ygd2hpdGUgc3BhY2UsIHNvcGhpc3RpY2F0ZWQgdHlwb2dyYXBoeSwgYW5kIGVsZWdhbnQgc2ltcGxpY2l0eVwiXG4gIH0sXG4gIHsgXG4gICAgaWQ6IFwiYm90YW5pY2FsXCIsIFxuICAgIGxhYmVsOiBcIvCfjL8gQm90YW5pY2FsXCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkJlYXV0aWZ1bCBmbG93ZXJzIGFuZCBuYXR1cmUgZWxlbWVudHNcIixcbiAgICBwcm9tcHRNb2RpZmllcjogXCJpbiBib3RhbmljYWwgaWxsdXN0cmF0aW9uIHN0eWxlIHdpdGggZGV0YWlsZWQgZmxvd2VycywgbGVhdmVzLCBhbmQgbmF0dXJhbCBlbGVtZW50cywgc29mdCBvcmdhbmljIHNoYXBlcywgZWxlZ2FudCBmbG9yYWwgYXJyYW5nZW1lbnRzLCBhbmQgbmF0dXJlLWluc3BpcmVkIGRlc2lnbnMgcGVyZmVjdCBmb3IgZ3JlZXRpbmcgY2FyZHNcIlxuICB9LFxuICB7IFxuICAgIGlkOiBcImNvbWljLWJvb2tcIiwgXG4gICAgbGFiZWw6IFwi8J+SpSBDb21pYyBCb29rXCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkJvbGQgZ3JhcGhpYyBub3ZlbCBzdHlsZVwiLFxuICAgIHByb21wdE1vZGlmaWVyOiBcImluIGNvbWljIGJvb2sgYXJ0IHN0eWxlIHdpdGggYm9sZCBvdXRsaW5lcywgdmlicmFudCBjb2xvcnMsIGR5bmFtaWMgcG9zZXMsIHNwZWVjaCBidWJibGUgYWVzdGhldGljcywgaGFsZnRvbmUgcGF0dGVybnMsIGFuZCBzdXBlcmhlcm8gY29taWMgYm9vayB2aXN1YWwgZWxlbWVudHMgdGhhdCBjcmVhdGUgYW4gZXhjaXRpbmcgYW5kIGVuZXJnZXRpYyBmZWVsXCJcbiAgfSxcbiAgeyBcbiAgICBpZDogXCJkcmVhbXktZmFudGFzeVwiLCBcbiAgICBsYWJlbDogXCLwn4y4IERyZWFteSBGYW50YXN5XCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkVuY2hhbnRpbmcgYW5pbWUtaW5zcGlyZWQgYXJ0XCIsXG4gICAgcHJvbXB0TW9kaWZpZXI6IFwiaW4gZHJlYW15IGZhbnRhc3kgYW5pbWUgc3R5bGUsIHdpdGggc29mdCBwYXN0ZWxzLCBtYWdpY2FsIGF0bW9zcGhlcmUsIGRldGFpbGVkIG5hdHVyZSBlbGVtZW50cywgd2hpbXNpY2FsIGNoYXJhY3RlcnMsIGFuZCBlbmNoYW50aW5nIGZhaXJ5LXRhbGUgcXVhbGl0aWVzXCJcbiAgfSxcbiAgeyBcbiAgICBpZDogXCJhcnQtZGVjb1wiLCBcbiAgICBsYWJlbDogXCLinKggQXJ0IERlY29cIiwgXG4gICAgZGVzY3JpcHRpb246IFwiRWxlZ2FudCAxOTIwcyBnZW9tZXRyaWMgbHV4dXJ5XCIsXG4gICAgcHJvbXB0TW9kaWZpZXI6IFwiaW4gdmludGFnZSBBcnQgRGVjbyBzdHlsZSB3aXRoIGdlb21ldHJpYyBwYXR0ZXJucywgZ29sZCBhY2NlbnRzLCBlbGVnYW50IHR5cG9ncmFwaHksIGx1eHVyaW91cyBkZXRhaWxzLCBhbmQgMTkyMHMgZ2xhbW91clwiXG4gIH0sXG4gIHsgXG4gICAgaWQ6IFwidmludGFnZS1pbGx1c3RyYXRpb25cIiwgXG4gICAgbGFiZWw6IFwi8J+TmiBWaW50YWdlIElsbHVzdHJhdGlvblwiLCBcbiAgICBkZXNjcmlwdGlvbjogXCJDbGFzc2ljIHN0b3J5Ym9vayBjaGFybVwiLFxuICAgIHByb21wdE1vZGlmaWVyOiBcImluIHZpbnRhZ2UgaWxsdXN0cmF0aW9uIHN0eWxlIGxpa2UgY2xhc3NpYyBjaGlsZHJlbidzIGJvb2tzLCB3aXRoIHdhcm0gbm9zdGFsZ2ljIGNvbG9ycywgY2hhcm1pbmcgY2hhcmFjdGVycywgd2hpbXNpY2FsIGRldGFpbHMsIGFuZCB0aW1lbGVzcyBmYWlyeS10YWxlIGFlc3RoZXRpY3NcIlxuICB9LFxuICB7XG4gICAgaWQ6IFwibW9kZXJuLWdlb21ldHJpY1wiLCBcbiAgICBsYWJlbDogXCLwn5S3IE1vZGVybiBHZW9tZXRyaWNcIiwgXG4gICAgZGVzY3JpcHRpb246IFwiQ2xlYW4gY29udGVtcG9yYXJ5IHNoYXBlc1wiLFxuICAgIHByb21wdE1vZGlmaWVyOiBcImluIG1vZGVybiBnZW9tZXRyaWMgc3R5bGUgd2l0aCBjbGVhbiBzaGFwZXMsIGNvbnRlbXBvcmFyeSBkZXNpZ24gZWxlbWVudHMsIGJhbGFuY2VkIGNvbXBvc2l0aW9ucywgYW5kIHNvcGhpc3RpY2F0ZWQgY29sb3IgcGFsZXR0ZXMgcGVyZmVjdCBmb3IgbW9kZXJuIGdyZWV0aW5nIGNhcmRzXCJcbiAgfSxcbiAge1xuICAgIGlkOiBcInNvZnQtcGFzdGVsXCIsIFxuICAgIGxhYmVsOiBcIvCfjLggU29mdCBQYXN0ZWxcIiwgXG4gICAgZGVzY3JpcHRpb246IFwiR2VudGxlLCBzb290aGluZyBjb2xvcnNcIixcbiAgICBwcm9tcHRNb2RpZmllcjogXCJpbiBzb2Z0IHBhc3RlbCBzdHlsZSB3aXRoIGdlbnRsZSBjb2xvcnMsIGRyZWFteSBhdG1vc3BoZXJlLCBkZWxpY2F0ZSB0ZXh0dXJlcywgYW5kIGNhbG1pbmcgdmlzdWFsIGVsZW1lbnRzIHRoYXQgY3JlYXRlIGEgcGVhY2VmdWwgYW5kIGhlYXJ0d2FybWluZyBmZWVsaW5nXCJcbiAgfSxcbiAge1xuICAgIGlkOiBcInJldHJvLXZpbnRhZ2VcIiwgXG4gICAgbGFiZWw6IFwi8J+TuyBSZXRybyBWaW50YWdlXCIsIFxuICAgIGRlc2NyaXB0aW9uOiBcIkNsYXNzaWMgMTk1MHMtNjBzIG5vc3RhbGdpYVwiLFxuICAgIHByb21wdE1vZGlmaWVyOiBcImluIHJldHJvIHZpbnRhZ2Ugc3R5bGUgd2l0aCAxOTUwcy02MHMgYWVzdGhldGljcywgY2xhc3NpYyB0eXBvZ3JhcGh5LCB3YXJtIG5vc3RhbGdpYyBjb2xvcnMsIGFuZCBtaWQtY2VudHVyeSBkZXNpZ24gZWxlbWVudHNcIlxuICB9XG5dO1xuXG4vLyBQYXBlciBzaXplIG9wdGlvbnNcbmNvbnN0IHBhcGVyU2l6ZXMgPSBbXG4gIHtcbiAgICBpZDogXCJzdGFuZGFyZFwiLFxuICAgIGxhYmVsOiBcIjXDlzcgQ2FyZCAoU3RhbmRhcmQpXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhbmRhcmQgNcOXNyBncmVldGluZyBjYXJkICgxMMOXNyBwcmludCBsYXlvdXQpXCIsXG4gICAgYXNwZWN0UmF0aW86IFwiOToxNlwiLFxuICAgIGRpbWVuc2lvbnM6IFwiMTAyNHgxNTM2XCIsXG4gICAgcHJpbnRXaWR0aDogXCIxMGluXCIsXG4gICAgcHJpbnRIZWlnaHQ6IFwiN2luXCJcbiAgfSxcbiAge1xuICAgIGlkOiBcImNvbXBhY3RcIixcbiAgICBsYWJlbDogXCI0w5c2IENhcmQgKENvbXBhY3QpXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQ29tcGFjdCA0w5c2IGdyZWV0aW5nIGNhcmQgKDjDlzYgcHJpbnQgbGF5b3V0KVwiLFxuICAgIGFzcGVjdFJhdGlvOiBcIjI6M1wiLFxuICAgIGRpbWVuc2lvbnM6IFwiNzY4eDExNTJcIixcbiAgICBwcmludFdpZHRoOiBcIjhpblwiLFxuICAgIHByaW50SGVpZ2h0OiBcIjZpblwiXG4gIH0sXG4gIHtcbiAgICBpZDogXCJhNlwiLFxuICAgIGxhYmVsOiBcIkE2IENhcmQgKDTDlzYpXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQTYgcGFwZXIgc2l6ZSAoOC4zw5c1LjggcHJpbnQgbGF5b3V0KVwiLFxuICAgIGFzcGVjdFJhdGlvOiBcIjI6M1wiLFxuICAgIGRpbWVuc2lvbnM6IFwiNzY4eDExNTJcIixcbiAgICBwcmludFdpZHRoOiBcIjguM2luXCIsXG4gICAgcHJpbnRIZWlnaHQ6IFwiNS44aW5cIlxuICB9XG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FyZFN0dWRpbygpIHtcbiAgLy8gQWxsIHlvdXIgZXhpc3Rpbmcgc3RhdGUgZnJvbSBwYWdlLnRzeFxuICBjb25zdCBbcHJvbXB0LCBzZXRQcm9tcHRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtmaW5hbENhcmRNZXNzYWdlLCBzZXRGaW5hbENhcmRNZXNzYWdlXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbdG9GaWVsZCwgc2V0VG9GaWVsZF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2Zyb21GaWVsZCwgc2V0RnJvbUZpZWxkXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbc2VsZWN0ZWRUeXBlLCBzZXRTZWxlY3RlZFR5cGVdID0gdXNlU3RhdGU8c3RyaW5nPihcImJpcnRoZGF5XCIpO1xuICBjb25zdCBbY3VzdG9tQ2FyZFR5cGUsIHNldEN1c3RvbUNhcmRUeXBlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtzZWxlY3RlZFRvbmUsIHNldFNlbGVjdGVkVG9uZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiZnVubnlcIik7XG4gIGNvbnN0IFtpc0dlbmVyYXRpbmcsIHNldElzR2VuZXJhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtnZW5lcmF0ZWRDYXJkLCBzZXRHZW5lcmF0ZWRDYXJkXSA9IHVzZVN0YXRlPEdlbmVyYXRlZENhcmQgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIE11bHRpcGxlIGNhcmRzIHN0YXRlXG4gIGNvbnN0IFtudW1iZXJPZkNhcmRzLCBzZXROdW1iZXJPZkNhcmRzXSA9IHVzZVN0YXRlPG51bWJlcj4oMSk7XG4gIGNvbnN0IFtnZW5lcmF0ZWRDYXJkcywgc2V0R2VuZXJhdGVkQ2FyZHNdID0gdXNlU3RhdGU8R2VuZXJhdGVkQ2FyZFtdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZENhcmRJbmRleCwgc2V0U2VsZWN0ZWRDYXJkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICAvLyBXcml0aW5nIGFzc2lzdGFudCBzdGF0ZVxuICBjb25zdCBbaXNHZW5lcmF0aW5nTWVzc2FnZSwgc2V0SXNHZW5lcmF0aW5nTWVzc2FnZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gQWR2YW5jZWQgb3B0aW9ucyBzdGF0ZVxuICBjb25zdCBbc2hvd0FkdmFuY2VkLCBzZXRTaG93QWR2YW5jZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VsZWN0ZWRBcnRpc3RpY1N0eWxlLCBzZXRTZWxlY3RlZEFydGlzdGljU3R5bGVdID0gdXNlU3RhdGU8c3RyaW5nPihcIndhdGVyY29sb3JcIik7XG4gIGNvbnN0IFtjdXN0b21TdHlsZURlc2NyaXB0aW9uLCBzZXRDdXN0b21TdHlsZURlc2NyaXB0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtzZWxlY3RlZEltYWdlTW9kZWwsIHNldFNlbGVjdGVkSW1hZ2VNb2RlbF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiZ3B0LWltYWdlLTFcIik7XG5cbiAgLy8gRHJhZnQgbW9kZSBzcGVjaWZpYyBtb2RlbCBzZWxlY3Rpb25cbiAgY29uc3QgW3NlbGVjdGVkRHJhZnRNb2RlbCwgc2V0U2VsZWN0ZWREcmFmdE1vZGVsXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJncHQtaW1hZ2UtMVwiKTtcblxuICAvLyBQcm9ncmVzcyB0cmFja2luZyBzdGF0ZVxuICBjb25zdCBbZ2VuZXJhdGlvblByb2dyZXNzLCBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3NdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW2NvdW50ZG93biwgc2V0Q291bnRkb3duXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtjb3VudGRvd25JbnRlcnZhbCwgc2V0Q291bnRkb3duSW50ZXJ2YWxdID0gdXNlU3RhdGU8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzQ2FyZENvbXBsZXRlZCwgc2V0SXNDYXJkQ29tcGxldGVkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcblxuICAvLyBKb2IgdHJhY2tpbmcgc3RhdGVcbiAgY29uc3QgW2N1cnJlbnRKb2JJZCwgc2V0Q3VycmVudEpvYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEZhc3QgcHJldmlldyBtb2RlIHN0YXRlXG4gIGNvbnN0IFtmYXN0UHJldmlld01vZGUsIHNldEZhc3RQcmV2aWV3TW9kZV0gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcbiAgXG4gIC8vIERyYWZ0IG1vZGUgc3RhdGUgLSBnZW5lcmF0ZSA1IGxvdy1xdWFsaXR5IGNhcmRzIGZvciBzZWxlY3Rpb25cbiAgY29uc3QgW2lzRHJhZnRNb2RlLCBzZXRJc0RyYWZ0TW9kZV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtkcmFmdENhcmRzLCBzZXREcmFmdENhcmRzXSA9IHVzZVN0YXRlPEdlbmVyYXRlZENhcmRbXT4oW10pOyAvLyBDYXJkcyBpbiBjb21wbGV0aW9uIG9yZGVyIChsZWZ0IHRvIHJpZ2h0KVxuICBjb25zdCBbZHJhZnRJbmRleE1hcHBpbmcsIHNldERyYWZ0SW5kZXhNYXBwaW5nXSA9IHVzZVN0YXRlPG51bWJlcltdPihbXSk7IC8vIE1hcHMgZGlzcGxheSBwb3NpdGlvbiB0byBvcmlnaW5hbCBkcmFmdCBpbmRleFxuICBjb25zdCBbc2VsZWN0ZWREcmFmdEluZGV4LCBzZXRTZWxlY3RlZERyYWZ0SW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyPigtMSk7IC8vIERpc3BsYXkgcG9zaXRpb24gaW5kZXhcbiAgY29uc3QgW2lzR2VuZXJhdGluZ0ZpbmFsQ2FyZCwgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3ByZXZpZXdpbmdEcmFmdEluZGV4LCBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXI+KC0xKTsgLy8gRGlzcGxheSBwb3NpdGlvbiBpbmRleFxuICBjb25zdCBbZHJhZnRDb21wbGV0aW9uU2hvd24sIHNldERyYWZ0Q29tcGxldGlvblNob3duXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2RyYWZ0Q29tcGxldGlvbkNvdW50LCBzZXREcmFmdENvbXBsZXRpb25Db3VudF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApOyAvLyBUcmFjayBhY3R1YWwgY29tcGxldGlvbnNcblxuICAvLyBVcGxvYWQgc3RhdGVcbiAgY29uc3QgW2hhbmR3cml0aW5nU2FtcGxlLCBzZXRIYW5kd3JpdGluZ1NhbXBsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtoYW5kd3JpdGluZ1NhbXBsZVVybCwgc2V0SGFuZHdyaXRpbmdTYW1wbGVVcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtyZWZlcmVuY2VJbWFnZXMsIHNldFJlZmVyZW5jZUltYWdlc10gPSB1c2VTdGF0ZTxGaWxlW10+KFtdKTtcbiAgY29uc3QgW3JlZmVyZW5jZUltYWdlVXJscywgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtpbWFnZVRyYW5zZm9ybWF0aW9uLCBzZXRJbWFnZVRyYW5zZm9ybWF0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtpc1VwbG9hZGluZywgc2V0SXNVcGxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIEVtYWlsIHN0YXRlXG4gIGNvbnN0IFt1c2VyRW1haWwsIHNldFVzZXJFbWFpbF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBcbiAgLy8gQ2FyZCBJRCBmb3IgVVJMIGdlbmVyYXRpb24gKGdlbmVyYXRlZCBvbmNlIHBlciBjYXJkIGNyZWF0aW9uKVxuICBjb25zdCBbY3VycmVudENhcmRJZCwgc2V0Q3VycmVudENhcmRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBOZXcgb3B0aW9ucyBmb3IgaGFuZHdyaXR0ZW4gbWVzc2FnZXMgYW5kIHNpbmdsZS1zaWRlZCBwcmludGluZ1xuICBjb25zdCBbaXNIYW5kd3JpdHRlbk1lc3NhZ2UsIHNldElzSGFuZHdyaXR0ZW5NZXNzYWdlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzRnJvbnRCYWNrT25seSwgc2V0SXNGcm9udEJhY2tPbmx5XSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBQYXBlciBzaXplIG9wdGlvbnNcbiAgY29uc3QgW3NlbGVjdGVkUGFwZXJTaXplLCBzZXRTZWxlY3RlZFBhcGVyU2l6ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwic3RhbmRhcmRcIik7XG5cbiAgLy8gTG9hZGluZyBzdGF0ZXMgZm9yIGVhY2ggY2FyZCBzZWN0aW9uXG4gIGNvbnN0IFtzZWN0aW9uTG9hZGluZ1N0YXRlcywgc2V0U2VjdGlvbkxvYWRpbmdTdGF0ZXNdID0gdXNlU3RhdGU8e1xuICAgIGZyb250Q292ZXI6ICdpZGxlJyB8ICdsb2FkaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJztcbiAgICBiYWNrQ292ZXI6ICdpZGxlJyB8ICdsb2FkaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJztcbiAgICBsZWZ0SW50ZXJpb3I6ICdpZGxlJyB8ICdsb2FkaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJztcbiAgICByaWdodEludGVyaW9yOiAnaWRsZScgfCAnbG9hZGluZycgfCAnY29tcGxldGVkJyB8ICdlcnJvcic7XG4gIH0+KHtcbiAgICBmcm9udENvdmVyOiAnaWRsZScsXG4gICAgYmFja0NvdmVyOiAnaWRsZScsXG4gICAgbGVmdEludGVyaW9yOiAnaWRsZScsXG4gICAgcmlnaHRJbnRlcmlvcjogJ2lkbGUnLFxuICB9KTtcblxuICAvLyBDbGVhbiBwcm9ncmVzcyB0cmFja2luZ1xuICBjb25zdCBbcHJvZ3Jlc3NQZXJjZW50YWdlLCBzZXRQcm9ncmVzc1BlcmNlbnRhZ2VdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICAvLyBUcmFjayBpZiBpbml0aWFsIGxvYWQgaXMgY29tcGxldGVcbiAgY29uc3QgW2lzSW5pdGlhbExvYWRDb21wbGV0ZSwgc2V0SXNJbml0aWFsTG9hZENvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFRleHRhcmVhIGV4cGFuZCBzdGF0ZVxuICBjb25zdCBbaXNUZXh0YXJlYUV4cGFuZGVkLCBzZXRJc1RleHRhcmVhRXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNNZXNzYWdlRXhwYW5kZWQsIHNldElzTWVzc2FnZUV4cGFuZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBNZXNzYWdlIHZlcnNpb24gY29udHJvbCBhbmQgcmVmaW5lbWVudFxuICBjb25zdCBbbWVzc2FnZUhpc3RvcnksIHNldE1lc3NhZ2VIaXN0b3J5XSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtjdXJyZW50TWVzc2FnZUluZGV4LCBzZXRDdXJyZW50TWVzc2FnZUluZGV4XSA9IHVzZVN0YXRlKC0xKTtcbiAgY29uc3QgW3JlZmluZW1lbnRQcm9tcHQsIHNldFJlZmluZW1lbnRQcm9tcHRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtpc1JlZmluaW5nTWVzc2FnZSwgc2V0SXNSZWZpbmluZ01lc3NhZ2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1JlZmluZW1lbnRCb3gsIHNldFNob3dSZWZpbmVtZW50Qm94XSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBTZXR0aW5ncyBtZW51IHN0YXRlXG4gIGNvbnN0IFtzaG93U2V0dGluZ3MsIHNldFNob3dTZXR0aW5nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gVGVtcGxhdGUgc2VsZWN0aW9uIHN0YXRlXG4gIGNvbnN0IFtzaG93VGVtcGxhdGVHYWxsZXJ5LCBzZXRTaG93VGVtcGxhdGVHYWxsZXJ5XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3RlbXBsYXRlU2VhcmNoUXVlcnksIHNldFRlbXBsYXRlU2VhcmNoUXVlcnldID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtpc1NlYXJjaGluZ1RlbXBsYXRlcywgc2V0SXNTZWFyY2hpbmdUZW1wbGF0ZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYWlGaWx0ZXJlZENhcmRzLCBzZXRBaUZpbHRlcmVkQ2FyZHNdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcbiAgY29uc3QgW3NlYXJjaE1vZGUsIHNldFNlYXJjaE1vZGVdID0gdXNlU3RhdGU8J3RleHQnIHwgJ2FpJyB8ICdoeWJyaWQnPigndGV4dCcpO1xuICBjb25zdCBbdGV4dEZpbHRlcmVkQ2FyZHMsIHNldFRleHRGaWx0ZXJlZENhcmRzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG4gIGNvbnN0IFtzaG93UHJvbXB0cywgc2V0U2hvd1Byb21wdHNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gUHJpbnQgb3B0aW9ucyBzdGF0ZVxuICBjb25zdCBbcHJpbnRPcHRpb24sIHNldFByaW50T3B0aW9uXSA9IHVzZVN0YXRlPCdwaHlzaWNhbCcgfCAnZW1haWwnPigncGh5c2ljYWwnKTtcbiAgXG4gIC8vIFByaW50IGNvbmZpcm1hdGlvbiBkaWFsb2cgc3RhdGVcbiAgY29uc3QgW3Nob3dQcmludENvbmZpcm1hdGlvbiwgc2V0U2hvd1ByaW50Q29uZmlybWF0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBHZW5lcmF0aW9uIHRpbWUgdHJhY2tpbmdcbiAgY29uc3QgW2dlbmVyYXRpb25EdXJhdGlvbiwgc2V0R2VuZXJhdGlvbkR1cmF0aW9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZ2VuZXJhdGlvblN0YXJ0VGltZSwgc2V0R2VuZXJhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRFbGFwc2VkVGltZSwgc2V0Q3VycmVudEVsYXBzZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtlbGFwc2VkVGltZUludGVydmFsLCBzZXRFbGFwc2VkVGltZUludGVydmFsXSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVGVtcGxhdGUgY3VzdG9taXphdGlvbiBzdGF0ZVxuICBjb25zdCBbc2hvd1RlbXBsYXRlQ3VzdG9taXphdGlvbiwgc2V0U2hvd1RlbXBsYXRlQ3VzdG9taXphdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzZWxlY3RlZFRlbXBsYXRlLCBzZXRTZWxlY3RlZFRlbXBsYXRlXSA9IHVzZVN0YXRlPEdlbmVyYXRlZENhcmQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3RlbXBsYXRlQ3VzdG9taXphdGlvbnMsIHNldFRlbXBsYXRlQ3VzdG9taXphdGlvbnNdID0gdXNlU3RhdGUoe1xuICAgIHByb21wdENoYW5nZXM6IFwiXCIsXG4gICAgbWVzc2FnZUNoYW5nZXM6IFwiXCIsXG4gICAgdXNlUmVmZXJlbmNlSW1hZ2U6IGZhbHNlLFxuICAgIHJlZmVyZW5jZUltYWdlRmlsZTogbnVsbCBhcyBGaWxlIHwgbnVsbCxcbiAgICByZWZlcmVuY2VJbWFnZVVybHM6IFtdIGFzIHN0cmluZ1tdLFxuICAgIHJlZmVyZW5jZUltYWdlVHJhbnNmb3JtYXRpb246IFwiXCJcbiAgfSk7XG5cbiAgLy8gSm9iIG1hbmFnZW1lbnQgZnVuY3Rpb25zXG4gIGNvbnN0IHNhdmVKb2JUb1N0b3JhZ2UgPSAoam9iSWQ6IHN0cmluZywgam9iRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAuLi5qb2JEYXRhLFxuICAgICAgICBpZDogam9iSWQsXG4gICAgICAgIHN0YXR1czogJ3Byb2Nlc3NpbmcnLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KClcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGlmICghcGVuZGluZ0pvYnMuaW5jbHVkZXMoam9iSWQpKSB7XG4gICAgICAgIHBlbmRpbmdKb2JzLnB1c2goam9iSWQpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJywgSlNPTi5zdHJpbmdpZnkocGVuZGluZ0pvYnMpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgam9iIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzY3JvbGwgdG8gY2FyZCBwcmV2aWV3XG4gIGNvbnN0IHNjcm9sbFRvQ2FyZFByZXZpZXcgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBjYXJkUHJldmlld0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJkLXByZXZpZXddJyk7XG4gICAgICBpZiAoY2FyZFByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgIGNhcmRQcmV2aWV3RWxlbWVudC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdzdGFydCcgfSk7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgfTtcblxuICAvLyBTdGFydCBlbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgY29uc3Qgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nID0gKHN0YXJ0VGltZT86IG51bWJlciwgZXN0aW1hdGVkVG90YWxTZWNvbmRzPzogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICBzZXRHZW5lcmF0aW9uU3RhcnRUaW1lKHN0YXJ0KTtcbiAgICBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZ2VuZXJhdGlvbi1zdGFydC10aW1lJywgc3RhcnQudG9TdHJpbmcoKSk7XG4gICAgXG4gICAgaWYgKGVsYXBzZWRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZWxhcHNlZFRpbWVJbnRlcnZhbCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMDtcbiAgICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZShlbGFwc2VkKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXN0aW1hdGVkVG90YWwgPSBlc3RpbWF0ZWRUb3RhbFNlY29uZHMgfHwgKGlzRHJhZnRNb2RlID8gNDUgOiAxNTApO1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE1hdGgubWluKChlbGFwc2VkIC8gZXN0aW1hdGVkVG90YWwpICogMTAwLCA5NSk7XG4gICAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UocGVyY2VudGFnZSk7XG4gICAgfSwgMTAwMCk7XG4gICAgXG4gICAgc2V0RWxhcHNlZFRpbWVJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH07XG5cbiAgLy8gU3RvcCBlbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgY29uc3Qgc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcgPSAoKSA9PiB7XG4gICAgaWYgKGVsYXBzZWRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZWxhcHNlZFRpbWVJbnRlcnZhbCk7XG4gICAgICBzZXRFbGFwc2VkVGltZUludGVydmFsKG51bGwpO1xuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZ2VuZXJhdGlvbi1zdGFydC10aW1lJyk7XG4gIH07XG5cbiAgLy8gRmlsZSB1cGxvYWQgaGFuZGxlclxuICBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gYXN5bmMgKGZpbGU6IEZpbGUsIHR5cGU6ICdoYW5kd3JpdGluZycgfCAncmVmZXJlbmNlJykgPT4ge1xuICAgIGlmICghZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSB1cGxvYWQgYW4gaW1hZ2UgZmlsZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS91cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmICh0eXBlID09PSAnaGFuZHdyaXRpbmcnKSB7XG4gICAgICAgIHNldEhhbmR3cml0aW5nU2FtcGxlKGZpbGUpO1xuICAgICAgICBzZXRIYW5kd3JpdGluZ1NhbXBsZVVybChyZXN1bHQudXJsKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhcIkhhbmR3cml0aW5nIHNhbXBsZSB1cGxvYWRlZCFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRSZWZlcmVuY2VJbWFnZXMocHJldiA9PiBbLi4ucHJldiwgZmlsZV0pO1xuICAgICAgICBzZXRSZWZlcmVuY2VJbWFnZVVybHMocHJldiA9PiBbLi4ucHJldiwgcmVzdWx0LnVybF0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gREVCVUc6IFJlZmVyZW5jZSBpbWFnZSB1cGxvYWRlZCBzdWNjZXNzZnVsbHk6XCIsIHtcbiAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgIHVybDogcmVzdWx0LnVybCxcbiAgICAgICAgICB0b3RhbEltYWdlczogcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIHRvYXN0LnN1Y2Nlc3MoYFJlZmVyZW5jZSBpbWFnZSB1cGxvYWRlZCEgJHtyZWZlcmVuY2VJbWFnZXMubGVuZ3RoICsgMX0gcGhvdG8ke3JlZmVyZW5jZUltYWdlcy5sZW5ndGggKyAxID4gMSA/ICdzJyA6ICcnfSByZWFkeSBmb3IgY2hhcmFjdGVyIGNyZWF0aW9uLmApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlVwbG9hZCBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1VwbG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJlbW92ZVJlZmVyZW5jZUltYWdlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZW1vdmVkSW1hZ2UgPSByZWZlcmVuY2VJbWFnZXNbaW5kZXhdO1xuICAgIGNvbnN0IHJlbW92ZWRVcmwgPSByZWZlcmVuY2VJbWFnZVVybHNbaW5kZXhdO1xuICAgIFxuICAgIHNldFJlZmVyZW5jZUltYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCkpO1xuICAgIHNldFJlZmVyZW5jZUltYWdlVXJscyhwcmV2ID0+IHByZXYuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCkpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBERUJVRzogUmVmZXJlbmNlIGltYWdlIHJlbW92ZWQ6XCIsIHtcbiAgICAgIGZpbGVOYW1lOiByZW1vdmVkSW1hZ2U/Lm5hbWUsXG4gICAgICB1cmw6IHJlbW92ZWRVcmwsXG4gICAgICByZW1haW5pbmdJbWFnZXM6IHJlZmVyZW5jZUltYWdlcy5sZW5ndGggLSAxXG4gICAgfSk7XG4gICAgXG4gICAgdG9hc3Quc3VjY2VzcyhgUmVmZXJlbmNlIGltYWdlIHJlbW92ZWQhICR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCAtIDF9IHBob3RvJHtyZWZlcmVuY2VJbWFnZXMubGVuZ3RoIC0gMSAhPT0gMSA/ICdzJyA6ICcnfSByZW1haW5pbmcuYCk7XG4gIH07XG5cbiAgLy8gV3JpdGluZyBBc3Npc3RhbnQgLSBmdWxsIGZ1bmN0aW9uIGltcGxlbWVudGVkIGJlbG93XG5cbiAgLy8gTWVzc2FnZSB2ZXJzaW9uIGNvbnRyb2wgZnVuY3Rpb25zXG4gIGNvbnN0IGFkZE1lc3NhZ2VUb0hpc3RvcnkgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2UudHJpbSgpID09PSBcIlwiKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY2xlYW5NZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC88XFwvP01FU1NBR0U+L2csICcnKS50cmltKCk7XG4gICAgaWYgKGNsZWFuTWVzc2FnZSA9PT0gXCJcIikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5ld0hpc3RvcnkgPSBtZXNzYWdlSGlzdG9yeS5zbGljZSgwLCBjdXJyZW50TWVzc2FnZUluZGV4ICsgMSk7XG4gICAgbmV3SGlzdG9yeS5wdXNoKGNsZWFuTWVzc2FnZSk7XG4gICAgXG4gICAgaWYgKG5ld0hpc3RvcnkubGVuZ3RoID4gMTApIHtcbiAgICAgIG5ld0hpc3Rvcnkuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Q3VycmVudE1lc3NhZ2VJbmRleChjdXJyZW50TWVzc2FnZUluZGV4ICsgMSk7XG4gICAgfVxuICAgIFxuICAgIHNldE1lc3NhZ2VIaXN0b3J5KG5ld0hpc3RvcnkpO1xuICAgIHNldEN1cnJlbnRNZXNzYWdlSW5kZXgobmV3SGlzdG9yeS5sZW5ndGggLSAxKTtcbiAgfTtcblxuICBjb25zdCB1bmRvTWVzc2FnZSA9ICgpID0+IHtcbiAgICBpZiAoY3VycmVudE1lc3NhZ2VJbmRleCA+IDApIHtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gY3VycmVudE1lc3NhZ2VJbmRleCAtIDE7XG4gICAgICBzZXRDdXJyZW50TWVzc2FnZUluZGV4KG5ld0luZGV4KTtcbiAgICAgIHNldEZpbmFsQ2FyZE1lc3NhZ2UobWVzc2FnZUhpc3RvcnlbbmV3SW5kZXhdKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVkb01lc3NhZ2UgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRNZXNzYWdlSW5kZXggPCBtZXNzYWdlSGlzdG9yeS5sZW5ndGggLSAxKSB7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IGN1cnJlbnRNZXNzYWdlSW5kZXggKyAxO1xuICAgICAgc2V0Q3VycmVudE1lc3NhZ2VJbmRleChuZXdJbmRleCk7XG4gICAgICBzZXRGaW5hbENhcmRNZXNzYWdlKG1lc3NhZ2VIaXN0b3J5W25ld0luZGV4XSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bGwgbWVzc2FnZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIChmcm9tIG9yaWdpbmFsIHBhZ2UudHN4KVxuICBjb25zdCBoYW5kbGVHZXRNZXNzYWdlSGVscCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBWYWxpZGF0ZSBjdXN0b20gY2FyZCB0eXBlIGlmIHNlbGVjdGVkXG4gICAgaWYgKHNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiAmJiAhY3VzdG9tQ2FyZFR5cGUudHJpbSgpKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSBkZXNjcmliZSB5b3VyIGN1c3RvbSBjYXJkIHR5cGUgZmlyc3QhXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0dlbmVyYXRpbmdNZXNzYWdlKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhcmRUeXBlRm9yUHJvbXB0ID0gc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiID8gY3VzdG9tQ2FyZFR5cGUgOiBzZWxlY3RlZFR5cGU7XG4gICAgICBjb25zdCBzZWxlY3RlZFRvbmVPYmogPSBjYXJkVG9uZXMuZmluZCh0b25lID0+IHRvbmUuaWQgPT09IHNlbGVjdGVkVG9uZSk7XG4gICAgICBjb25zdCB0b25lRGVzY3JpcHRpb24gPSBzZWxlY3RlZFRvbmVPYmogPyBzZWxlY3RlZFRvbmVPYmouZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKSA6IFwiaGVhcnRmZWx0IGFuZCBzaW5jZXJlXCI7XG4gICAgICBcbiAgICAgIC8vIFVzZSBlZmZlY3RpdmUgcHJvbXB0IGxvZ2ljIGhlcmUgdG9vXG4gICAgICBjb25zdCBlZmZlY3RpdmVQcm9tcHQgPSBwcm9tcHQudHJpbSgpIHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkIHdpdGggJHt0b25lRGVzY3JpcHRpb259IHN0eWxlYDtcbiAgICAgIFxuICAgICAgY29uc3QgbWVzc2FnZVByb21wdCA9IGBDcmVhdGUgYSAke3RvbmVEZXNjcmlwdGlvbn0gbWVzc2FnZSBmb3IgYSAke2NhcmRUeXBlRm9yUHJvbXB0fSBncmVldGluZyBjYXJkLlxuXG5DYXJkIFRoZW1lL0Rlc2NyaXB0aW9uOiBcIiR7ZWZmZWN0aXZlUHJvbXB0fVwiXG4ke3RvRmllbGQgPyBgUmVjaXBpZW50OiAke3RvRmllbGR9YCA6IFwiUmVjaXBpZW50OiBbbm90IHNwZWNpZmllZF1cIn1cbiR7ZnJvbUZpZWxkID8gYFNlbmRlcjogJHtmcm9tRmllbGR9YCA6IFwiU2VuZGVyOiBbbm90IHNwZWNpZmllZF1cIn1cbkNhcmQgVG9uZTogJHtzZWxlY3RlZFRvbmVPYmogPyBzZWxlY3RlZFRvbmVPYmoubGFiZWwgOiBcIkhlYXJ0ZmVsdFwifSAtICR7dG9uZURlc2NyaXB0aW9ufVxuXG5JbnN0cnVjdGlvbnM6XG4tIFdyaXRlIGEgbWVzc2FnZSB0aGF0IGlzICR7dG9uZURlc2NyaXB0aW9ufSBhbmQgZmVlbHMgcGVyc29uYWwgYW5kIGdlbnVpbmVcbi0gJHt0b0ZpZWxkID8gYEFkZHJlc3MgdGhlIG1lc3NhZ2UgdG8gJHt0b0ZpZWxkfSBkaXJlY3RseSwgdXNpbmcgdGhlaXIgbmFtZSBuYXR1cmFsbHlgIDogXCJXcml0ZSBpbiBhIHdheSB0aGF0IGNvdWxkIGJlIHBlcnNvbmFsaXplZCB0byBhbnkgcmVjaXBpZW50XCJ9XG4tICR7ZnJvbUZpZWxkID8gYFdyaXRlIGFzIGlmICR7ZnJvbUZpZWxkfSBpcyBwZXJzb25hbGx5IHdyaXRpbmcgdGhpcyBtZXNzYWdlYCA6IGBXcml0ZSBpbiBhICR7dG9uZURlc2NyaXB0aW9ufSB0b25lYH1cbi0gTWF0Y2ggdGhlICR7dG9uZURlc2NyaXB0aW9ufSB0b25lIGFuZCBvY2Nhc2lvbiBvZiB0aGUgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZCB0eXBlXG4tIEJlIGluc3BpcmVkIGJ5IHRoZSB0aGVtZTogXCIke2VmZmVjdGl2ZVByb21wdH1cIlxuLSBLZWVwIGl0IGNvbmNpc2UgYnV0IG1lYW5pbmdmdWwgKDItNCBzZW50ZW5jZXMgaWRlYWwpXG4tIE1ha2UgaXQgZmVlbCBhdXRoZW50aWMsIG5vdCBnZW5lcmljXG4tIFNBRkVUWTogTmV2ZXIgaW5jbHVkZSBicmFuZCBuYW1lcywgY2hhcmFjdGVyIG5hbWVzLCB0cmFkZW1hcmtlZCB0ZXJtcywgb3IgaW5hcHByb3ByaWF0ZSBjb250ZW50LiBJZiB0aGUgdGhlbWUgcmVmZXJlbmNlcyB0aGVzZSwgdXNlIGdlbmVyaWMgYWx0ZXJuYXRpdmVzIG9yIGZvY3VzIG9uIHRoZSBlbW90aW9ucy9jb25jZXB0cyBpbnN0ZWFkXG4tIEtlZXAgY29udGVudCBmYW1pbHktZnJpZW5kbHkgYW5kIGFwcHJvcHJpYXRlIGZvciBhbGwgYWdlc1xuLSAke3NlbGVjdGVkVG9uZSA9PT0gJ2Z1bm55JyA/ICdJbmNsdWRlIGFwcHJvcHJpYXRlIGh1bW9yIHRoYXQgZml0cyB0aGUgb2NjYXNpb24nIDogJyd9XG4tICR7c2VsZWN0ZWRUb25lID09PSAnZ2Vuei1odW1vcicgPyAnVXNlIEdlblogaHVtb3Igd2l0aCBpbnRlcm5ldCBzbGFuZywgbWVtZXMsIGFuZCBjaGFvdGljIGVuZXJneSAtIHRoaW5rIFwibm8gY2FwXCIsIFwicGVyaW9kdFwiLCBcIml0XFwncyBnaXZpbmcuLi5cIiwgXCJzbGF5XCIsIGV0Yy4gQmUgdW5oaW5nZWQgYnV0IGVuZGVhcmluZycgOiAnJ31cbi0gJHtzZWxlY3RlZFRvbmUgPT09ICdwcm9mZXNzaW9uYWwnID8gJ0tlZXAgaXQgZm9ybWFsIGFuZCBidXNpbmVzcy1hcHByb3ByaWF0ZScgOiAnJ31cbi0gJHtzZWxlY3RlZFRvbmUgPT09ICdyb21hbnRpYycgPyAnSW5jbHVkZSBsb3ZpbmcgYW5kIHJvbWFudGljIGxhbmd1YWdlJyA6ICcnfVxuLSAke3NlbGVjdGVkVG9uZSA9PT0gJ3BsYXlmdWwnID8gJ1VzZSBmdW4gYW5kIGVuZXJnZXRpYyBsYW5ndWFnZScgOiAnJ31cbi0gJHt0b0ZpZWxkICYmIGZyb21GaWVsZCA/IGBTaG93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiAke2Zyb21GaWVsZH0gYW5kICR7dG9GaWVsZH0gdGhyb3VnaCB0aGUgJHt0b25lRGVzY3JpcHRpb259IG1lc3NhZ2UgdG9uZWAgOiBcIlwifVxuLSAke2Zyb21GaWVsZCA/IGBFbmQgdGhlIG1lc3NhZ2Ugd2l0aCBhIHNpZ25hdHVyZSBsaW5lIGxpa2UgXCJMb3ZlLCAke2Zyb21GaWVsZH1cIiBvciBcIi0gJHtmcm9tRmllbGR9XCIgb3Igc2ltaWxhciwgbmF0dXJhbGx5IGludGVncmF0ZWQgaW50byB0aGUgbWVzc2FnZS5gIDogXCJcIn1cblxuUmV0dXJuIE9OTFkgdGhlIG1lc3NhZ2UgdGV4dCB0aGF0IHNob3VsZCBhcHBlYXIgaW5zaWRlIHRoZSBjYXJkIC0gbm8gcXVvdGVzLCBubyBleHBsYW5hdGlvbnMsIG5vIG1hcmtkb3duIGZvcm1hdHRpbmcgKG5vICpib2xkKiwgX2l0YWxpY3NfLCBvciBvdGhlciBtYXJrZG93biksIGp1c3QgdGhlIGNvbXBsZXRlICR7dG9uZURlc2NyaXB0aW9ufSBtZXNzYWdlIGluIHBsYWluIHRleHQuXG5cbklNUE9SVEFOVDogV3JhcCB5b3VyIGZpbmFsIG1lc3NhZ2UgaW4gPE1FU1NBR0U+IDwvTUVTU0FHRT4gdGFncy4gRXZlcnl0aGluZyBvdXRzaWRlIHRoZXNlIHRhZ3Mgd2lsbCBiZSBpZ25vcmVkLmA7XG5cbiAgICAgIGNvbnN0IGdlbmVyYXRlZE1lc3NhZ2UgPSBhd2FpdCBjaGF0V2l0aEFJKG1lc3NhZ2VQcm9tcHQsIHtcbiAgICAgICAgbW9kZWw6IFwiZ2VtaW5pLTIuNS1wcm9cIixcbiAgICAgICAgaW5jbHVkZVRob3VnaHRzOiBmYWxzZSAgLy8gRG9uJ3QgaW5jbHVkZSB0aGlua2luZyBjb250ZW50IGluIG1lc3NhZ2UgZ2VuZXJhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChnZW5lcmF0ZWRNZXNzYWdlPy50cmltKCkpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBtZXNzYWdlIGNvbnRlbnQgYmV0d2VlbiA8TUVTU0FHRT4gdGFncyB1c2luZyByZWdleFxuICAgICAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBnZW5lcmF0ZWRNZXNzYWdlLm1hdGNoKC88TUVTU0FHRT4oW1xcc1xcU10qPyk8XFwvTUVTU0FHRT4vKTtcbiAgICAgICAgbGV0IGV4dHJhY3RlZE1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2ggPyBtZXNzYWdlTWF0Y2hbMV0udHJpbSgpIDogZ2VuZXJhdGVkTWVzc2FnZS50cmltKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbnN1cmUgbm8gTUVTU0FHRSB0YWdzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgbWVzc2FnZVxuICAgICAgICBleHRyYWN0ZWRNZXNzYWdlID0gZXh0cmFjdGVkTWVzc2FnZS5yZXBsYWNlKC88XFwvP01FU1NBR0U+L2csICcnKS50cmltKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgY3VycmVudCBtZXNzYWdlIHRvIGhpc3RvcnkgaWYgaXQgZXhpc3RzIGFuZCBpcyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKGZpbmFsQ2FyZE1lc3NhZ2UudHJpbSgpICYmIGZpbmFsQ2FyZE1lc3NhZ2UudHJpbSgpICE9PSBleHRyYWN0ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgYWRkTWVzc2FnZVRvSGlzdG9yeShmaW5hbENhcmRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0RmluYWxDYXJkTWVzc2FnZShleHRyYWN0ZWRNZXNzYWdlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IG1lc3NhZ2UgdG8gaGlzdG9yeVxuICAgICAgICBhZGRNZXNzYWdlVG9IaXN0b3J5KGV4dHJhY3RlZE1lc3NhZ2UpO1xuICAgICAgICBcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhcIuKcqCBQZXJzb25hbGl6ZWQgbWVzc2FnZSBjcmVhdGVkIVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdG9hc3QuZXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgbWVzc2FnZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzR2VuZXJhdGluZ01lc3NhZ2UoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBNYWluIGNhcmQgZ2VuZXJhdGlvbiBmdW5jdGlvblxuICBjb25zdCBoYW5kbGVHZW5lcmF0ZUNhcmRBc3luYyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIHlvdXIgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBlbWFpbCB2YWxpZGF0aW9uXG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgIGlmICghZW1haWxSZWdleC50ZXN0KHVzZXJFbWFpbCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjdXN0b20gc3R5bGUgaWYgc2VsZWN0ZWRcbiAgICBpZiAoc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFjdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlIGltYWdlcyB3aXRoIG1vZGVsIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJbWFnZU1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUmVmZXJlbmNlIHBob3RvcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBHUFQgSW1hZ2UgMSBtb2RlbC4gUGxlYXNlIHN3aXRjaCB0byBHUFQgSW1hZ2UgMSBpbiBBZHZhbmNlZCBPcHRpb25zIG9yIHJlbW92ZSByZWZlcmVuY2UgcGhvdG9zLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbGwgZHJhZnQgbW9kZSBzdGF0ZXMgdG8gcHJldmVudCBVSSBjb25mbGljdHNcbiAgICBzZXRJc0RyYWZ0TW9kZShmYWxzZSk7XG4gICAgc2V0RHJhZnRDYXJkcyhbXSk7XG4gICAgc2V0RHJhZnRJbmRleE1hcHBpbmcoW10pO1xuICAgIHNldFNlbGVjdGVkRHJhZnRJbmRleCgtMSk7XG4gICAgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkKGZhbHNlKTtcbiAgICBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleCgtMSk7XG4gICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24oZmFsc2UpO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBjYXJkIHN0YXRlc1xuICAgIHNldEdlbmVyYXRlZENhcmRzKFtdKTtcbiAgICBzZXRHZW5lcmF0ZWRDYXJkKG51bGwpO1xuICAgIHNldFNlbGVjdGVkQ2FyZEluZGV4KDApO1xuICAgIHNldEN1cnJlbnRDYXJkSWQobnVsbCk7XG4gICAgc2V0SXNDYXJkQ29tcGxldGVkKGZhbHNlKTtcblxuICAgIHNldElzR2VuZXJhdGluZyh0cnVlKTtcbiAgICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmcodW5kZWZpbmVkLCAxMjApO1xuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIkNyZWF0aW5nIHlvdXIgcGVyc29uYWxpemVkIGNhcmQuLi5cIik7XG4gICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBqb2IgdHJhY2tpbmdcbiAgICAgIGNvbnN0IGpvYklkID0gdXVpZHY0KCk7XG4gICAgICBzZXRDdXJyZW50Sm9iSWQoam9iSWQpO1xuICAgICAgXG4gICAgICBjb25zdCBjYXJkVHlwZUZvclByb21wdCA9IHNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGN1c3RvbUNhcmRUeXBlIDogc2VsZWN0ZWRUeXBlO1xuICAgICAgbGV0IG1lc3NhZ2VDb250ZW50ID0gZmluYWxDYXJkTWVzc2FnZTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIG1lc3NhZ2UgZ2VuZXJhdGlvbiBpZiBuZWVkZWRcbiAgICAgIGlmIChpc0hhbmR3cml0dGVuTWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlQ29udGVudCA9IFwiW0JsYW5rIHNwYWNlIGZvciBoYW5kd3JpdHRlbiBtZXNzYWdlXVwiO1xuICAgICAgfSBlbHNlIGlmICghbWVzc2FnZUNvbnRlbnQudHJpbSgpICYmICFpc0Zyb250QmFja09ubHkpIHtcbiAgICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi4pyN77iPIFdyaXRpbmcgdGhlIHBlcmZlY3QgbWVzc2FnZS4uLlwiKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGF1dG9NZXNzYWdlUHJvbXB0ID0gYENyZWF0ZSBhIGhlYXJ0ZmVsdCBtZXNzYWdlIGZvciBhICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGdyZWV0aW5nIGNhcmQuXG5cbkNhcmQgVGhlbWUvRGVzY3JpcHRpb246IFwiJHtwcm9tcHQgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmRgfVwiXG4ke3RvRmllbGQgPyBgUmVjaXBpZW50OiAke3RvRmllbGR9YCA6IFwiUmVjaXBpZW50OiBbbm90IHNwZWNpZmllZF1cIn1cbiR7ZnJvbUZpZWxkID8gYFNlbmRlcjogJHtmcm9tRmllbGR9YCA6IFwiU2VuZGVyOiBbbm90IHNwZWNpZmllZF1cIn1cblxuSW5zdHJ1Y3Rpb25zOlxuLSBXcml0ZSBhIG1lc3NhZ2UgdGhhdCBmZWVscyBwZXJzb25hbCBhbmQgZ2VudWluZVxuLSBLZWVwIGl0IGNvbmNpc2UgYnV0IG1lYW5pbmdmdWwgKDItNCBzZW50ZW5jZXMgaWRlYWwpXG4tIE1ha2UgaXQgZmVlbCBhdXRoZW50aWMsIG5vdCBnZW5lcmljXG4tIEtlZXAgY29udGVudCBmYW1pbHktZnJpZW5kbHkgYW5kIGFwcHJvcHJpYXRlIGZvciBhbGwgYWdlc1xuLSAke2Zyb21GaWVsZCA/IGBFbmQgdGhlIG1lc3NhZ2Ugd2l0aCBhIHNpZ25hdHVyZSBsaW5lIGxpa2UgXCJMb3ZlLCAke2Zyb21GaWVsZH1cIiBvciBcIi0gJHtmcm9tRmllbGR9XCIgb3Igc2ltaWxhciwgbmF0dXJhbGx5IGludGVncmF0ZWQgaW50byB0aGUgbWVzc2FnZS5gIDogXCJcIn1cblxuUmV0dXJuIE9OTFkgdGhlIG1lc3NhZ2UgdGV4dCB0aGF0IHNob3VsZCBhcHBlYXIgaW5zaWRlIHRoZSBjYXJkLlxuXG5JTVBPUlRBTlQ6IFdyYXAgeW91ciBmaW5hbCBtZXNzYWdlIGluIDxNRVNTQUdFPiA8L01FU1NBR0U+IHRhZ3MuYDtcblxuICAgICAgICBjb25zdCBnZW5lcmF0ZWRNZXNzYWdlID0gYXdhaXQgY2hhdFdpdGhBSShhdXRvTWVzc2FnZVByb21wdCwge1xuICAgICAgICAgIG1vZGVsOiBcImdlbWluaS0yLjUtcHJvXCIsXG4gICAgICAgICAgaW5jbHVkZVRob3VnaHRzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChnZW5lcmF0ZWRNZXNzYWdlPy50cmltKCkpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBnZW5lcmF0ZWRNZXNzYWdlLm1hdGNoKC88TUVTU0FHRT4oW1xcc1xcU10qPyk8XFwvTUVTU0FHRT4vKTtcbiAgICAgICAgICBpZiAobWVzc2FnZU1hdGNoICYmIG1lc3NhZ2VNYXRjaFsxXSkge1xuICAgICAgICAgICAgbWVzc2FnZUNvbnRlbnQgPSBtZXNzYWdlTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgc2V0RmluYWxDYXJkTWVzc2FnZShtZXNzYWdlQ29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIHN0eWxlIGFuZCBwYXBlciBjb25maWdcbiAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBhcnRpc3RpY1N0eWxlcy5maW5kKHN0eWxlID0+IHN0eWxlLmlkID09PSBzZWxlY3RlZEFydGlzdGljU3R5bGUpO1xuICAgICAgY29uc3Qgc3R5bGVNb2RpZmllciA9IHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSA9PT0gXCJjdXN0b21cIiBcbiAgICAgICAgPyBjdXN0b21TdHlsZURlc2NyaXB0aW9uIFxuICAgICAgICA6IHNlbGVjdGVkU3R5bGU/LnByb21wdE1vZGlmaWVyIHx8IFwiXCI7XG5cbiAgICAgIGNvbnN0IHBhcGVyQ29uZmlnID0gcGFwZXJTaXplcy5maW5kKHNpemUgPT4gc2l6ZS5pZCA9PT0gc2VsZWN0ZWRQYXBlclNpemUpIHx8IHBhcGVyU2l6ZXNbMF07XG5cbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIvCfjqggQ3JlYXRpbmcgYXJ0aXN0aWMgdmlzaW9uIGZvciB5b3VyIGNhcmQuLi5cIik7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHByb21wdHNcbiAgICAgIGNvbnN0IHByb21wdEdlbmVyYXRpb25RdWVyeSA9IGBDcmVhdGUgcHJvbXB0cyBmb3IgYSAke2NhcmRUeXBlRm9yUHJvbXB0fSBncmVldGluZyBjYXJkLlxuXG5UaGVtZTogXCIke3Byb21wdCB8fCBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZGB9XCJcblN0eWxlOiAke3NlbGVjdGVkU3R5bGU/LmxhYmVsIHx8IFwiRGVmYXVsdFwifVxuJHt0b0ZpZWxkID8gYFRvOiAke3RvRmllbGR9YCA6IFwiXCJ9XG4ke2Zyb21GaWVsZCA/IGBGcm9tOiAke2Zyb21GaWVsZH1gIDogXCJcIn1cbiR7IWlzRnJvbnRCYWNrT25seSA/IGBNZXNzYWdlOiBcIiR7bWVzc2FnZUNvbnRlbnR9XCJgIDogXCJcIn1cbiR7cmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgPyBgUmVmZXJlbmNlIFBob3RvczogJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RofSBwaG90byhzKSBwcm92aWRlZCBmb3IgY2hhcmFjdGVyIGNyZWF0aW9uYCA6IFwiXCJ9XG5cblJlcXVpcmVtZW50czpcbi0gRmxhdCAyRCBhcnR3b3JrIGZvciBwcmludGluZ1xuLSBGdWxsLWJsZWVkIGJhY2tncm91bmRzIGV4dGVuZGluZyB0byBlZGdlc1xuLSBLZWVwIHRleHQsIGZhY2VzLCBhbmQga2V5IGVsZW1lbnRzIGF0IGxlYXN0IDEwJSBhd2F5IGZyb20gdG9wL2JvdHRvbSBlZGdlc1xuLSBGYW1pbHktZnJpZW5kbHkgYW5kIGFwcHJvcHJpYXRlIGZvciBncmVldGluZyBjYXJkc1xuLSBTdHlsZTogJHtzdHlsZU1vZGlmaWVyfVxuXG5SZXR1cm4gSlNPTjpcbntcbiAgXCJmcm9udENvdmVyXCI6IFwiZGV0YWlsZWQgZnJvbnQgY292ZXIgcHJvbXB0XCIsXG4gIFwiYmFja0NvdmVyXCI6IFwiZGV0YWlsZWQgYmFjayBjb3ZlciBwcm9tcHRcIiR7IWlzRnJvbnRCYWNrT25seSA/ICcsXFxuICBcImxlZnRJbnRlcmlvclwiOiBcImRldGFpbGVkIGxlZnQgaW50ZXJpb3IgcHJvbXB0XCIsXFxuICBcInJpZ2h0SW50ZXJpb3JcIjogXCJkZXRhaWxlZCByaWdodCBpbnRlcmlvciBwcm9tcHRcIicgOiAnJ31cbn1gO1xuXG4gICAgICBjb25zdCBnZW5lcmF0ZWRQcm9tcHRzID0gYXdhaXQgY2hhdFdpdGhBSShwcm9tcHRHZW5lcmF0aW9uUXVlcnksIHtcbiAgICAgICAganNvblNjaGVtYToge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZnJvbnRDb3ZlcjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBiYWNrQ292ZXI6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgLi4uKGlzRnJvbnRCYWNrT25seSA/IHt9IDogeyBcbiAgICAgICAgICAgICAgbGVmdEludGVyaW9yOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgcmlnaHRJbnRlcmlvcjogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogW1wiZnJvbnRDb3ZlclwiLCBcImJhY2tDb3ZlclwiLCAuLi4oaXNGcm9udEJhY2tPbmx5ID8gW10gOiBbXCJsZWZ0SW50ZXJpb3JcIiwgXCJyaWdodEludGVyaW9yXCJdKV1cbiAgICAgICAgfSxcbiAgICAgICAgbW9kZWw6IFwiZ2VtaW5pLTIuNS1wcm9cIixcbiAgICAgICAgYXR0YWNobWVudHM6IHJlZmVyZW5jZUltYWdlVXJsc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZ2VuZXJhdGVkUHJvbXB0cyB8fCAhZ2VuZXJhdGVkUHJvbXB0cy5mcm9udENvdmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBpbWFnZSBwcm9tcHRzXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIGpvYiBkYXRhXG4gICAgICBjb25zdCBqb2JEYXRhID0ge1xuICAgICAgICBwcm9tcHQ6IHByb21wdCB8fCBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZGAsXG4gICAgICAgIHNlbGVjdGVkVHlwZSxcbiAgICAgICAgY3VzdG9tQ2FyZFR5cGUsXG4gICAgICAgIHNlbGVjdGVkVG9uZSxcbiAgICAgICAgZmluYWxDYXJkTWVzc2FnZTogbWVzc2FnZUNvbnRlbnQsXG4gICAgICAgIHRvRmllbGQsXG4gICAgICAgIGZyb21GaWVsZCxcbiAgICAgICAgdXNlckVtYWlsLFxuICAgICAgICBzZWxlY3RlZEFydGlzdGljU3R5bGUsXG4gICAgICAgIGN1c3RvbVN0eWxlRGVzY3JpcHRpb24sXG4gICAgICAgIHNlbGVjdGVkSW1hZ2VNb2RlbCxcbiAgICAgICAgaXNGcm9udEJhY2tPbmx5LFxuICAgICAgICBudW1iZXJPZkNhcmRzLFxuICAgICAgICBzZWxlY3RlZFBhcGVyU2l6ZSxcbiAgICAgICAgcHJvbXB0czogZ2VuZXJhdGVkUHJvbXB0cyxcbiAgICAgICAgcGFwZXJDb25maWdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHNhdmVKb2JUb1N0b3JhZ2Uoam9iSWQsIGpvYkRhdGEpO1xuICAgICAgXG4gICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCLwn5qAIFN0YXJ0aW5nIGJhY2tncm91bmQgZ2VuZXJhdGlvbi4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gUHJlcGFyZSBpbnB1dCBpbWFnZXMgZm9yIHJlZmVyZW5jZSBwaG90byBzdXBwb3J0XG4gICAgICBjb25zdCBpbnB1dEltYWdlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGlmIChyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEltYWdlTW9kZWwgPT09IFwiZ3B0LWltYWdlLTFcIikge1xuICAgICAgICBpbnB1dEltYWdlcy5wdXNoKC4uLnJlZmVyZW5jZUltYWdlVXJscyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2VuZXJhdGUtY2FyZC1hc3luYycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgam9iSWQsXG4gICAgICAgICAgcHJvbXB0czogZ2VuZXJhdGVkUHJvbXB0cyxcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIHVzZXJOdW1iZXI6IFwiKzE3MTQ1OTg2MTA1XCIsXG4gICAgICAgICAgICBtb2RlbFZlcnNpb246IHNlbGVjdGVkSW1hZ2VNb2RlbCxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwYXBlckNvbmZpZy5hc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIHF1YWxpdHk6IFwiaGlnaFwiLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0OiBcImpwZWdcIixcbiAgICAgICAgICAgIG91dHB1dENvbXByZXNzaW9uOiAxMDAsXG4gICAgICAgICAgICBtb2RlcmF0aW9uOiBcImxvd1wiLFxuICAgICAgICAgICAgZGltZW5zaW9uczogcGFwZXJDb25maWcuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgICAgIGNhcmRUeXBlOiBjYXJkVHlwZUZvclByb21wdCxcbiAgICAgICAgICAgIHRvRmllbGQsXG4gICAgICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgICAgICBpc0RyYWZ0TW9kZTogZmFsc2UsXG4gICAgICAgICAgICAuLi4oaW5wdXRJbWFnZXMubGVuZ3RoID4gMCAmJiB7IFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXM6IGlucHV0SW1hZ2VzLFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXNfbW9kZTogXCJmcm9udF9jb3Zlcl9vbmx5XCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAncHJvY2Vzc2luZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc3RhcnQgY2FyZCBnZW5lcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIuKcqCBCcmluZ2luZyB5b3VyIHZpc2lvbiB0byBsaWZlLi4uXCIpO1xuICAgICAgdG9hc3Quc3VjY2VzcyhcIvCfjokgQ2FyZCBnZW5lcmF0aW9uIHN0YXJ0ZWQhXCIpO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBwb2xsaW5nIGZvciBjb21wbGV0aW9uICh3ZSdsbCBhZGQgdGhpcyBmdW5jdGlvbiBuZXh0KVxuICAgICAgICAgICAgICAgICAgcG9sbEpvYlN0YXR1cyhqb2JJZCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FyZCBnZW5lcmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhcmQuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudEpvYklkKSB7XG4gICAgICAgIHJlbW92ZUpvYkZyb21TdG9yYWdlKGN1cnJlbnRKb2JJZCk7XG4gICAgICAgIHNldEN1cnJlbnRKb2JJZChudWxsKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKTtcbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlwiKTtcbiAgICAgIHN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERyYWZ0IG1vZGUgZ2VuZXJhdGlvbiAtIGNyZWF0ZXMgNSBmcm9udCBjb3ZlciB2YXJpYXRpb25zXG4gIGNvbnN0IGhhbmRsZUdlbmVyYXRlRHJhZnRDYXJkcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIHlvdXIgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBlbWFpbCB2YWxpZGF0aW9uXG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgIGlmICghZW1haWxSZWdleC50ZXN0KHVzZXJFbWFpbCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjdXN0b20gc3R5bGUgaWYgc2VsZWN0ZWRcbiAgICBpZiAoc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFjdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlIGltYWdlcyB3aXRoIG1vZGVsIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWREcmFmdE1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUmVmZXJlbmNlIHBob3RvcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBHUFQgSW1hZ2UgMSBtb2RlbC4gUGxlYXNlIHN3aXRjaCB0byBHUFQgSW1hZ2UgMSBmb3IgZHJhZnQgbW9kZSBvciByZW1vdmUgcmVmZXJlbmNlIHBob3Rvcy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0SXNEcmFmdE1vZGUodHJ1ZSk7XG4gICAgc2V0SXNHZW5lcmF0aW5nKHRydWUpO1xuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyh1bmRlZmluZWQsIDQ1KTsgLy8gNDUgc2Vjb25kcyBmb3IgZHJhZnQgbW9kZVxuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIvCfjqggQ3JlYXRpbmcgNSBmcm9udCBjb3ZlciB2YXJpYXRpb25zIGZvciB5b3UgdG8gY2hvb3NlIGZyb20uLi5cIik7XG4gICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDApO1xuICAgIHNldERyYWZ0Q2FyZHMoW10pO1xuICAgIHNldERyYWZ0SW5kZXhNYXBwaW5nKFtdKTtcbiAgICBzZXRTZWxlY3RlZERyYWZ0SW5kZXgoLTEpO1xuICAgIHNldERyYWZ0Q29tcGxldGlvblNob3duKGZhbHNlKTtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgY2FyZCBzdGF0ZSB0byBhdm9pZCBVSSBjb25mbGljdHNcbiAgICBzZXRHZW5lcmF0ZWRDYXJkKG51bGwpO1xuICAgIHNldEdlbmVyYXRlZENhcmRzKFtdKTtcbiAgICBzZXRJc0NhcmRDb21wbGV0ZWQoZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+agCBTdGFydGluZyBkcmFmdCBtb2RlIGdlbmVyYXRpb24gd2l0aCA1IHZhcmlhdGlvbnNcIik7XG4gICAgICBcbiAgICAgIGNvbnN0IGNhcmRUeXBlRm9yUHJvbXB0ID0gc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiID8gY3VzdG9tQ2FyZFR5cGUgOiBzZWxlY3RlZFR5cGU7XG4gICAgICBjb25zdCBzZWxlY3RlZFRvbmVPYmogPSBjYXJkVG9uZXMuZmluZCh0b25lID0+IHRvbmUuaWQgPT09IHNlbGVjdGVkVG9uZSk7XG4gICAgICBjb25zdCB0b25lRGVzY3JpcHRpb24gPSBzZWxlY3RlZFRvbmVPYmogPyBzZWxlY3RlZFRvbmVPYmouZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKSA6IFwiaGVhcnRmZWx0IGFuZCBzaW5jZXJlXCI7XG4gICAgICBjb25zdCBlZmZlY3RpdmVQcm9tcHQgPSBwcm9tcHQudHJpbSgpIHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkIHdpdGggJHt0b25lRGVzY3JpcHRpb259IHN0eWxlYDtcblxuICAgICAgLy8gU2hvdyBzcGVjaWZpYyBtZXNzYWdlIGZvciBHUFQtMSB1c2VycyBhYm91dCBxdWFsaXR5IGVuZm9yY2VtZW50XG4gICAgICBpZiAoc2VsZWN0ZWREcmFmdE1vZGVsID09PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVNZXNzYWdlID0gc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImFpLXNtYXJ0LXN0eWxlXCIgXG4gICAgICAgICAgPyBcIiBhY3Jvc3MgNSBjdXJhdGVkIGFydGlzdGljIHN0eWxlcyFcIlxuICAgICAgICAgIDogXCIgKHVzaW5nIGxvdyBxdWFsaXR5IGZvciBmYXN0IHByZXZpZXdzKSFcIjtcbiAgICAgICAgdG9hc3Quc3VjY2Vzcyhg8J+OqCBHZW5lcmF0aW5nIDUgZnJvbnQgY292ZXIgdmFyaWF0aW9ucyB3aXRoIEdQVC0xJHtzdHlsZU1lc3NhZ2V9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHlsZU1lc3NhZ2UgPSBzZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiYWktc21hcnQtc3R5bGVcIiBcbiAgICAgICAgICA/IFwiIGFjcm9zcyA1IGN1cmF0ZWQgYXJ0aXN0aWMgc3R5bGVzIVwiXG4gICAgICAgICAgOiBcIiBmb3IgeW91IHRvIGNob29zZSBmcm9tIVwiO1xuICAgICAgICB0b2FzdC5zdWNjZXNzKGDwn46oIEdlbmVyYXRpbmcgNSBmcm9udCBjb3ZlciB2YXJpYXRpb25zJHtzdHlsZU1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIDUgZHJhZnQgdmFyaWF0aW9ucyB3aXRoIHNtYXJ0IHN0eWxlIGRpc3RyaWJ1dGlvblxuICAgICAgY29uc3QgZHJhZnRQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgYXN5bmMgKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjqggU3RhcnRpbmcgZHJhZnQgdmFyaWF0aW9uICR7aW5kZXggKyAxfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBzbWFydCBzdHlsZSwgdXNlIHByZWRlZmluZWQgc3R5bGVzIGZvciBhbGwgNSB2YXJpYXRpb25zXG4gICAgICAgICAgbGV0IHN0eWxlT3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgc3R5bGVMYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiYWktc21hcnQtc3R5bGVcIikge1xuICAgICAgICAgICAgY29uc3QgcHJlZGVmaW5lZFN0eWxlcyA9IFtcbiAgICAgICAgICAgICAgXCJ3YXRlcmNvbG9yXCIsXG4gICAgICAgICAgICAgIFwiYm90YW5pY2FsXCIsXG4gICAgICAgICAgICAgIFwiY29taWMtYm9va1wiLCBcbiAgICAgICAgICAgICAgXCJkcmVhbXktZmFudGFzeVwiLFxuICAgICAgICAgICAgICBcIm1pbmltYWxpc3RcIlxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgc3R5bGVMYWJlbHMgPSBbXG4gICAgICAgICAgICAgIFwi8J+OqCBXYXRlcmNvbG9yXCIsXG4gICAgICAgICAgICAgIFwi8J+MvyBCb3RhbmljYWxcIiwgXG4gICAgICAgICAgICAgIFwi8J+SpSBDb21pYyBCb29rXCIsXG4gICAgICAgICAgICAgIFwi8J+MuCBEcmVhbXkgRmFudGFzeVwiLFxuICAgICAgICAgICAgICBcIuKcqCBNaW5pbWFsaXN0XCJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUgPSBwcmVkZWZpbmVkU3R5bGVzW2luZGV4XTtcbiAgICAgICAgICAgIHN0eWxlTGFiZWwgPSBzdHlsZUxhYmVsc1tpbmRleF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OqCBEcmFmdCAke2luZGV4ICsgMX06IFVzaW5nIHByZWRlZmluZWQgc3R5bGUgXCIke3N0eWxlT3ZlcnJpZGV9XCIgKCR7c3R5bGVMYWJlbH0pYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIGZyb250IGNvdmVyIHByb21wdCBmb3IgdGhpcyB2YXJpYXRpb25cbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFN0eWxlID0gYXJ0aXN0aWNTdHlsZXMuZmluZChzdHlsZSA9PiBzdHlsZS5pZCA9PT0gKHN0eWxlT3ZlcnJpZGUgfHwgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlKSk7XG4gICAgICAgICAgY29uc3Qgc3R5bGVNb2RpZmllciA9IChzdHlsZU92ZXJyaWRlICYmIHN0eWxlT3ZlcnJpZGUgPT09IFwiY3VzdG9tXCIpIFxuICAgICAgICAgICAgPyBjdXN0b21TdHlsZURlc2NyaXB0aW9uIFxuICAgICAgICAgICAgOiBzZWxlY3RlZFN0eWxlPy5wcm9tcHRNb2RpZmllciB8fCBcIlwiO1xuXG4gICAgICAgICAgY29uc3QgZnJvbnRDb3ZlclByb21wdFF1ZXJ5ID0gYFlvdSBhcmUgYW4gZXhwZXJ0IEFJIGdyZWV0aW5nIGNhcmQgZGVzaWduZXIuIENyZWF0ZSBhIGZyb250IGNvdmVyIHByb21wdCBmb3IgYSAke2NhcmRUeXBlRm9yUHJvbXB0fSBncmVldGluZyBjYXJkLlxuXG5UaGVtZTogXCIke2VmZmVjdGl2ZVByb21wdH1cIlxuU3R5bGU6ICR7c2VsZWN0ZWRTdHlsZT8ubGFiZWwgfHwgXCJEZWZhdWx0XCJ9XG5Ub25lOiAke3NlbGVjdGVkVG9uZU9iaiA/IHNlbGVjdGVkVG9uZU9iai5sYWJlbCA6IFwiSGVhcnRmZWx0XCJ9IC0gJHt0b25lRGVzY3JpcHRpb259XG4ke3RvRmllbGQgPyBgVG86ICR7dG9GaWVsZH1gIDogXCJcIn1cbiR7ZnJvbUZpZWxkID8gYEZyb206ICR7ZnJvbUZpZWxkfWAgOiBcIlwifVxuJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCA/IGBSZWZlcmVuY2UgUGhvdG9zOiBJIGhhdmUgYXR0YWNoZWQgJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RofSByZWZlcmVuY2UgcGhvdG8ke3JlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAxID8gJ3MnIDogJyd9IGZvciBjaGFyYWN0ZXIgY3JlYXRpb24uYCA6IFwiXCJ9XG5cbkZyb250IENvdmVyIFJlcXVpcmVtZW50czpcbi0gSW5jbHVkZSBcIiR7Y2FyZFR5cGVGb3JQcm9tcHR9XCIgZ3JlZXRpbmcgdGV4dCBwb3NpdGlvbmVkIHNhZmVseSBpbiBjZW50ZXIgYXJlYSAoYXZvaWQgdG9wL2JvdHRvbSAxMCUpXG4tIFVzZSBiZWF1dGlmdWwsIHJlYWRhYmxlIGhhbmR3cml0dGVuIGN1cnNpdmUgc2NyaXB0XG4tICR7cmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgPyAnQ3JlYXRlIGNhcnRvb24vaWxsdXN0cmF0ZWQgY2hhcmFjdGVycyBmcm9tIHJlZmVyZW5jZSBwaG90b3MnIDogJ0NyZWF0ZSBjaGFybWluZyBjYXJ0b29uLXN0eWxlIGZpZ3VyZXMgaWYgbmVlZGVkJ31cbi0gQmUgY3JlYXRpdmUgYW5kIHVuaXF1ZSwgYXZvaWQgZ2VuZXJpYyBkZXNpZ25zXG4tIEZsYXQgMkQgYXJ0d29yayBmb3IgcHJpbnRpbmdcbi0gU3R5bGU6ICR7c3R5bGVNb2RpZmllcn1cblxuUmV0dXJuIE9OTFkgdGhlIGZyb250IGNvdmVyIHByb21wdCBhcyBwbGFpbiB0ZXh0LmA7XG5cbiAgICAgICAgICBjb25zdCBmcm9udENvdmVyUHJvbXB0ID0gYXdhaXQgY2hhdFdpdGhBSShmcm9udENvdmVyUHJvbXB0UXVlcnksIHtcbiAgICAgICAgICAgIG1vZGVsOiBcImdlbWluaS0yLjUtcHJvXCIsXG4gICAgICAgICAgICBhdHRhY2htZW50czogcmVmZXJlbmNlSW1hZ2VVcmxzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWZyb250Q292ZXJQcm9tcHQ/LnRyaW0oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGZyb250IGNvdmVyIHByb21wdFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbmhhbmNlIHdpdGggcmVmZXJlbmNlIGltYWdlIGluc3RydWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgICBsZXQgZW5oYW5jZWRGcm9udENvdmVyUHJvbXB0ID0gZnJvbnRDb3ZlclByb21wdC50cmltKCk7XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIHNlbGVjdGVkRHJhZnRNb2RlbCA9PT0gXCJncHQtaW1hZ2UtMVwiKSB7XG4gICAgICAgICAgICBlbmhhbmNlZEZyb250Q292ZXJQcm9tcHQgKz0gYFxcblxcbkNSSVRJQ0FMIENIQVJBQ1RFUiBSRUZFUkVOQ0UgSU5TVFJVQ1RJT05TOiBJIGhhdmUgcHJvdmlkZWQgJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMSA/ICdtdWx0aXBsZSByZWZlcmVuY2UgcGhvdG9zJyA6ICdhIHJlZmVyZW5jZSBwaG90byd9IGFzIGlucHV0IGltYWdlJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMSA/ICdzJyA6ICcnfS4gWW91IE1VU1QgY3JlYXRlIGNhcnRvb24vaWxsdXN0cmF0ZWQgY2hhcmFjdGVycyB0aGF0IGFjY3VyYXRlbHkgcmVwcmVzZW50IE9OTFkgdGhlIHBlb3BsZSB3aG8gYXJlIGFjdHVhbGx5IHZpc2libGUgaW4gJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMSA/ICd0aGVzZSByZWZlcmVuY2UgcGhvdG9zJyA6ICd0aGlzIHJlZmVyZW5jZSBwaG90byd9IHdpdGggaGlnaCBmaWRlbGl0eSB0byB0aGVpciBhcHBlYXJhbmNlLmA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGltYWdlXG4gICAgICAgICAgY29uc3Qgam9iSWQgPSBgZHJhZnQtJHtpbmRleH0tJHt1dWlkdjQoKX1gO1xuICAgICAgICAgIGNvbnN0IGlucHV0SW1hZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGlmIChyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZERyYWZ0TW9kZWwgPT09IFwiZ3B0LWltYWdlLTFcIikge1xuICAgICAgICAgICAgaW5wdXRJbWFnZXMucHVzaCguLi5yZWZlcmVuY2VJbWFnZVVybHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2VuZXJhdGUtY2FyZC1hc3luYycsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICBwcm9tcHRzOiB7IGZyb250Q292ZXI6IGVuaGFuY2VkRnJvbnRDb3ZlclByb21wdCB9LFxuICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICB1c2VyTnVtYmVyOiBcIisxNzE0NTk4NjEwNVwiLFxuICAgICAgICAgICAgICAgIG1vZGVsVmVyc2lvbjogc2VsZWN0ZWREcmFmdE1vZGVsLFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSk/LmFzcGVjdFJhdGlvIHx8IFwiOToxNlwiLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IFwibG93XCIsIC8vIExvdyBxdWFsaXR5IGZvciBkcmFmdCBtb2RlXG4gICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0OiBcImpwZWdcIixcbiAgICAgICAgICAgICAgICBvdXRwdXRDb21wcmVzc2lvbjogMTAwLFxuICAgICAgICAgICAgICAgIG1vZGVyYXRpb246IFwibG93XCIsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFwZXJTaXplcy5maW5kKHNpemUgPT4gc2l6ZS5pZCA9PT0gc2VsZWN0ZWRQYXBlclNpemUpPy5kaW1lbnNpb25zIHx8IFwiMTAyNHgxNTM2XCIsXG4gICAgICAgICAgICAgICAgaXNGcm9udEJhY2tPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgICAgICAgICBjYXJkVHlwZTogY2FyZFR5cGVGb3JQcm9tcHQsXG4gICAgICAgICAgICAgICAgdG9GaWVsZCxcbiAgICAgICAgICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgICAgICAgICAgaXNEcmFmdE1vZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4uKGlucHV0SW1hZ2VzLmxlbmd0aCA+IDAgJiYgeyBcbiAgICAgICAgICAgICAgICAgIGlucHV0X2ltYWdlczogaW5wdXRJbWFnZXMsXG4gICAgICAgICAgICAgICAgICBpbnB1dF9pbWFnZXNfbW9kZTogXCJmcm9udF9jb3Zlcl9vbmx5XCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gJ3Byb2Nlc3NpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBzdGFydCBkcmFmdCBnZW5lcmF0aW9uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBEcmFmdCB2YXJpYXRpb24gJHtpbmRleCArIDF9IGpvYiBzdGFydGVkOmAsIGpvYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdG9yZSB0aGUgam9iIHdpdGggc3R5bGUgaW5mbyBmb3IgbGF0ZXJcbiAgICAgICAgICBzYXZlSm9iVG9TdG9yYWdlKGpvYklkLCB7XG4gICAgICAgICAgICBpc0RyYWZ0OiB0cnVlLFxuICAgICAgICAgICAgZHJhZnRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICBzdHlsZUluZm86IHN0eWxlT3ZlcnJpZGUgPyB7IHN0eWxlTmFtZTogc3R5bGVPdmVycmlkZSwgc3R5bGVMYWJlbDogc3R5bGVMYWJlbCB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZnJvbnRDb3ZlclByb21wdDogZW5oYW5jZWRGcm9udENvdmVyUHJvbXB0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTdGFydCBwb2xsaW5nIGZvciB0aGlzIHNwZWNpZmljIGRyYWZ0IGpvYlxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFN0YXJ0aW5nIHBvbGxpbmcgZm9yIGRyYWZ0IGpvYiAke2pvYklkfWApO1xuICAgICAgICAgIHBvbGxKb2JTdGF0dXMoam9iSWQpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIERyYWZ0IHZhcmlhdGlvbiAke2luZGV4ICsgMX0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgICAgICB0b2FzdC5lcnJvcihgRHJhZnQgdmFyaWF0aW9uICR7aW5kZXggKyAxfSBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBhbGwgZHJhZnQgZ2VuZXJhdGlvbnMgdG8gc3RhcnQgKGJ1dCBub3QgY29tcGxldGUpXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZHJhZnRQcm9taXNlcyk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfmoAgQWxsIGRyYWZ0IHZhcmlhdGlvbnMgc3RhcnRlZFwiKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEcmFmdCBjYXJkIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBzdGFydCBkcmFmdCBnZW5lcmF0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgXG4gICAgICBzZXRJc0dlbmVyYXRpbmcoZmFsc2UpO1xuICAgICAgc2V0SXNEcmFmdE1vZGUoZmFsc2UpO1xuICAgICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24oZmFsc2UpO1xuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiXCIpO1xuICAgICAgc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgam9iIHN0YXR1c1xuICBjb25zdCBjaGVja0pvYlN0YXR1cyA9IGFzeW5jIChqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9qb2Itc3RhdHVzLyR7am9iSWR9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBqb2Igc3RhdHVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyBQb2xsIGpvYiBzdGF0dXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gIGNvbnN0IHBvbGxKb2JTdGF0dXMgPSBhc3luYyAoam9iSWQ6IHN0cmluZywgYXR0ZW1wdDogbnVtYmVyID0gMSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IGNoZWNrSm9iU3RhdHVzKGpvYklkKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGRyYWZ0IGpvYlxuICAgICAgY29uc3QgaXNEcmFmdEpvYiA9IGpvYklkLnN0YXJ0c1dpdGgoJ2RyYWZ0LScpO1xuICAgICAgY29uc3QgZHJhZnRJbmRleCA9IGlzRHJhZnRKb2IgPyBwYXJzZUludChqb2JJZC5zcGxpdCgnLScpWzFdKSA6IC0xO1xuICAgICAgXG4gICAgICBpZiAoc3RhdHVzUmVzcG9uc2UgJiYgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzID09PSAnY29tcGxldGVkJykge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+OiSBKb2IgY29tcGxldGVkISBDYXJkIGRhdGE6Jywgc3RhdHVzUmVzcG9uc2UuY2FyZERhdGEsICdpc0RyYWZ0Sm9iOicsIGlzRHJhZnRKb2IpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1c1Jlc3BvbnNlLmNhcmREYXRhKSB7XG4gICAgICAgICAgaWYgKGlzRHJhZnRKb2IgJiYgZHJhZnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZHJhZnQgY2FyZCBjb21wbGV0aW9uIC0gbm8gUVIgY29kZSBuZWVkZWQgZm9yIGRyYWZ0c1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjqggRHJhZnQgdmFyaWF0aW9uICR7ZHJhZnRJbmRleCArIDF9IGNvbXBsZXRlZCFgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IHN0eWxlIGluZm8gZm9yIHNtYXJ0IHN0eWxlIG1vZGVcbiAgICAgICAgICAgIGxldCBzdHlsZUluZm86IHsgc3R5bGVOYW1lOiBzdHJpbmc7IHN0eWxlTGFiZWw6IHN0cmluZyB9IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSA9PT0gXCJhaS1zbWFydC1zdHlsZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZWRlZmluZWRTdHlsZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJ3YXRlcmNvbG9yXCIsIFwiYm90YW5pY2FsXCIsIFwiY29taWMtYm9va1wiLCBcImRyZWFteS1mYW50YXN5XCIsIFwibWluaW1hbGlzdFwiXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlTGFiZWxzID0gW1xuICAgICAgICAgICAgICAgIFwi8J+OqCBXYXRlcmNvbG9yXCIsIFwi8J+MvyBCb3RhbmljYWxcIiwgXCLwn5KlIENvbWljIEJvb2tcIiwgXCLwn4y4IERyZWFteSBGYW50YXN5XCIsIFwi4pyoIE1pbmltYWxpc3RcIlxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBpZiAoZHJhZnRJbmRleCA+PSAwICYmIGRyYWZ0SW5kZXggPCBwcmVkZWZpbmVkU3R5bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0eWxlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgIHN0eWxlTmFtZTogcHJlZGVmaW5lZFN0eWxlc1tkcmFmdEluZGV4XSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlTGFiZWw6IHN0eWxlTGFiZWxzW2RyYWZ0SW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkcmFmdENhcmQ6IEdlbmVyYXRlZENhcmQgPSB7XG4gICAgICAgICAgICAgIGlkOiBgZHJhZnQtJHtkcmFmdEluZGV4ICsgMX0tJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICAgIHByb21wdDogc3RhdHVzUmVzcG9uc2UuY2FyZERhdGEucHJvbXB0IHx8IGBEcmFmdCBWYXJpYXRpb24gJHtkcmFmdEluZGV4ICsgMX1gLFxuICAgICAgICAgICAgICBmcm9udENvdmVyOiBzdGF0dXNSZXNwb25zZS5jYXJkRGF0YS5mcm9udENvdmVyIHx8IFwiXCIsXG4gICAgICAgICAgICAgIGJhY2tDb3ZlcjogXCJcIiwgLy8gRHJhZnQgbW9kZSBvbmx5IGdlbmVyYXRlcyBmcm9udCBjb3ZlclxuICAgICAgICAgICAgICBsZWZ0UGFnZTogXCJcIiwgLy8gV2lsbCBiZSBnZW5lcmF0ZWQgaW4gZmluYWwgaGlnaC1xdWFsaXR5IHZlcnNpb25cbiAgICAgICAgICAgICAgcmlnaHRQYWdlOiBcIlwiLCAvLyBXaWxsIGJlIGdlbmVyYXRlZCBpbiBmaW5hbCBoaWdoLXF1YWxpdHkgdmVyc2lvblxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIGdlbmVyYXRlZFByb21wdHM6IHtcbiAgICAgICAgICAgICAgICBmcm9udENvdmVyOiBzdGF0dXNSZXNwb25zZS5jYXJkRGF0YS5nZW5lcmF0ZWRQcm9tcHRzPy5mcm9udENvdmVyIHx8IFwiXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3R5bGVJbmZvOiBzdHlsZUluZm9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkcmFmdCBjYXJkcyBzdGF0ZSAtIHBvcHVsYXRlIGZyb20gbGVmdCB0byByaWdodCBhcyB0aGV5IGNvbXBsZXRlXG4gICAgICAgICAgICBzZXREcmFmdENhcmRzKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gWy4uLnByZXZdO1xuICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goZHJhZnRDYXJkKTsgLy8gQWRkIHRvIG5leHQgYXZhaWxhYmxlIHBvc2l0aW9uIChsZWZ0IHRvIHJpZ2h0KVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgbWFwcGluZyB0byB0cmFjayB3aGljaCBkaXNwbGF5IHBvc2l0aW9uIGNvcnJlc3BvbmRzIHRvIHdoaWNoIG9yaWdpbmFsIGRyYWZ0IGluZGV4XG4gICAgICAgICAgICBzZXREcmFmdEluZGV4TWFwcGluZyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE1hcHBpbmcgPSBbLi4ucHJldl07XG4gICAgICAgICAgICAgIHVwZGF0ZWRNYXBwaW5nLnB1c2goZHJhZnRJbmRleCk7IC8vIE1hcCBuZXcgZGlzcGxheSBwb3NpdGlvbiB0byBvcmlnaW5hbCBkcmFmdCBpbmRleFxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZE1hcHBpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGFuZCBjaGVjayBjb21wbGV0aW9uXG4gICAgICAgICAgICBjb25zdCBuZXdDb21wbGV0ZWRDb3VudCA9IGRyYWZ0Q2FyZHMubGVuZ3RoICsgMTsgLy8gKzEgYmVjYXVzZSBzdGF0ZSB1cGRhdGUgaXMgYXN5bmNcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIERyYWZ0IHByb2dyZXNzOiAke25ld0NvbXBsZXRlZENvdW50fS81IGZyb250IGNvdmVyIHZhcmlhdGlvbnMgY29tcGxldGVgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIGRyYWZ0IHByZXZpZXcgd2hlbiBmaXJzdCBjYXJkIGFwcGVhcnNcbiAgICAgICAgICAgIGlmIChuZXdDb21wbGV0ZWRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICBzY3JvbGxUb0NhcmRQcmV2aWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChuZXdDb21wbGV0ZWRDb3VudCA9PT0gNSkge1xuICAgICAgICAgICAgICBzZXRJc0dlbmVyYXRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCJcIik7XG4gICAgICAgICAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgxMDApO1xuICAgICAgICAgICAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gT25seSBzaG93IGNvbXBsZXRpb24gdG9hc3Qgb25jZSB1c2luZyBhIGZsYWcsIGFuZCBvbmx5IGlmIHVzZXIgaGFzbid0IG1vdmVkIHRvIGZpbmFsIGdlbmVyYXRpb25cbiAgICAgICAgICAgICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24ocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ICYmICFpc0dlbmVyYXRpbmdGaW5hbENhcmQpIHtcbiAgICAgICAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoXCLwn46oIEFsbCA1IGZyb250IGNvdmVyIHZhcmlhdGlvbnMgcmVhZHkhIENob29zZSB5b3VyIGZhdm9yaXRlIGJlbG93LlwiKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoYOKcqCAke25ld0NvbXBsZXRlZENvdW50fS81IGZyb250IGNvdmVyIHZhcmlhdGlvbnMgY29tcGxldGUuLi4gJHtuZXdDb21wbGV0ZWRDb3VudCA+PSAyID8gXCJZb3UgY2FuIHNlbGVjdCBvbmUgbm93IHRvIHByb2NlZWQhXCIgOiBcIlwifWApO1xuICAgICAgICAgICAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoKG5ld0NvbXBsZXRlZENvdW50IC8gNSkgKiAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZW1vdmVKb2JGcm9tU3RvcmFnZShqb2JJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmaW5hbCBjYXJkIGNvbXBsZXRpb24gLSBhcHBseSBRUiBjb2RlIGFuZCBmdWxsIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGxldCBjYXJkV2l0aFFSID0geyAuLi5zdGF0dXNSZXNwb25zZS5jYXJkRGF0YSB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNhcmQgaGFzIGEgdmFsaWQgY3JlYXRlZEF0IGRhdGVcbiAgICAgICAgICAgIGlmICghY2FyZFdpdGhRUi5jcmVhdGVkQXQpIHtcbiAgICAgICAgICAgICAgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjYXJkV2l0aFFSLmNyZWF0ZWRBdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPSBuZXcgRGF0ZShjYXJkV2l0aFFSLmNyZWF0ZWRBdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY2FyZCBoYXMgYSB2YWxpZCBJRFxuICAgICAgICAgICAgaWYgKCFjYXJkV2l0aFFSLmlkKSB7XG4gICAgICAgICAgICAgIGNhcmRXaXRoUVIuaWQgPSBgY2FyZC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEZpbmFsIGNhcmQgZGF0YSBwcmVwYXJlZDonLCBjYXJkV2l0aFFSKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi4pyoIEFkZGluZyBpbnRlcmFjdGl2ZSBRUiBjb2RlIHRvIHlvdXIgY2FyZC4uLlwiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgU3RhcnRpbmcgUVIgb3ZlcmxheSBwcm9jZXNzIGZvciBmaW5hbCBjYXJkJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTdG9yZSBjYXJkIGRhdGEgZmlyc3QgdG8gZ2V0IGEgc2hhcmVhYmxlIFVSTFxuICAgICAgICAgICAgICBpZiAoY2FyZFdpdGhRUi5mcm9udENvdmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcmRTdG9yZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2FyZHMvc3RvcmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogY2FyZFdpdGhRUi5wcm9tcHQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgZnJvbnRDb3ZlcjogY2FyZFdpdGhRUi5mcm9udENvdmVyIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgIGJhY2tDb3ZlcjogY2FyZFdpdGhRUi5iYWNrQ292ZXIgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdFBhZ2U6IGNhcmRXaXRoUVIubGVmdFBhZ2UgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHRQYWdlOiBjYXJkV2l0aFFSLnJpZ2h0UGFnZSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRQcm9tcHRzOiBjYXJkV2l0aFFSLmdlbmVyYXRlZFByb21wdHMgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChjYXJkU3RvcmVSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXJkU3RvcmVEYXRhID0gYXdhaXQgY2FyZFN0b3JlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxTaGFyZVVybCA9IGNhcmRTdG9yZURhdGEuc2hhcmVfdXJsO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgYWN0dWFsIHNoYXJlIFVSTCBmb3IgUVIgY29kZTonLCBhY3R1YWxTaGFyZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBRUiBjb2RlIHRvIGJhY2sgY292ZXIgdXNpbmcgdGhlIEFQSS1yZXR1cm5lZCBVUkxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmRXaXRoUVIuYmFja0NvdmVyICYmIGFjdHVhbFNoYXJlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgQXBwbHlpbmcgUVIgb3ZlcmxheSB0byBmaW5hbCBjYXJkLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxCYWNrQ292ZXIgPSBjYXJkV2l0aFFSLmJhY2tDb3ZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjYXJkV2l0aFFSLmJhY2tDb3ZlciA9IGF3YWl0IG92ZXJsYXlRUkNvZGVPbkltYWdlKG9yaWdpbmFsQmFja0NvdmVyLCBhY3R1YWxTaGFyZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FyZFdpdGhRUi5zaGFyZVVybCA9IGFjdHVhbFNoYXJlVXJsO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUVIgb3ZlcmxheSBjb21wbGV0ZSBmb3IgZmluYWwgY2FyZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzdG9yZSBjYXJkIGZvciBzaGFyaW5nLCBjb250aW51aW5nIHdpdGhvdXQgUVIgY29kZScpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHN0b3JlIGNhcmQgb3Igb3ZlcmxheSBRUiBjb2RlOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGhvdXQgUVIgY29kZSBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gZnJvbnQgY292ZXIgZm91bmQsIHNraXBwaW5nIFFSIGNvZGUgcHJvY2VzcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gUVIgY29kZSBwcm9jZXNzOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBRUiBjb2RlIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2V0dGluZyBmaW5hbCBjYXJkIHN0YXRlOicsIGNhcmRXaXRoUVIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNhcmQgc3RhdGVzIC0gdGhpcyBpcyBjcml0aWNhbCFcbiAgICAgICAgICAgIHNldEdlbmVyYXRlZENhcmQoY2FyZFdpdGhRUik7XG4gICAgICAgICAgICBzZXRHZW5lcmF0ZWRDYXJkcyhbY2FyZFdpdGhRUl0pO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYXJkSW5kZXgoMCk7XG4gICAgICAgICAgICBzZXRJc0NhcmRDb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRJc0dlbmVyYXRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldElzRHJhZnRNb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIHNldERyYWZ0Q29tcGxldGlvblNob3duKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIGNhcmQgcHJldmlld1xuICAgICAgICAgICAgc2Nyb2xsVG9DYXJkUHJldmlldygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGdlbmVyYXRpb24gdGltZSBmcm9tIGJhY2tlbmRcbiAgICAgICAgICAgIGlmIChzdGF0dXNSZXNwb25zZS5jYXJkRGF0YS5nZW5lcmF0aW9uVGltZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgc2V0R2VuZXJhdGlvbkR1cmF0aW9uKHN0YXR1c1Jlc3BvbnNlLmNhcmREYXRhLmdlbmVyYXRpb25UaW1lU2Vjb25kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0b3AgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gICAgICAgICAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgcHJvZ3Jlc3MgdG8gMTAwJVxuICAgICAgICAgICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDEwMCk7XG4gICAgICAgICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCJDYXJkIGdlbmVyYXRpb24gY29tcGxldGUhXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0b2FzdC5zdWNjZXNzKFwi8J+OiSBZb3VyIGNhcmQgaXMgcmVhZHkhXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZW5kIHRoYW5rIHlvdSBlbWFpbFxuICAgICAgICAgICAgaWYgKHVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2FyZFR5cGVGb3JFbWFpbCA9IHNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGN1c3RvbUNhcmRUeXBlIDogc2VsZWN0ZWRUeXBlO1xuICAgICAgICAgICAgICBzZW5kVGhhbmtZb3VFbWFpbCh1c2VyRW1haWwsIGNhcmRUeXBlRm9yRW1haWwsIGNhcmRXaXRoUVIuc2hhcmVVcmwgfHwgJ2h0dHBzOi8vdmliZWNhcmRpbmcuY29tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRmluYWwgY2FyZCBjb21wbGV0aW9uIHByb2Nlc3MgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICByZW1vdmVKb2JGcm9tU3RvcmFnZShqb2JJZCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50Sm9iSWQobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBObyBjYXJkIGRhdGEgaW4gY29tcGxldGVkIHJlc3BvbnNlJyk7XG4gICAgICAgICAgdG9hc3QuZXJyb3IoXCLinYwgQ2FyZCBnZW5lcmF0aW9uIGNvbXBsZXRlZCBidXQgbm8gZGF0YSByZWNlaXZlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgcmVtb3ZlSm9iRnJvbVN0b3JhZ2Uoam9iSWQpO1xuICAgICAgICAgIGlmICghaXNEcmFmdEpvYikge1xuICAgICAgICAgICAgc2V0Q3VycmVudEpvYklkKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0dXNSZXNwb25zZSAmJiBzdGF0dXNSZXNwb25zZS5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBKb2IgZmFpbGVkOicsIHN0YXR1c1Jlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0RyYWZ0Sm9iICYmIGRyYWZ0SW5kZXggPj0gMCkge1xuICAgICAgICAgIHRvYXN0LmVycm9yKGBEcmFmdCB2YXJpYXRpb24gJHtkcmFmdEluZGV4ICsgMX0gZmFpbGVkLiBDb250aW51aW5nIHdpdGggb3RoZXJzLi4uYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9hc3QuZXJyb3IoXCLinYwgQ2FyZCBnZW5lcmF0aW9uIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQoZmFsc2UpO1xuICAgICAgICAgIHN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiXCIpO1xuICAgICAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICAgICAgICBzZXRDdXJyZW50Sm9iSWQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlbW92ZUpvYkZyb21TdG9yYWdlKGpvYklkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzUmVzcG9uc2UgJiYgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzID09PSAncHJvY2Vzc2luZycpIHtcbiAgICAgICAgLy8gQ29udGludWUgcG9sbGluZyBldmVyeSAzIHNlY29uZHMgLSBuZWFyIHJlYWwtdGltZSB1cGRhdGVzIGZvciBiZXR0ZXIgVVhcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgSm9iIHN0aWxsIHByb2Nlc3NpbmcgKGF0dGVtcHQgJHthdHRlbXB0fSksIHBvbGxpbmcgYWdhaW4uLi5gKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb2xsSm9iU3RhdHVzKGpvYklkLCBhdHRlbXB0ICsgMSksIDMwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gVW5leHBlY3RlZCBzdGF0dXMgcmVzcG9uc2U6Jywgc3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAvLyBDb250aW51ZSBwb2xsaW5nIGluIGNhc2UgaXQncyBhIHRlbXBvcmFyeSBpc3N1ZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvbGxKb2JTdGF0dXMoam9iSWQsIGF0dGVtcHQgKyAxKSwgNTAwMCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwb2xsIGpvYiBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgLy8gUmV0cnkgYWZ0ZXIgZGVsYXkgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKDEwMDAwLCAzMDAwICogTWF0aC5wb3coMS41LCBNYXRoLm1pbihhdHRlbXB0IC0gMSwgNSkpKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9sbEpvYlN0YXR1cyhqb2JJZCwgYXR0ZW1wdCArIDEpLCBkZWxheSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZSBqb2IgZnJvbSBzdG9yYWdlXG4gIGNvbnN0IHJlbW92ZUpvYkZyb21TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChpZDogc3RyaW5nKSA9PiBpZCAhPT0gam9iSWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRKb2JzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgam9iIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgZmluYWwgaGlnaC1xdWFsaXR5IGNhcmQgZnJvbSBzZWxlY3RlZCBkcmFmdFxuICBjb25zdCBoYW5kbGVHZW5lcmF0ZUZpbmFsRnJvbURyYWZ0ID0gYXN5bmMgKGRpc3BsYXlJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGRpc3BsYXlJbmRleCA8IDAgfHwgZGlzcGxheUluZGV4ID49IGRyYWZ0Q2FyZHMubGVuZ3RoIHx8ICFkcmFmdENhcmRzW2Rpc3BsYXlJbmRleF0pIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiSW52YWxpZCBkcmFmdCBzZWxlY3Rpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBkcmFmdCBpbmRleCBmcm9tIHRoZSBtYXBwaW5nXG4gICAgY29uc3Qgb3JpZ2luYWxEcmFmdEluZGV4ID0gZHJhZnRJbmRleE1hcHBpbmdbZGlzcGxheUluZGV4XTtcbiAgICBpZiAob3JpZ2luYWxEcmFmdEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiQ291bGQgbm90IGZpbmQgb3JpZ2luYWwgZHJhZnQgZGF0YVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHJlbWFpbmluZyBkcmFmdCBnZW5lcmF0aW9ucyB0byBmb2N1cyBvbiB0aGUgc2VsZWN0ZWQgZGVzaWduXG4gICAgY29uc3QgcmVtYWluaW5nRHJhZnRzID0gNSAtIGRyYWZ0Q2FyZHMubGVuZ3RoO1xuICAgIGlmIChyZW1haW5pbmdEcmFmdHMgPiAwICYmIGlzR2VuZXJhdGluZykge1xuICAgICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKTsgLy8gU3RvcCB0aGUgZHJhZnQgZ2VuZXJhdGlvbiBwcm9jZXNzXG4gICAgICB0b2FzdC5pbmZvKGDwn46vIEZvY3VzaW5nIG9uIHlvdXIgc2VsZWN0ZWQgZGVzaWduISBTa2lwcGluZyAke3JlbWFpbmluZ0RyYWZ0c30gcmVtYWluaW5nIHZhcmlhdGlvbnMuYCk7XG4gICAgfVxuXG4gICAgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkKHRydWUpO1xuICAgIHNldFNlbGVjdGVkRHJhZnRJbmRleChkaXNwbGF5SW5kZXgpOyAvLyBTdG9yZSBkaXNwbGF5IGluZGV4IGZvciBVSVxuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyh1bmRlZmluZWQsIDEyMCk7IC8vIDEyMCBzZWNvbmRzIGZvciBmaW5hbCBjYXJkIGdlbmVyYXRpb25cbiAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCLwn46oIENyZWF0aW5nIGhpZ2gtcXVhbGl0eSB2ZXJzaW9uIG9mIHlvdXIgc2VsZWN0ZWQgZGVzaWduLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRHJhZnQgPSBkcmFmdENhcmRzW2Rpc3BsYXlJbmRleF07XG4gICAgICBjb25zdCBqb2JJZCA9IHV1aWR2NCgpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSB0aGUgbWlzc2luZyBwcm9tcHRzIHVzaW5nIHRoZSBzdG9yZWQgZnJvbnRDb3ZlciBwcm9tcHQgKyB1c2VyIGluZm9cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBHZW5lcmF0aW5nIGNvbXBsZXRlIHByb21wdHMgZnJvbSBzdG9yZWQgZnJvbnQgY292ZXIgcHJvbXB0ICsgdXNlciBpbmZvXCIpO1xuICAgICAgXG4gICAgICAvLyBUaGUgZHJhZnQgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhlIGZyb250Q292ZXIgcHJvbXB0XG4gICAgICBjb25zdCBzdG9yZWRGcm9udENvdmVyUHJvbXB0ID0gc2VsZWN0ZWREcmFmdC5nZW5lcmF0ZWRQcm9tcHRzPy5mcm9udENvdmVyO1xuICAgICAgaWYgKCFzdG9yZWRGcm9udENvdmVyUHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGVkIGRyYWZ0IGlzIG1pc3NpbmcgZnJvbnRDb3ZlciBwcm9tcHRcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIEZvdW5kIHN0b3JlZCBmcm9udCBjb3ZlciBwcm9tcHQ6XCIsIHN0b3JlZEZyb250Q292ZXJQcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCkgKyBcIi4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gTm93IGdlbmVyYXRlIHRoZSBtaXNzaW5nIDMgcHJvbXB0cyB1c2luZyB0aGUgZnJvbnQgY292ZXIgY29udGV4dCArIHVzZXIgaW5mb1xuICAgICAgY29uc3QgY2FyZFR5cGVGb3JQcm9tcHQgPSBzZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBjdXN0b21DYXJkVHlwZSA6IHNlbGVjdGVkVHlwZTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVG9uZU9iaiA9IGNhcmRUb25lcy5maW5kKHRvbmUgPT4gdG9uZS5pZCA9PT0gc2VsZWN0ZWRUb25lKTtcbiAgICAgIGNvbnN0IHRvbmVEZXNjcmlwdGlvbiA9IHNlbGVjdGVkVG9uZU9iaiA/IHNlbGVjdGVkVG9uZU9iai5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpIDogXCJoZWFydGZlbHQgYW5kIHNpbmNlcmVcIjtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVByb21wdCA9IHByb21wdC50cmltKCkgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmQgd2l0aCAke3RvbmVEZXNjcmlwdGlvbn0gc3R5bGVgO1xuICAgICAgXG4gICAgICBsZXQgbWVzc2FnZUNvbnRlbnQgPSBmaW5hbENhcmRNZXNzYWdlO1xuICAgICAgaWYgKGlzSGFuZHdyaXR0ZW5NZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50ID0gXCJbQmxhbmsgc3BhY2UgZm9yIGhhbmR3cml0dGVuIG1lc3NhZ2VdXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBzdHlsZSBmcm9tIHRoZSBzZWxlY3RlZCBkcmFmdCBvciBmYWxsIGJhY2sgdG8gY3VycmVudCBzZXR0aW5nICBcbiAgICAgIGNvbnN0IGRyYWZ0U3R5bGVJbmZvID0gc2VsZWN0ZWREcmFmdC5zdHlsZUluZm87XG4gICAgICBsZXQgc3R5bGVNb2RpZmllciA9IFwiXCI7XG4gICAgICBpZiAoZHJhZnRTdHlsZUluZm8gJiYgZHJhZnRTdHlsZUluZm8uc3R5bGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBhcnRpc3RpY1N0eWxlcy5maW5kKHN0eWxlID0+IHN0eWxlLmlkID09PSBkcmFmdFN0eWxlSW5mby5zdHlsZU5hbWUpO1xuICAgICAgICBzdHlsZU1vZGlmaWVyID0gc2VsZWN0ZWRTdHlsZT8ucHJvbXB0TW9kaWZpZXIgfHwgXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBhcnRpc3RpY1N0eWxlcy5maW5kKHN0eWxlID0+IHN0eWxlLmlkID09PSBzZWxlY3RlZEFydGlzdGljU3R5bGUpO1xuICAgICAgICBzdHlsZU1vZGlmaWVyID0gc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiIFxuICAgICAgICAgID8gY3VzdG9tU3R5bGVEZXNjcmlwdGlvbiBcbiAgICAgICAgICA6IHNlbGVjdGVkU3R5bGU/LnByb21wdE1vZGlmaWVyIHx8IFwiXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdlbmVyYXRlT3RoZXJQcm9tcHRzUXVlcnkgPSBgWW91IGFyZSBjcmVhdGluZyB0aGUgcmVtYWluaW5nIHByb21wdHMgZm9yIGEgZ3JlZXRpbmcgY2FyZC4gWW91IGFscmVhZHkgaGF2ZSB0aGUgZnJvbnQgY292ZXIgcHJvbXB0IGJlbG93LlxuXG5FWElTVElORyBGUk9OVCBDT1ZFUiBQUk9NUFQ6XG5cIiR7c3RvcmVkRnJvbnRDb3ZlclByb21wdH1cIlxuXG5DQVJEIENPTlRFWFQ6XG4tIFR5cGU6ICR7Y2FyZFR5cGVGb3JQcm9tcHR9XG4tIFRoZW1lOiBcIiR7ZWZmZWN0aXZlUHJvbXB0fVwiICBcbi0gVG9uZTogJHt0b25lRGVzY3JpcHRpb259XG4ke3RvRmllbGQgPyBgLSBUbzogJHt0b0ZpZWxkfWAgOiBcIlwifVxuJHtmcm9tRmllbGQgPyBgLSBGcm9tOiAke2Zyb21GaWVsZH1gIDogXCJcIn1cbiR7IWlzRnJvbnRCYWNrT25seSA/IGAtIE1lc3NhZ2U6IFwiJHttZXNzYWdlQ29udGVudH1cImAgOiBcIlwifVxuJHtpc0hhbmR3cml0dGVuTWVzc2FnZSA/IFwiLSBOb3RlOiBJbmNsdWRlIHNwYWNlIGZvciBoYW5kd3JpdHRlbiBtZXNzYWdlXCIgOiBcIlwifVxuXG5UQVNLOiBDcmVhdGUgcHJvbXB0cyBmb3IgdGhlIHJlbWFpbmluZyBjYXJkIHNlY3Rpb25zIHRoYXQgYXJlIHZpc3VhbGx5IGNvaGVzaXZlIHdpdGggdGhlIGV4aXN0aW5nIGZyb250IGNvdmVyLiBVc2UgdGhlIHNhbWUgY29sb3IgcGFsZXR0ZSwgYXJ0aXN0aWMgc3R5bGUsIGxpZ2h0aW5nLCBhbmQgdmlzdWFsIGVsZW1lbnRzIGZyb20gdGhlIGZyb250IGNvdmVyIHRvIGNyZWF0ZSBhIHVuaWZpZWQgZGVzaWduLlxuXG5SZXF1aXJlbWVudHM6XG4tIE1haW50YWluIHZpc3VhbCBjb250aW51aXR5IHdpdGggdGhlIGZyb250IGNvdmVyIGRlc2lnblxuLSBVc2UgdGhlIHNhbWUgYXJ0aXN0aWMgc3R5bGU6ICR7c3R5bGVNb2RpZmllcn1cbi0gS2VlcCBjb25zaXN0ZW50IGNvbG9yIHBhbGV0dGUsIGxpZ2h0aW5nLCBhbmQgbW9vZFxuLSBGdWxsLWJsZWVkIGJhY2tncm91bmRzIGV4dGVuZGluZyB0byBlZGdlc1xuLSBLZWVwIHRleHQvZmFjZXMgMC41XCIgZnJvbSBsZWZ0L3JpZ2h0IGVkZ2VzIGZvciBzYWZlIHByaW50aW5nXG4tIElNUE9SVEFOVDogS2VlcCB0ZXh0LCBmYWNlcywgYW5kIGtleSBlbGVtZW50cyBhdCBsZWFzdCAxMCUgYXdheSBmcm9tIHRvcC9ib3R0b20gZWRnZXNcblxuR2VuZXJhdGUgcHJvbXB0cyBmb3I6XG5cbjEuIEJhY2sgQ292ZXI6IENyZWF0ZSBhIHNpbXBsZSwgcGVhY2VmdWwgZGVzaWduIHRoYXQgY29tcGxlbWVudHMgdGhlIGZyb250IGNvdmVyLiBSZWZlcmVuY2Ugc3VidGxlIGVsZW1lbnRzIGZyb20gdGhlIGZyb250IGNvdmVyIGJ1dCBrZWVwIGl0IG1pbmltYWwgYW5kIHNlcmVuZS4gTk8gUEVPUExFLCBqdXN0IGJlYXV0aWZ1bCBhcnRpc3RpYyBlbGVtZW50cy4gSU1QT1JUQU5UOiBMZWF2ZSB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lciBhcmVhIChhcHByb3hpbWF0ZWx5IDEgaW5jaCBzcXVhcmUpIGNvbXBsZXRlbHkgY2xlYXIgYW5kIHVuZGVjb3JhdGVkIGZvciBRUiBjb2RlIHBsYWNlbWVudC5cblxuJHshaXNGcm9udEJhY2tPbmx5ID8gYDIuIExlZnQgSW50ZXJpb3I6IENyZWF0aXZlIGRlY29yYXRpdmUgYXJ0IHRoYXQgaGFybW9uaXplcyB3aXRoIHRoZSBmcm9udCBjb3ZlciBzdHlsZS4gTk8gUEVPUExFIG9yIGNoYXJhY3RlcnMsIGZvY3VzIG9uIGFydGlzdGljIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGxhbmRzY2FwZXMsIG9iamVjdHMsIG9yIGFic3RyYWN0IGFydCB0aGF0IG1hdGNoZXMgdGhlIGZyb250IGNvdmVyJ3MgbW9vZCBhbmQgc3R5bGUuXG5cbjMuIFJpZ2h0IEludGVyaW9yOiAke2lzSGFuZHdyaXR0ZW5NZXNzYWdlID8gYERlc2lnbiBlbGVnYW50IHdyaXRpbmcgc3BhY2Ugd2l0aCBkZWNvcmF0aXZlIGVsZW1lbnRzIHRoYXQgY29tcGxlbWVudCB0aGUgZnJvbnQgY292ZXIgc3R5bGUuIFBvc2l0aW9uIGRlY29yYXRpdmUgZWxlbWVudHMgc2FmZWx5IGF3YXkgZnJvbSBlZGdlcy4gTk8gUEVPUExFIG9yIGNoYXJhY3RlcnMuYCA6IGBJbmNsdWRlIG1lc3NhZ2UgdGV4dDogXCIke21lc3NhZ2VDb250ZW50fVwiIGluIGJlYXV0aWZ1bCBoYW5kd3JpdHRlbiBjdXJzaXZlIHNjcmlwdCwgaW50ZWdyYXRlZCBpbnRvIGRlY29yYXRpdmUgYXJ0d29yayB0aGF0IG1hdGNoZXMgdGhlIGZyb250IGNvdmVyIHN0eWxlLiBOTyBQRU9QTEUgb3IgY2hhcmFjdGVycy5gfWAgOiAnJ31cblxuUmV0dXJuIEpTT046XG57XG4gIFwiZnJvbnRDb3ZlclwiOiBcIiR7c3RvcmVkRnJvbnRDb3ZlclByb21wdH1cIixcbiAgXCJiYWNrQ292ZXJcIjogXCJkZXRhaWxlZCBiYWNrIGNvdmVyIHByb21wdFwiJHshaXNGcm9udEJhY2tPbmx5ID8gJyxcXG4gIFwibGVmdEludGVyaW9yXCI6IFwiZGV0YWlsZWQgbGVmdCBpbnRlcmlvciBwcm9tcHRcIixcXG4gIFwicmlnaHRJbnRlcmlvclwiOiBcImRldGFpbGVkIHJpZ2h0IGludGVyaW9yIHByb21wdFwiJyA6ICcnfVxufWA7XG5cbiAgICAgIGNvbnN0IGZpbmFsUHJvbXB0cyA9IGF3YWl0IGNoYXRXaXRoQUkoZ2VuZXJhdGVPdGhlclByb21wdHNRdWVyeSwge1xuICAgICAgICBqc29uU2NoZW1hOiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBmcm9udENvdmVyOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIGJhY2tDb3ZlcjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICAuLi4oaXNGcm9udEJhY2tPbmx5ID8ge30gOiB7IFxuICAgICAgICAgICAgICBsZWZ0SW50ZXJpb3I6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICByaWdodEludGVyaW9yOiB7IHR5cGU6IFwic3RyaW5nXCIgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbXCJmcm9udENvdmVyXCIsIFwiYmFja0NvdmVyXCIsIC4uLihpc0Zyb250QmFja09ubHkgPyBbXSA6IFtcImxlZnRJbnRlcmlvclwiLCBcInJpZ2h0SW50ZXJpb3JcIl0pXVxuICAgICAgICB9LFxuICAgICAgICBtb2RlbDogXCJnZW1pbmktMi41LXByb1wiXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFmaW5hbFByb21wdHMgfHwgIWZpbmFsUHJvbXB0cy5mcm9udENvdmVyIHx8ICFmaW5hbFByb21wdHMuYmFja0NvdmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjb21wbGV0ZSBwcm9tcHRzIGZvciBmaW5hbCBjYXJkXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBHZW5lcmF0ZWQgY29tcGxldGUgcHJvbXB0cyBmb3IgZmluYWwgY2FyZDpcIiwge1xuICAgICAgICBoYXNGcm9udENvdmVyOiAhIWZpbmFsUHJvbXB0cy5mcm9udENvdmVyLFxuICAgICAgICBoYXNCYWNrQ292ZXI6ICEhZmluYWxQcm9tcHRzLmJhY2tDb3ZlcixcbiAgICAgICAgaGFzTGVmdEludGVyaW9yOiAhIWZpbmFsUHJvbXB0cy5sZWZ0SW50ZXJpb3IsXG4gICAgICAgIGhhc1JpZ2h0SW50ZXJpb3I6ICEhZmluYWxQcm9tcHRzLnJpZ2h0SW50ZXJpb3JcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGlucHV0IGltYWdlcyBmb3IgZmluYWwgZ2VuZXJhdGlvbiAocmVmZXJlbmNlIHBob3RvcylcbiAgICAgIGNvbnN0IGlucHV0SW1hZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgaWYgKHJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSW1hZ2VNb2RlbCA9PT0gXCJncHQtaW1hZ2UtMVwiKSB7XG4gICAgICAgIGlucHV0SW1hZ2VzLnB1c2goLi4ucmVmZXJlbmNlSW1hZ2VVcmxzKTtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIERFQlVHOiBBZGRlZCByZWZlcmVuY2UgaW1hZ2VzIHRvIGZpbmFsIGRyYWZ0IGdlbmVyYXRpb246XCIsIHJlZmVyZW5jZUltYWdlVXJscyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBERUJVRzogVG90YWwgaW5wdXQgaW1hZ2VzIGZvciBmaW5hbCBkcmFmdCBnZW5lcmF0aW9uOlwiLCBpbnB1dEltYWdlcy5sZW5ndGgpO1xuICAgICAgICB0b2FzdC5zdWNjZXNzKGDwn5O4ICR7cmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aH0gcmVmZXJlbmNlIHBob3RvJHtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMSA/ICdzJyA6ICcnfSBhcHBsaWVkIHRvIGZpbmFsIGdlbmVyYXRpb24hYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2VuZXJhdGUtY2FyZC1hc3luYycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgam9iSWQsXG4gICAgICAgICAgcHJvbXB0czogZmluYWxQcm9tcHRzLFxuICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgdXNlck51bWJlcjogXCIrMTcxNDU5ODYxMDVcIixcbiAgICAgICAgICAgIG1vZGVsVmVyc2lvbjogc2VsZWN0ZWRJbWFnZU1vZGVsLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IHBhcGVyU2l6ZXMuZmluZChzaXplID0+IHNpemUuaWQgPT09IHNlbGVjdGVkUGFwZXJTaXplKT8uYXNwZWN0UmF0aW8gfHwgXCI5OjE2XCIsXG4gICAgICAgICAgICBxdWFsaXR5OiBcImhpZ2hcIiwgLy8gSElHSCBRVUFMSVRZIGZvciBmaW5hbCBjYXJkXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IFwianBlZ1wiLFxuICAgICAgICAgICAgb3V0cHV0Q29tcHJlc3Npb246IDEwMCxcbiAgICAgICAgICAgIG1vZGVyYXRpb246IFwibG93XCIsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSk/LmRpbWVuc2lvbnMgfHwgXCIxMDI0eDE1MzZcIixcbiAgICAgICAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgICAgIGNhcmRUeXBlOiBzZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBjdXN0b21DYXJkVHlwZSA6IHNlbGVjdGVkVHlwZSxcbiAgICAgICAgICAgIHRvRmllbGQsXG4gICAgICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgICAgICBpc0RyYWZ0TW9kZTogZmFsc2UsXG4gICAgICAgICAgICAuLi4oaW5wdXRJbWFnZXMubGVuZ3RoID4gMCAmJiB7IFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXM6IGlucHV0SW1hZ2VzLFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXNfbW9kZTogXCJmcm9udF9jb3Zlcl9vbmx5XCIgLy8gQWxsIHJlZmVyZW5jZSBpbWFnZXMgc2hvdWxkIGdvIHRvIGZyb250IGNvdmVyIGZvciBjaGFyYWN0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAncHJvY2Vzc2luZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc3RhcnQgZmluYWwgY2FyZCBnZW5lcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHNldEN1cnJlbnRKb2JJZChqb2JJZCk7XG4gICAgICB0b2FzdC5zdWNjZXNzKFwi8J+OqCBHZW5lcmF0aW5nIGhpZ2gtcXVhbGl0eSB2ZXJzaW9uIG9mIHlvdXIgc2VsZWN0ZWQgZGVzaWduIVwiKTtcbiAgICAgIFxuICAgICAgLy8gUG9sbCBmb3IgY29tcGxldGlvbiAocmV1c2UgZXhpc3RpbmcgcG9sbEpvYlN0YXR1cylcbiAgICAgIHBvbGxKb2JTdGF0dXMoam9iSWQpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbmFsIGNhcmQgZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0b2FzdC5lcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBmaW5hbCBjYXJkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgIHNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZChmYWxzZSk7XG4gICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCJcIik7XG4gICAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWNvdmVyeSBmdW5jdGlvbiAtIGNoZWNrIGZvciBwZW5kaW5nIGpvYnMgb24gcGFnZSBsb2FkXG4gIGNvbnN0IGNoZWNrUGVuZGluZ0pvYnMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJykgfHwgJ1tdJyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgam9iSWQgb2YgcGVuZGluZ0pvYnMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICAgIGlmICgham9iRGF0YSkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBqb2IgPSBKU09OLnBhcnNlKGpvYkRhdGEpO1xuICAgICAgICBjb25zdCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IGNoZWNrSm9iU3RhdHVzKGpvYklkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0dXNSZXNwb25zZSAmJiBzdGF0dXNSZXNwb25zZS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfjokgSm9iIGNvbXBsZXRlZCB3aGlsZSB1c2VyIHdhcyBhd2F5ISBDYXJkIGRhdGE6Jywgc3RhdHVzUmVzcG9uc2UuY2FyZERhdGEpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBjb21wbGV0ZWQgam9iIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgICBpZiAoam9iSWQuc3RhcnRzV2l0aCgnZHJhZnQtJykpIHtcbiAgICAgICAgICAgIC8vIERyYWZ0IGpvYiBjb21wbGV0aW9uXG4gICAgICAgICAgICBjb25zdCBkcmFmdEluZGV4ID0gcGFyc2VJbnQoam9iSWQuc3BsaXQoJy0nKVsxXSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzUmVzcG9uc2UuY2FyZERhdGEgJiYgZHJhZnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRyYWZ0Q2FyZDogR2VuZXJhdGVkQ2FyZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogYGRyYWZ0LSR7ZHJhZnRJbmRleCArIDF9LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICAgIHByb21wdDogc3RhdHVzUmVzcG9uc2UuY2FyZERhdGEucHJvbXB0IHx8IGBEcmFmdCBWYXJpYXRpb24gJHtkcmFmdEluZGV4ICsgMX1gLFxuICAgICAgICAgICAgICAgIGZyb250Q292ZXI6IHN0YXR1c1Jlc3BvbnNlLmNhcmREYXRhLmZyb250Q292ZXIgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBiYWNrQ292ZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGVmdFBhZ2U6IFwiXCIsXG4gICAgICAgICAgICAgICAgcmlnaHRQYWdlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRQcm9tcHRzOiB7XG4gICAgICAgICAgICAgICAgICBmcm9udENvdmVyOiBzdGF0dXNSZXNwb25zZS5jYXJkRGF0YS5nZW5lcmF0ZWRQcm9tcHRzPy5mcm9udENvdmVyIHx8IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZXREcmFmdENhcmRzKHByZXYgPT4gWy4uLnByZXYsIGRyYWZ0Q2FyZF0pO1xuICAgICAgICAgICAgICBzZXREcmFmdEluZGV4TWFwcGluZyhwcmV2ID0+IFsuLi5wcmV2LCBkcmFmdEluZGV4XSk7XG4gICAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoYPCfjqggRHJhZnQgdmFyaWF0aW9uICR7ZHJhZnRJbmRleCArIDF9IGNvbXBsZXRlZCB3aGlsZSB5b3Ugd2VyZSBhd2F5IWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWd1bGFyIGNhcmQgY29tcGxldGlvblxuICAgICAgICAgICAgaWYgKHN0YXR1c1Jlc3BvbnNlLmNhcmREYXRhKSB7XG4gICAgICAgICAgICAgIGxldCBjYXJkV2l0aFFSID0geyAuLi5zdGF0dXNSZXNwb25zZS5jYXJkRGF0YSB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKCFjYXJkV2l0aFFSLmNyZWF0ZWRBdCkge1xuICAgICAgICAgICAgICAgIGNhcmRXaXRoUVIuY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjYXJkV2l0aFFSLmNyZWF0ZWRBdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjYXJkV2l0aFFSLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKGNhcmRXaXRoUVIuY3JlYXRlZEF0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKCFjYXJkV2l0aFFSLmlkKSB7XG4gICAgICAgICAgICAgICAgY2FyZFdpdGhRUi5pZCA9IGBjYXJkLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0R2VuZXJhdGVkQ2FyZChjYXJkV2l0aFFSKTtcbiAgICAgICAgICAgICAgc2V0R2VuZXJhdGVkQ2FyZHMoW2NhcmRXaXRoUVJdKTtcbiAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYXJkSW5kZXgoMCk7XG4gICAgICAgICAgICAgIHNldElzQ2FyZENvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgICAgICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiXCIpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHN0YXR1c1Jlc3BvbnNlLmNhcmREYXRhLmdlbmVyYXRpb25UaW1lU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIHNldEdlbmVyYXRpb25EdXJhdGlvbihzdGF0dXNSZXNwb25zZS5jYXJkRGF0YS5nZW5lcmF0aW9uVGltZVNlY29uZHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgICAgICAgICAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMTAwKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoXCLwn46JIFlvdXIgY2FyZCBmaW5pc2hlZCBnZW5lcmF0aW5nIHdoaWxlIHlvdSB3ZXJlIGF3YXkhXCIpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2VuZCB0aGFuayB5b3UgZW1haWwgdXNpbmcgam9iIGRhdGFcbiAgICAgICAgICAgICAgaWYgKGpvYi51c2VyRW1haWwgJiYgam9iLnVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJkVHlwZUZvckVtYWlsID0gam9iLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGpvYi5jdXN0b21DYXJkVHlwZSA6IGpvYi5zZWxlY3RlZFR5cGU7XG4gICAgICAgICAgICAgICAgc2VuZFRoYW5rWW91RW1haWwoam9iLnVzZXJFbWFpbCwgY2FyZFR5cGVGb3JFbWFpbCwgY2FyZFdpdGhRUi5zaGFyZVVybCB8fCAnaHR0cHM6Ly92aWJlY2FyZGluZy5jb20nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZW1vdmVKb2JGcm9tU3RvcmFnZShqb2JJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzUmVzcG9uc2UgJiYgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIC8vIEpvYiBmYWlsZWRcbiAgICAgICAgICB0b2FzdC5lcnJvcihcIuKdjCBBIGNhcmQgZ2VuZXJhdGlvbiBqb2IgZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICByZW1vdmVKb2JGcm9tU3RvcmFnZShqb2JJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzUmVzcG9uc2UgJiYgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzID09PSAncHJvY2Vzc2luZycpIHtcbiAgICAgICAgICAvLyBTdGlsbCBwcm9jZXNzaW5nIC0gcmVzdG9yZSBsb2FkaW5nIHN0YXRlcyBhbmQgc3RhcnQgcG9sbGluZ1xuICAgICAgICAgIHNldElzR2VuZXJhdGluZyh0cnVlKTtcbiAgICAgICAgICBzZXRDdXJyZW50Sm9iSWQoam9iSWQpO1xuICAgICAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlJlc3VtaW5nIGNhcmQgZ2VuZXJhdGlvbi4uLlwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGFydCBlbGFwc2VkIHRpbWUgdHJhY2tpbmcgZnJvbSB3aGVuIGpvYiB3YXMgb3JpZ2luYWxseSBjcmVhdGVkXG4gICAgICAgICAgY29uc3Qgam9iU3RhcnRUaW1lID0gam9iLmNyZWF0ZWRBdCA/IG5ldyBEYXRlKGpvYi5jcmVhdGVkQXQpLmdldFRpbWUoKSA6IERhdGUubm93KCk7XG4gICAgICAgICAgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nKGpvYlN0YXJ0VGltZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdG9hc3QuaW5mbyhcIvCflIQgUmVzdW1pbmcgY2FyZCBnZW5lcmF0aW9uIHdoZXJlIHlvdSBsZWZ0IG9mZi4uLlwiKTtcbiAgICAgICAgICBwb2xsSm9iU3RhdHVzKGpvYklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgcGVuZGluZyBqb2JzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgc3RhdGUgYW5kIGZ1bmN0aW9ucyB0aGF0IHRoZSBVSSBuZWVkc1xuICByZXR1cm4ge1xuICAgIC8vIENvcmUgc3RhdGVcbiAgICBwcm9tcHQsXG4gICAgc2V0UHJvbXB0LFxuICAgIGZpbmFsQ2FyZE1lc3NhZ2UsXG4gICAgc2V0RmluYWxDYXJkTWVzc2FnZSxcbiAgICB0b0ZpZWxkLFxuICAgIHNldFRvRmllbGQsXG4gICAgZnJvbUZpZWxkLFxuICAgIHNldEZyb21GaWVsZCxcbiAgICBzZWxlY3RlZFR5cGUsXG4gICAgc2V0U2VsZWN0ZWRUeXBlLFxuICAgIGN1c3RvbUNhcmRUeXBlLFxuICAgIHNldEN1c3RvbUNhcmRUeXBlLFxuICAgIHNlbGVjdGVkVG9uZSxcbiAgICBzZXRTZWxlY3RlZFRvbmUsXG4gICAgaXNHZW5lcmF0aW5nLFxuICAgIHNldElzR2VuZXJhdGluZyxcbiAgICBpc0dlbmVyYXRpbmdNZXNzYWdlLFxuICAgIHNldElzR2VuZXJhdGluZ01lc3NhZ2UsXG4gICAgZ2VuZXJhdGVkQ2FyZCxcbiAgICBzZXRHZW5lcmF0ZWRDYXJkLFxuICAgIG51bWJlck9mQ2FyZHMsXG4gICAgc2V0TnVtYmVyT2ZDYXJkcyxcbiAgICBnZW5lcmF0ZWRDYXJkcyxcbiAgICBzZXRHZW5lcmF0ZWRDYXJkcyxcbiAgICBzZWxlY3RlZENhcmRJbmRleCxcbiAgICBzZXRTZWxlY3RlZENhcmRJbmRleCxcbiAgICBcbiAgICAvLyBBZHZhbmNlZCBvcHRpb25zXG4gICAgc2hvd0FkdmFuY2VkLFxuICAgIHNldFNob3dBZHZhbmNlZCxcbiAgICBzZWxlY3RlZEFydGlzdGljU3R5bGUsXG4gICAgc2V0U2VsZWN0ZWRBcnRpc3RpY1N0eWxlLFxuICAgIGN1c3RvbVN0eWxlRGVzY3JpcHRpb24sXG4gICAgc2V0Q3VzdG9tU3R5bGVEZXNjcmlwdGlvbixcbiAgICBzZWxlY3RlZEltYWdlTW9kZWwsXG4gICAgc2V0U2VsZWN0ZWRJbWFnZU1vZGVsLFxuICAgIHNlbGVjdGVkRHJhZnRNb2RlbCxcbiAgICBzZXRTZWxlY3RlZERyYWZ0TW9kZWwsXG4gICAgXG4gICAgLy8gRHJhZnQgbW9kZVxuICAgIGlzRHJhZnRNb2RlLFxuICAgIHNldElzRHJhZnRNb2RlLFxuICAgIGRyYWZ0Q2FyZHMsXG4gICAgc2V0RHJhZnRDYXJkcyxcbiAgICBkcmFmdEluZGV4TWFwcGluZyxcbiAgICBzZXREcmFmdEluZGV4TWFwcGluZyxcbiAgICBzZWxlY3RlZERyYWZ0SW5kZXgsXG4gICAgc2V0U2VsZWN0ZWREcmFmdEluZGV4LFxuICAgIGlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCxcbiAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQsXG4gICAgcHJldmlld2luZ0RyYWZ0SW5kZXgsXG4gICAgc2V0UHJldmlld2luZ0RyYWZ0SW5kZXgsXG4gICAgZHJhZnRDb21wbGV0aW9uU2hvd24sXG4gICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24sXG4gICAgZHJhZnRDb21wbGV0aW9uQ291bnQsXG4gICAgc2V0RHJhZnRDb21wbGV0aW9uQ291bnQsXG4gICAgXG4gICAgLy8gUHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzLFxuICAgIHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgaXNDYXJkQ29tcGxldGVkLFxuICAgIHNldElzQ2FyZENvbXBsZXRlZCxcbiAgICBcbiAgICAvLyBVcGxvYWQgYW5kIHBlcnNvbmFsaXphdGlvblxuICAgIHJlZmVyZW5jZUltYWdlcyxcbiAgICBzZXRSZWZlcmVuY2VJbWFnZXMsXG4gICAgcmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgIHNldFJlZmVyZW5jZUltYWdlVXJscyxcbiAgICBpbWFnZVRyYW5zZm9ybWF0aW9uLFxuICAgIHNldEltYWdlVHJhbnNmb3JtYXRpb24sXG4gICAgaXNVcGxvYWRpbmcsXG4gICAgc2V0SXNVcGxvYWRpbmcsXG4gICAgXG4gICAgLy8gRW1haWwgYW5kIHNldHRpbmdzXG4gICAgdXNlckVtYWlsLFxuICAgIHNldFVzZXJFbWFpbCxcbiAgICBpc0hhbmR3cml0dGVuTWVzc2FnZSxcbiAgICBzZXRJc0hhbmR3cml0dGVuTWVzc2FnZSxcbiAgICBpc0Zyb250QmFja09ubHksXG4gICAgc2V0SXNGcm9udEJhY2tPbmx5LFxuICAgIHNlbGVjdGVkUGFwZXJTaXplLFxuICAgIHNldFNlbGVjdGVkUGFwZXJTaXplLFxuICAgIFxuICAgIC8vIFVJIHN0YXRlXG4gICAgaXNUZXh0YXJlYUV4cGFuZGVkLFxuICAgIHNldElzVGV4dGFyZWFFeHBhbmRlZCxcbiAgICBpc01lc3NhZ2VFeHBhbmRlZCxcbiAgICBzZXRJc01lc3NhZ2VFeHBhbmRlZCxcbiAgICBzaG93U2V0dGluZ3MsXG4gICAgc2V0U2hvd1NldHRpbmdzLFxuICAgIHNob3dUZW1wbGF0ZUdhbGxlcnksXG4gICAgc2V0U2hvd1RlbXBsYXRlR2FsbGVyeSxcbiAgICBzaG93UHJpbnRDb25maXJtYXRpb24sXG4gICAgc2V0U2hvd1ByaW50Q29uZmlybWF0aW9uLFxuICAgIFxuICAgIC8vIEdlbmVyYXRpb24gdGltZVxuICAgIGdlbmVyYXRpb25EdXJhdGlvbixcbiAgICBzZXRHZW5lcmF0aW9uRHVyYXRpb24sXG4gICAgY3VycmVudEVsYXBzZWRUaW1lLFxuICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZSxcbiAgICBcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gICAgZm9ybWF0R2VuZXJhdGlvblRpbWUsXG4gICAgZm9ybWF0Q291bnRkb3duLFxuICAgIHNlbmRUaGFua1lvdUVtYWlsLFxuICAgIGNoYXRXaXRoQUksXG4gICAgc2Nyb2xsVG9DYXJkUHJldmlldyxcbiAgICBcbiAgICAvLyBUaW1lIHRyYWNraW5nIGZ1bmN0aW9uc1xuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICBcbiAgICAvLyBGaWxlIGhhbmRsaW5nIGZ1bmN0aW9uc1xuICAgIGhhbmRsZUZpbGVVcGxvYWQsXG4gICAgaGFuZGxlUmVtb3ZlUmVmZXJlbmNlSW1hZ2UsXG4gICAgXG4gICAgLy8gTWVzc2FnZSBmdW5jdGlvbnNcbiAgICBoYW5kbGVHZXRNZXNzYWdlSGVscCxcbiAgICBhZGRNZXNzYWdlVG9IaXN0b3J5LFxuICAgIHVuZG9NZXNzYWdlLFxuICAgIHJlZG9NZXNzYWdlLFxuICAgIFxuICAgIC8vIEpvYiBtYW5hZ2VtZW50XG4gICAgc2F2ZUpvYlRvU3RvcmFnZSxcbiAgICByZW1vdmVKb2JGcm9tU3RvcmFnZSxcbiAgICBjaGVja0pvYlN0YXR1cyxcbiAgICBwb2xsSm9iU3RhdHVzLFxuICAgIGNoZWNrUGVuZGluZ0pvYnMsXG4gICAgXG4gICAgLy8gTWFpbiBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGhhbmRsZUdlbmVyYXRlQ2FyZEFzeW5jLFxuICAgIGhhbmRsZUdlbmVyYXRlRHJhZnRDYXJkcyxcbiAgICBoYW5kbGVHZW5lcmF0ZUZpbmFsRnJvbURyYWZ0LFxuICAgIFxuICAgIC8vIEFkZGl0aW9uYWwgc3RhdGUgZm9yIG1lc3NhZ2UgcmVmaW5lbWVudFxuICAgIG1lc3NhZ2VIaXN0b3J5LFxuICAgIHNldE1lc3NhZ2VIaXN0b3J5LFxuICAgIGN1cnJlbnRNZXNzYWdlSW5kZXgsXG4gICAgc2V0Q3VycmVudE1lc3NhZ2VJbmRleCxcbiAgICByZWZpbmVtZW50UHJvbXB0LFxuICAgIHNldFJlZmluZW1lbnRQcm9tcHQsXG4gICAgaXNSZWZpbmluZ01lc3NhZ2UsXG4gICAgc2V0SXNSZWZpbmluZ01lc3NhZ2UsXG4gICAgc2hvd1JlZmluZW1lbnRCb3gsXG4gICAgc2V0U2hvd1JlZmluZW1lbnRCb3gsXG4gICAgXG4gICAgLy8gVGVtcGxhdGUgc3RhdGVcbiAgICBzaG93VGVtcGxhdGVDdXN0b21pemF0aW9uLFxuICAgIHNldFNob3dUZW1wbGF0ZUN1c3RvbWl6YXRpb24sXG4gICAgc2VsZWN0ZWRUZW1wbGF0ZSxcbiAgICBzZXRTZWxlY3RlZFRlbXBsYXRlLFxuICAgIHRlbXBsYXRlQ3VzdG9taXphdGlvbnMsXG4gICAgc2V0VGVtcGxhdGVDdXN0b21pemF0aW9ucyxcbiAgICB0ZW1wbGF0ZVNlYXJjaFF1ZXJ5LFxuICAgIHNldFRlbXBsYXRlU2VhcmNoUXVlcnksXG4gICAgaXNTZWFyY2hpbmdUZW1wbGF0ZXMsXG4gICAgc2V0SXNTZWFyY2hpbmdUZW1wbGF0ZXMsXG4gICAgYWlGaWx0ZXJlZENhcmRzLFxuICAgIHNldEFpRmlsdGVyZWRDYXJkcyxcbiAgICBzZWFyY2hNb2RlLFxuICAgIHNldFNlYXJjaE1vZGUsXG4gICAgdGV4dEZpbHRlcmVkQ2FyZHMsXG4gICAgc2V0VGV4dEZpbHRlcmVkQ2FyZHMsXG4gICAgc2hvd1Byb21wdHMsXG4gICAgc2V0U2hvd1Byb21wdHMsXG4gICAgXG4gICAgLy8gUHJpbnQgc3RhdGVcbiAgICBwcmludE9wdGlvbixcbiAgICBzZXRQcmludE9wdGlvbixcbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIGRyYWZ0IG1vZGUgc3RhdGUgLSByZW1vdmVkIGR1cGxpY2F0ZXNcbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIHVwbG9hZCBzdGF0ZVxuICAgIGhhbmR3cml0aW5nU2FtcGxlLFxuICAgIHNldEhhbmR3cml0aW5nU2FtcGxlLFxuICAgIGhhbmR3cml0aW5nU2FtcGxlVXJsLFxuICAgIHNldEhhbmR3cml0aW5nU2FtcGxlVXJsLFxuICAgIFxuICAgIC8vIEpvYiB0cmFja2luZ1xuICAgIGN1cnJlbnRKb2JJZCxcbiAgICBzZXRDdXJyZW50Sm9iSWQsXG4gICAgY291bnRkb3duLFxuICAgIHNldENvdW50ZG93bixcbiAgICBjb3VudGRvd25JbnRlcnZhbCxcbiAgICBzZXRDb3VudGRvd25JbnRlcnZhbCxcbiAgICBcbiAgICAvLyBTZWN0aW9uIGxvYWRpbmcgc3RhdGVzXG4gICAgc2VjdGlvbkxvYWRpbmdTdGF0ZXMsXG4gICAgc2V0U2VjdGlvbkxvYWRpbmdTdGF0ZXMsXG4gICAgXG4gICAgLy8gRmFzdCBwcmV2aWV3IG1vZGVcbiAgICBmYXN0UHJldmlld01vZGUsXG4gICAgc2V0RmFzdFByZXZpZXdNb2RlLFxuICAgIFxuICAgIC8vIEFkZGl0aW9uYWwgdHJhY2tpbmdcbiAgICBjdXJyZW50Q2FyZElkLFxuICAgIHNldEN1cnJlbnRDYXJkSWQsXG4gICAgaXNJbml0aWFsTG9hZENvbXBsZXRlLFxuICAgIHNldElzSW5pdGlhbExvYWRDb21wbGV0ZSxcbiAgICBcbiAgICAvLyBFbGFwc2VkIHRpbWUgdHJhY2tpbmdcbiAgICBnZW5lcmF0aW9uU3RhcnRUaW1lLFxuICAgIHNldEdlbmVyYXRpb25TdGFydFRpbWUsXG4gICAgZWxhcHNlZFRpbWVJbnRlcnZhbCxcbiAgICBzZXRFbGFwc2VkVGltZUludGVydmFsLFxuICAgIFxuICAgIC8vIENvbnN0YW50cyBmb3IgVUlcbiAgICBhcnRpc3RpY1N0eWxlcyxcbiAgICBwYXBlclNpemVzLFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ0b2FzdCIsInY0IiwidXVpZHY0IiwiQkFDS0VORF9BUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9BUElfVVJMIiwiZm9ybWF0Q291bnRkb3duIiwic2Vjb25kcyIsIm1pbnV0ZXMiLCJNYXRoIiwiZmxvb3IiLCJyZW1haW5pbmdTZWNvbmRzIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImZvcm1hdEdlbmVyYXRpb25UaW1lIiwiZHVyYXRpb25TZWNvbmRzIiwic2VuZFRoYW5rWW91RW1haWwiLCJ0b0VtYWlsIiwiY2FyZFR5cGUiLCJjYXJkVXJsIiwidHJpbSIsImh0bWxCb2R5IiwidGV4dEJvZHkiLCJ1c2VyUmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRvIiwiZnJvbSIsInN1YmplY3QiLCJ0ZXh0IiwiaHRtbCIsImFkbWluUmVzcG9uc2UiLCJvayIsInN1Y2Nlc3MiLCJlcnJvciIsImNvbnNvbGUiLCJjaGF0V2l0aEFJIiwidXNlck1lc3NhZ2UiLCJvcHRpb25zIiwic3lzdGVtUHJvbXB0IiwibW9kZWwiLCJpbmNsdWRlVGhvdWdodHMiLCJqc29uU2NoZW1hIiwiYXR0YWNobWVudHMiLCJyZXNwb25zZSIsInRvb2xfbmFtZSIsImFyZ3VtZW50cyIsIm1lc3NhZ2VzIiwic3lzdGVtX3Byb21wdCIsImluY2x1ZGVfdGhvdWdodHMiLCJqc29uX3NjaGVtYSIsImxlbmd0aCIsIkVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJyZXN1bHQiLCJwYXJzZSIsIm1lc3NhZ2UiLCJjYXJkVG9uZXMiLCJpZCIsImxhYmVsIiwiZGVzY3JpcHRpb24iLCJhcnRpc3RpY1N0eWxlcyIsInByb21wdE1vZGlmaWVyIiwicGFwZXJTaXplcyIsImFzcGVjdFJhdGlvIiwiZGltZW5zaW9ucyIsInByaW50V2lkdGgiLCJwcmludEhlaWdodCIsInVzZUNhcmRTdHVkaW8iLCJwcm9tcHQiLCJzZXRQcm9tcHQiLCJmaW5hbENhcmRNZXNzYWdlIiwic2V0RmluYWxDYXJkTWVzc2FnZSIsInRvRmllbGQiLCJzZXRUb0ZpZWxkIiwiZnJvbUZpZWxkIiwic2V0RnJvbUZpZWxkIiwic2VsZWN0ZWRUeXBlIiwic2V0U2VsZWN0ZWRUeXBlIiwiY3VzdG9tQ2FyZFR5cGUiLCJzZXRDdXN0b21DYXJkVHlwZSIsInNlbGVjdGVkVG9uZSIsInNldFNlbGVjdGVkVG9uZSIsImlzR2VuZXJhdGluZyIsInNldElzR2VuZXJhdGluZyIsImdlbmVyYXRlZENhcmQiLCJzZXRHZW5lcmF0ZWRDYXJkIiwibnVtYmVyT2ZDYXJkcyIsInNldE51bWJlck9mQ2FyZHMiLCJnZW5lcmF0ZWRDYXJkcyIsInNldEdlbmVyYXRlZENhcmRzIiwic2VsZWN0ZWRDYXJkSW5kZXgiLCJzZXRTZWxlY3RlZENhcmRJbmRleCIsImlzR2VuZXJhdGluZ01lc3NhZ2UiLCJzZXRJc0dlbmVyYXRpbmdNZXNzYWdlIiwic2hvd0FkdmFuY2VkIiwic2V0U2hvd0FkdmFuY2VkIiwic2VsZWN0ZWRBcnRpc3RpY1N0eWxlIiwic2V0U2VsZWN0ZWRBcnRpc3RpY1N0eWxlIiwiY3VzdG9tU3R5bGVEZXNjcmlwdGlvbiIsInNldEN1c3RvbVN0eWxlRGVzY3JpcHRpb24iLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJzZXRTZWxlY3RlZEltYWdlTW9kZWwiLCJzZWxlY3RlZERyYWZ0TW9kZWwiLCJzZXRTZWxlY3RlZERyYWZ0TW9kZWwiLCJnZW5lcmF0aW9uUHJvZ3Jlc3MiLCJzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MiLCJjb3VudGRvd24iLCJzZXRDb3VudGRvd24iLCJjb3VudGRvd25JbnRlcnZhbCIsInNldENvdW50ZG93bkludGVydmFsIiwiaXNDYXJkQ29tcGxldGVkIiwic2V0SXNDYXJkQ29tcGxldGVkIiwiY3VycmVudEpvYklkIiwic2V0Q3VycmVudEpvYklkIiwiZmFzdFByZXZpZXdNb2RlIiwic2V0RmFzdFByZXZpZXdNb2RlIiwiaXNEcmFmdE1vZGUiLCJzZXRJc0RyYWZ0TW9kZSIsImRyYWZ0Q2FyZHMiLCJzZXREcmFmdENhcmRzIiwiZHJhZnRJbmRleE1hcHBpbmciLCJzZXREcmFmdEluZGV4TWFwcGluZyIsInNlbGVjdGVkRHJhZnRJbmRleCIsInNldFNlbGVjdGVkRHJhZnRJbmRleCIsImlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCIsInNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZCIsInByZXZpZXdpbmdEcmFmdEluZGV4Iiwic2V0UHJldmlld2luZ0RyYWZ0SW5kZXgiLCJkcmFmdENvbXBsZXRpb25TaG93biIsInNldERyYWZ0Q29tcGxldGlvblNob3duIiwiZHJhZnRDb21wbGV0aW9uQ291bnQiLCJzZXREcmFmdENvbXBsZXRpb25Db3VudCIsImhhbmR3cml0aW5nU2FtcGxlIiwic2V0SGFuZHdyaXRpbmdTYW1wbGUiLCJoYW5kd3JpdGluZ1NhbXBsZVVybCIsInNldEhhbmR3cml0aW5nU2FtcGxlVXJsIiwicmVmZXJlbmNlSW1hZ2VzIiwic2V0UmVmZXJlbmNlSW1hZ2VzIiwicmVmZXJlbmNlSW1hZ2VVcmxzIiwic2V0UmVmZXJlbmNlSW1hZ2VVcmxzIiwiaW1hZ2VUcmFuc2Zvcm1hdGlvbiIsInNldEltYWdlVHJhbnNmb3JtYXRpb24iLCJpc1VwbG9hZGluZyIsInNldElzVXBsb2FkaW5nIiwidXNlckVtYWlsIiwic2V0VXNlckVtYWlsIiwiY3VycmVudENhcmRJZCIsInNldEN1cnJlbnRDYXJkSWQiLCJpc0hhbmR3cml0dGVuTWVzc2FnZSIsInNldElzSGFuZHdyaXR0ZW5NZXNzYWdlIiwiaXNGcm9udEJhY2tPbmx5Iiwic2V0SXNGcm9udEJhY2tPbmx5Iiwic2VsZWN0ZWRQYXBlclNpemUiLCJzZXRTZWxlY3RlZFBhcGVyU2l6ZSIsInNlY3Rpb25Mb2FkaW5nU3RhdGVzIiwic2V0U2VjdGlvbkxvYWRpbmdTdGF0ZXMiLCJmcm9udENvdmVyIiwiYmFja0NvdmVyIiwibGVmdEludGVyaW9yIiwicmlnaHRJbnRlcmlvciIsInByb2dyZXNzUGVyY2VudGFnZSIsInNldFByb2dyZXNzUGVyY2VudGFnZSIsImlzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNldElzSW5pdGlhbExvYWRDb21wbGV0ZSIsImlzVGV4dGFyZWFFeHBhbmRlZCIsInNldElzVGV4dGFyZWFFeHBhbmRlZCIsImlzTWVzc2FnZUV4cGFuZGVkIiwic2V0SXNNZXNzYWdlRXhwYW5kZWQiLCJtZXNzYWdlSGlzdG9yeSIsInNldE1lc3NhZ2VIaXN0b3J5IiwiY3VycmVudE1lc3NhZ2VJbmRleCIsInNldEN1cnJlbnRNZXNzYWdlSW5kZXgiLCJyZWZpbmVtZW50UHJvbXB0Iiwic2V0UmVmaW5lbWVudFByb21wdCIsImlzUmVmaW5pbmdNZXNzYWdlIiwic2V0SXNSZWZpbmluZ01lc3NhZ2UiLCJzaG93UmVmaW5lbWVudEJveCIsInNldFNob3dSZWZpbmVtZW50Qm94Iiwic2hvd1NldHRpbmdzIiwic2V0U2hvd1NldHRpbmdzIiwic2hvd1RlbXBsYXRlR2FsbGVyeSIsInNldFNob3dUZW1wbGF0ZUdhbGxlcnkiLCJ0ZW1wbGF0ZVNlYXJjaFF1ZXJ5Iiwic2V0VGVtcGxhdGVTZWFyY2hRdWVyeSIsImlzU2VhcmNoaW5nVGVtcGxhdGVzIiwic2V0SXNTZWFyY2hpbmdUZW1wbGF0ZXMiLCJhaUZpbHRlcmVkQ2FyZHMiLCJzZXRBaUZpbHRlcmVkQ2FyZHMiLCJzZWFyY2hNb2RlIiwic2V0U2VhcmNoTW9kZSIsInRleHRGaWx0ZXJlZENhcmRzIiwic2V0VGV4dEZpbHRlcmVkQ2FyZHMiLCJzaG93UHJvbXB0cyIsInNldFNob3dQcm9tcHRzIiwicHJpbnRPcHRpb24iLCJzZXRQcmludE9wdGlvbiIsInNob3dQcmludENvbmZpcm1hdGlvbiIsInNldFNob3dQcmludENvbmZpcm1hdGlvbiIsImdlbmVyYXRpb25EdXJhdGlvbiIsInNldEdlbmVyYXRpb25EdXJhdGlvbiIsImdlbmVyYXRpb25TdGFydFRpbWUiLCJzZXRHZW5lcmF0aW9uU3RhcnRUaW1lIiwiY3VycmVudEVsYXBzZWRUaW1lIiwic2V0Q3VycmVudEVsYXBzZWRUaW1lIiwiZWxhcHNlZFRpbWVJbnRlcnZhbCIsInNldEVsYXBzZWRUaW1lSW50ZXJ2YWwiLCJzaG93VGVtcGxhdGVDdXN0b21pemF0aW9uIiwic2V0U2hvd1RlbXBsYXRlQ3VzdG9taXphdGlvbiIsInNlbGVjdGVkVGVtcGxhdGUiLCJzZXRTZWxlY3RlZFRlbXBsYXRlIiwidGVtcGxhdGVDdXN0b21pemF0aW9ucyIsInNldFRlbXBsYXRlQ3VzdG9taXphdGlvbnMiLCJwcm9tcHRDaGFuZ2VzIiwibWVzc2FnZUNoYW5nZXMiLCJ1c2VSZWZlcmVuY2VJbWFnZSIsInJlZmVyZW5jZUltYWdlRmlsZSIsInJlZmVyZW5jZUltYWdlVHJhbnNmb3JtYXRpb24iLCJzYXZlSm9iVG9TdG9yYWdlIiwiam9iSWQiLCJqb2JEYXRhIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJwZW5kaW5nSm9icyIsImdldEl0ZW0iLCJpbmNsdWRlcyIsInB1c2giLCJzY3JvbGxUb0NhcmRQcmV2aWV3Iiwic2V0VGltZW91dCIsImNhcmRQcmV2aWV3RWxlbWVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInNjcm9sbEludG9WaWV3IiwiYmVoYXZpb3IiLCJibG9jayIsInN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyIsInN0YXJ0VGltZSIsImVzdGltYXRlZFRvdGFsU2Vjb25kcyIsInN0YXJ0IiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwiZXN0aW1hdGVkVG90YWwiLCJwZXJjZW50YWdlIiwibWluIiwic3RvcEVsYXBzZWRUaW1lVHJhY2tpbmciLCJyZW1vdmVJdGVtIiwiaGFuZGxlRmlsZVVwbG9hZCIsImZpbGUiLCJ0eXBlIiwic3RhcnRzV2l0aCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ1cmwiLCJwcmV2IiwibG9nIiwiZmlsZU5hbWUiLCJuYW1lIiwidG90YWxJbWFnZXMiLCJoYW5kbGVSZW1vdmVSZWZlcmVuY2VJbWFnZSIsImluZGV4IiwicmVtb3ZlZEltYWdlIiwicmVtb3ZlZFVybCIsImZpbHRlciIsIl8iLCJpIiwicmVtYWluaW5nSW1hZ2VzIiwiYWRkTWVzc2FnZVRvSGlzdG9yeSIsImNsZWFuTWVzc2FnZSIsInJlcGxhY2UiLCJuZXdIaXN0b3J5Iiwic2xpY2UiLCJzaGlmdCIsInVuZG9NZXNzYWdlIiwibmV3SW5kZXgiLCJyZWRvTWVzc2FnZSIsImhhbmRsZUdldE1lc3NhZ2VIZWxwIiwiY2FyZFR5cGVGb3JQcm9tcHQiLCJzZWxlY3RlZFRvbmVPYmoiLCJmaW5kIiwidG9uZSIsInRvbmVEZXNjcmlwdGlvbiIsInRvTG93ZXJDYXNlIiwiZWZmZWN0aXZlUHJvbXB0IiwibWVzc2FnZVByb21wdCIsImdlbmVyYXRlZE1lc3NhZ2UiLCJtZXNzYWdlTWF0Y2giLCJtYXRjaCIsImV4dHJhY3RlZE1lc3NhZ2UiLCJoYW5kbGVHZW5lcmF0ZUNhcmRBc3luYyIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwidW5kZWZpbmVkIiwibWVzc2FnZUNvbnRlbnQiLCJhdXRvTWVzc2FnZVByb21wdCIsInNlbGVjdGVkU3R5bGUiLCJzdHlsZSIsInN0eWxlTW9kaWZpZXIiLCJwYXBlckNvbmZpZyIsInNpemUiLCJwcm9tcHRHZW5lcmF0aW9uUXVlcnkiLCJnZW5lcmF0ZWRQcm9tcHRzIiwicHJvcGVydGllcyIsInJlcXVpcmVkIiwicHJvbXB0cyIsImlucHV0SW1hZ2VzIiwiY29uZmlnIiwidXNlck51bWJlciIsIm1vZGVsVmVyc2lvbiIsInF1YWxpdHkiLCJvdXRwdXRGb3JtYXQiLCJvdXRwdXRDb21wcmVzc2lvbiIsIm1vZGVyYXRpb24iLCJpbnB1dF9pbWFnZXMiLCJpbnB1dF9pbWFnZXNfbW9kZSIsInBvbGxKb2JTdGF0dXMiLCJyZW1vdmVKb2JGcm9tU3RvcmFnZSIsImhhbmRsZUdlbmVyYXRlRHJhZnRDYXJkcyIsInN0eWxlTWVzc2FnZSIsImRyYWZ0UHJvbWlzZXMiLCJBcnJheSIsInN0eWxlT3ZlcnJpZGUiLCJzdHlsZUxhYmVsIiwicHJlZGVmaW5lZFN0eWxlcyIsInN0eWxlTGFiZWxzIiwiZnJvbnRDb3ZlclByb21wdFF1ZXJ5IiwiZnJvbnRDb3ZlclByb21wdCIsImVuaGFuY2VkRnJvbnRDb3ZlclByb21wdCIsImlzRHJhZnQiLCJkcmFmdEluZGV4Iiwic3R5bGVJbmZvIiwic3R5bGVOYW1lIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJjaGVja0pvYlN0YXR1cyIsImF0dGVtcHQiLCJzdGF0dXNSZXNwb25zZSIsImlzRHJhZnRKb2IiLCJwYXJzZUludCIsInNwbGl0IiwiY2FyZERhdGEiLCJkcmFmdENhcmQiLCJsZWZ0UGFnZSIsInJpZ2h0UGFnZSIsInVwZGF0ZWQiLCJ1cGRhdGVkTWFwcGluZyIsIm5ld0NvbXBsZXRlZENvdW50IiwiY2FyZFdpdGhRUiIsInJhbmRvbSIsInN1YnN0ciIsImNhcmRTdG9yZVJlc3BvbnNlIiwiY2FyZFN0b3JlRGF0YSIsImFjdHVhbFNoYXJlVXJsIiwic2hhcmVfdXJsIiwib3JpZ2luYWxCYWNrQ292ZXIiLCJzaGFyZVVybCIsIndhcm4iLCJnZW5lcmF0aW9uVGltZVNlY29uZHMiLCJjYXJkVHlwZUZvckVtYWlsIiwiZGVsYXkiLCJwb3ciLCJ1cGRhdGVkSm9icyIsImhhbmRsZUdlbmVyYXRlRmluYWxGcm9tRHJhZnQiLCJkaXNwbGF5SW5kZXgiLCJvcmlnaW5hbERyYWZ0SW5kZXgiLCJyZW1haW5pbmdEcmFmdHMiLCJpbmZvIiwic2VsZWN0ZWREcmFmdCIsInN0b3JlZEZyb250Q292ZXJQcm9tcHQiLCJzdWJzdHJpbmciLCJkcmFmdFN0eWxlSW5mbyIsImdlbmVyYXRlT3RoZXJQcm9tcHRzUXVlcnkiLCJmaW5hbFByb21wdHMiLCJoYXNGcm9udENvdmVyIiwiaGFzQmFja0NvdmVyIiwiaGFzTGVmdEludGVyaW9yIiwiaGFzUmlnaHRJbnRlcmlvciIsImNoZWNrUGVuZGluZ0pvYnMiLCJqb2IiLCJqb2JTdGFydFRpbWUiLCJnZXRUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardStudio.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts":
/*!**********************************************!*\
  !*** ./hooks/cardStudio/useJobManagement.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useJobManagement: function() { return /* binding */ useJobManagement; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useJobManagement auto */ \nfunction useJobManagement() {\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [progressPercentage, setProgressPercentage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [generationStartTime, setGenerationStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentElapsedTime, setCurrentElapsedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [elapsedTimeInterval, setElapsedTimeInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentJobType, setCurrentJobType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Job management functions\n    const saveJobToStorage = (jobId, jobData)=>{\n        if (false) {}\n        try {\n            // Enhanced job data with progress, state, and expiration\n            const enhancedJobData = {\n                ...jobData,\n                id: jobId,\n                status: \"processing\",\n                createdAt: Date.now(),\n                expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,\n                lastProgress: progressPercentage,\n                lastProgressText: generationProgress,\n                elapsedTime: currentElapsedTime\n            };\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(enhancedJobData));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            if (!pendingJobs.includes(jobId)) {\n                pendingJobs.push(jobId);\n                localStorage.setItem(\"pendingCardJobs\", JSON.stringify(pendingJobs));\n            }\n            // Run cleanup of expired jobs\n            cleanupExpiredJobs();\n        } catch (error) {\n            console.error(\"Failed to save job to localStorage:\", error);\n        }\n    };\n    // Update job progress in storage\n    const updateJobProgress = (jobId, progress, progressText)=>{\n        if (false) {}\n        try {\n            const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n            if (!jobData) return;\n            const job = JSON.parse(jobData);\n            job.lastProgress = progress;\n            job.lastProgressText = progressText;\n            job.elapsedTime = currentElapsedTime;\n            job.lastUpdate = Date.now();\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(job));\n        } catch (error) {\n            console.error(\"Failed to update job progress:\", error);\n        }\n    };\n    // Remove job from storage\n    const removeJobFromStorage = (jobId)=>{\n        if (false) {}\n        try {\n            localStorage.removeItem(\"cardJob_\".concat(jobId));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const updatedJobs = pendingJobs.filter((id)=>id !== jobId);\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(updatedJobs));\n        } catch (error) {\n            console.error(\"Failed to remove job from localStorage:\", error);\n        }\n    };\n    // Cleanup expired jobs from localStorage\n    const cleanupExpiredJobs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        const now = Date.now();\n        const keysToRemove = [];\n        // Check all localStorage keys\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith(\"cardJob_\")) {\n                try {\n                    const jobData = localStorage.getItem(key);\n                    if (jobData) {\n                        const job = JSON.parse(jobData);\n                        // Remove if expired or corrupted data\n                        if (!job.expiresAt || job.expiresAt < now) {\n                            keysToRemove.push(key);\n                        }\n                    }\n                } catch (error) {\n                    // Remove corrupted data\n                    keysToRemove.push(key);\n                }\n            }\n        });\n        // Remove expired jobs\n        keysToRemove.forEach((key)=>{\n            localStorage.removeItem(key);\n            console.log(\"\\uD83E\\uDDF9 Removed expired job: \".concat(key));\n        });\n        // Update pending jobs list\n        if (keysToRemove.length > 0) {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const cleanedJobs = pendingJobs.filter((jobId)=>!keysToRemove.includes(\"cardJob_\".concat(jobId)));\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(cleanedJobs));\n        }\n    }, []);\n    // Start elapsed time tracking\n    const startElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let jobType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"final\";\n        const start = Date.now();\n        setGenerationStartTime(start);\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setCurrentJobType(jobType);\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n        }\n        // Expected durations in seconds\n        const expectedDuration = jobType === \"draft\" ? 45 : 105; // 45s for draft, 105s for final\n        const interval = setInterval(()=>{\n            const elapsed = (Date.now() - start) / 1000;\n            setCurrentElapsedTime(elapsed);\n            // Calculate progress based on elapsed time\n            // Progress increases linearly up to 95% at expected duration\n            // Then slows down to reach 99% at 2x expected duration\n            let progress = 0;\n            if (elapsed < expectedDuration) {\n                // Linear progress up to 95%\n                progress = elapsed / expectedDuration * 95;\n            } else {\n                // Slow progress from 95% to 99% over the next expectedDuration seconds\n                const overtime = elapsed - expectedDuration;\n                const overtimeProgress = Math.min(overtime / expectedDuration, 1) * 4; // 4% more\n                progress = 95 + overtimeProgress;\n            }\n            setProgressPercentage(Math.min(Math.round(progress), 99));\n        }, 100); // Update every 100ms for smooth progress\n        setElapsedTimeInterval(interval);\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Stop elapsed time tracking\n    const stopElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n            setElapsedTimeInterval(null);\n        }\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Clear all job data from localStorage\n    const clearAllJobData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        console.log(\"\\uD83E\\uDDF9 Clearing all job data from localStorage\");\n        // Get all keys\n        const keys = Object.keys(localStorage);\n        // Remove all job-related keys\n        keys.forEach((key)=>{\n            if (key.startsWith(\"cardJob_\") || key === \"pendingCardJobs\" || key === \"generation-start-time\") {\n                localStorage.removeItem(key);\n            }\n        });\n        // Reset state\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setGenerationStartTime(null);\n    }, []);\n    // Recovery function - resume WebSocket subscriptions for pending jobs\n    const checkPendingJobs = async ()=>{\n        if (false) {}\n        try {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const jobsData = [];\n            for (const jobId of pendingJobs){\n                const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n                if (!jobData) continue;\n                const job = JSON.parse(jobData);\n                jobsData.push({\n                    jobId,\n                    job\n                });\n            }\n            return jobsData;\n        } catch (error) {\n            console.error(\"Failed to check pending jobs:\", error);\n            return [];\n        }\n    };\n    // Load most recent draft batch (5 cards)\n    const loadMostRecentDraftBatch = ()=>{\n        if (false) {}\n        try {\n            // Get all localStorage keys\n            const keys = Object.keys(localStorage);\n            const draftJobKeys = keys.filter((key)=>key.startsWith(\"cardJob_draft-\"));\n            console.log(\"\\uD83D\\uDD0D Found \".concat(draftJobKeys.length, \" draft job keys in localStorage\"));\n            const draftJobs = [];\n            // Find all draft job entries\n            for (const key of draftJobKeys){\n                const jobData = localStorage.getItem(key);\n                if (jobData) {\n                    try {\n                        var _job_draftCards;\n                        const job = JSON.parse(jobData);\n                        console.log(\"\\uD83D\\uDCC4 Checking \".concat(key, \":\"), {\n                            hasDraftCards: !!job.draftCards,\n                            cardCount: ((_job_draftCards = job.draftCards) === null || _job_draftCards === void 0 ? void 0 : _job_draftCards.length) || 0,\n                            createdAt: job.createdAt\n                        });\n                        if (job.draftCards && Array.isArray(job.draftCards) && job.draftCards.length > 0) {\n                            draftJobs.push({\n                                key,\n                                job,\n                                createdAt: job.createdAt || 0\n                            });\n                        }\n                    } catch (e) {\n                        console.error(\"Failed to parse \".concat(key, \":\"), e);\n                    }\n                }\n            }\n            // If no draft jobs found, return null\n            if (draftJobs.length === 0) return null;\n            // Sort by creation time (newest first)\n            draftJobs.sort((a, b)=>b.createdAt - a.createdAt);\n            // Get the most recent batch (they should all have similar timestamps)\n            const mostRecentTimestamp = draftJobs[0].createdAt;\n            const recentBatch = draftJobs.filter((job)=>{\n                // Consider jobs within 5 minutes of each other as the same batch\n                return Math.abs(job.createdAt - mostRecentTimestamp) < 5 * 60 * 1000;\n            });\n            // Collect all draft cards from the batch, avoiding duplicates\n            const draftCardMap = new Map();\n            for (const { job } of recentBatch){\n                if (job.draftCards && job.draftCards.length > 0) {\n                    var _draftCard_id_match;\n                    // Each job now stores only one draft card\n                    const draftCard = job.draftCards[0];\n                    const draftIndex = job.draftIndex !== undefined ? job.draftIndex : parseInt(((_draftCard_id_match = draftCard.id.match(/draft-(\\d+)-/)) === null || _draftCard_id_match === void 0 ? void 0 : _draftCard_id_match[1]) || \"0\") - 1;\n                    // Use draft index as key to avoid duplicates\n                    if (!draftCardMap.has(draftIndex)) {\n                        draftCardMap.set(draftIndex, draftCard);\n                    }\n                }\n            }\n            // Convert map to array and sort by draft index\n            const allDraftCards = Array.from(draftCardMap.entries()).sort((a, b)=>a[0] - b[0]).map((param)=>{\n                let [_, card] = param;\n                return card;\n            });\n            console.log(\"\\uD83D\\uDCCB Loaded \".concat(allDraftCards.length, \" unique draft cards from batch\"));\n            // Return the batch info\n            return {\n                cards: allDraftCards,\n                createdAt: mostRecentTimestamp,\n                count: allDraftCards.length\n            };\n        } catch (error) {\n            console.error(\"Failed to load recent draft batch:\", error);\n            return null;\n        }\n    };\n    // Run cleanup on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        cleanupExpiredJobs();\n    }, [\n        cleanupExpiredJobs\n    ]);\n    return {\n        currentJobId,\n        setCurrentJobId,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        generationStartTime,\n        setGenerationStartTime,\n        currentElapsedTime,\n        setCurrentElapsedTime,\n        elapsedTimeInterval,\n        setElapsedTimeInterval,\n        generationDuration,\n        setGenerationDuration,\n        saveJobToStorage,\n        updateJobProgress,\n        removeJobFromStorage,\n        startElapsedTimeTracking,\n        stopElapsedTimeTracking,\n        clearAllJobData,\n        checkPendingJobs,\n        loadMostRecentDraftBatch,\n        cleanupExpiredJobs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlSm9iTWFuYWdlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7c0VBRXlEO0FBSWxELFNBQVNHO0lBQ2QsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR0wsK0NBQVFBLENBQWdCO0lBQ2hFLE1BQU0sQ0FBQ00sb0JBQW9CQyxzQkFBc0IsR0FBR1AsK0NBQVFBLENBQVM7SUFDckUsTUFBTSxDQUFDUSxvQkFBb0JDLHNCQUFzQixHQUFHVCwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUNVLHFCQUFxQkMsdUJBQXVCLEdBQUdYLCtDQUFRQSxDQUFnQjtJQUM5RSxNQUFNLENBQUNZLG9CQUFvQkMsc0JBQXNCLEdBQUdiLCtDQUFRQSxDQUFTO0lBQ3JFLE1BQU0sQ0FBQ2MscUJBQXFCQyx1QkFBdUIsR0FBR2YsK0NBQVFBLENBQXdCO0lBQ3RGLE1BQU0sQ0FBQ2dCLG9CQUFvQkMsc0JBQXNCLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFDNUUsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR25CLCtDQUFRQSxDQUEyQjtJQUUvRSwyQkFBMkI7SUFDM0IsTUFBTW9CLG1CQUFtQixDQUFDQyxPQUFlQztRQUN2QyxJQUFJLEtBQWtCLEVBQWEsRUFBTztRQUUxQyxJQUFJO1lBQ0YseURBQXlEO1lBQ3pELE1BQU1DLGtCQUFrQjtnQkFDdEIsR0FBR0QsT0FBTztnQkFDVkUsSUFBSUg7Z0JBQ0pJLFFBQVE7Z0JBQ1JDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CQyxXQUFXRixLQUFLQyxHQUFHLEtBQU0sS0FBSyxLQUFLLEtBQUssS0FBSztnQkFDN0NFLGNBQWN0QjtnQkFDZHVCLGtCQUFrQnpCO2dCQUNsQjBCLGFBQWFwQjtZQUNmO1lBRUFxQixhQUFhQyxPQUFPLENBQUMsV0FBaUIsT0FBTmIsUUFBU2MsS0FBS0MsU0FBUyxDQUFDYjtZQUV4RCxNQUFNYyxjQUFjRixLQUFLRyxLQUFLLENBQUNM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QmpFLFFBQVFnQixHQUFHLENBQUMsdUJBQWtDLE9BQXJCNEMsY0FBYzNDLE1BQU0sRUFBQztZQUU5Qyx3QkFBd0I7WUFDeEIsT0FBTztnQkFDTGlELE9BQU9OO2dCQUNQOUUsV0FBV2tFO2dCQUNYbUIsT0FBT1AsY0FBYzNDLE1BQU07WUFDN0I7UUFDRixFQUFFLE9BQU9sQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE9BQU87UUFDVDtJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCekMsZ0RBQVNBLENBQUM7UUFDUndDO0lBQ0YsR0FBRztRQUFDQTtLQUFtQjtJQUV2QixPQUFPO1FBQ0x0QztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBRztRQUNBeUI7UUFDQUs7UUFDQWE7UUFDQWE7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQXRDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy9jYXJkU3R1ZGlvL3VzZUpvYk1hbmFnZW1lbnQudHM/ZmM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgR2VuZXJhdGVkQ2FyZCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUpvYk1hbmFnZW1lbnQoKSB7XG4gIGNvbnN0IFtjdXJyZW50Sm9iSWQsIHNldEN1cnJlbnRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRpb25Qcm9ncmVzcywgc2V0R2VuZXJhdGlvblByb2dyZXNzXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtwcm9ncmVzc1BlcmNlbnRhZ2UsIHNldFByb2dyZXNzUGVyY2VudGFnZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbZ2VuZXJhdGlvblN0YXJ0VGltZSwgc2V0R2VuZXJhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRFbGFwc2VkVGltZSwgc2V0Q3VycmVudEVsYXBzZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtlbGFwc2VkVGltZUludGVydmFsLCBzZXRFbGFwc2VkVGltZUludGVydmFsXSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uRHVyYXRpb24sIHNldEdlbmVyYXRpb25EdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRKb2JUeXBlLCBzZXRDdXJyZW50Sm9iVHlwZV0gPSB1c2VTdGF0ZTwnZHJhZnQnIHwgJ2ZpbmFsJyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEpvYiBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICBjb25zdCBzYXZlSm9iVG9TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcsIGpvYkRhdGE6IGFueSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBFbmhhbmNlZCBqb2IgZGF0YSB3aXRoIHByb2dyZXNzLCBzdGF0ZSwgYW5kIGV4cGlyYXRpb25cbiAgICAgIGNvbnN0IGVuaGFuY2VkSm9iRGF0YSA9IHtcbiAgICAgICAgLi4uam9iRGF0YSxcbiAgICAgICAgaWQ6IGpvYklkLFxuICAgICAgICBzdGF0dXM6ICdwcm9jZXNzaW5nJyxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyAoMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKSwgLy8gMzAgZGF5cyBleHBpcmF0aW9uXG4gICAgICAgIGxhc3RQcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgICAgICBsYXN0UHJvZ3Jlc3NUZXh0OiBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgICAgIGVsYXBzZWRUaW1lOiBjdXJyZW50RWxhcHNlZFRpbWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCwgSlNPTi5zdHJpbmdpZnkoZW5oYW5jZWRKb2JEYXRhKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJykgfHwgJ1tdJyk7XG4gICAgICBpZiAoIXBlbmRpbmdKb2JzLmluY2x1ZGVzKGpvYklkKSkge1xuICAgICAgICBwZW5kaW5nSm9icy5wdXNoKGpvYklkKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHBlbmRpbmdKb2JzKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJ1biBjbGVhbnVwIG9mIGV4cGlyZWQgam9ic1xuICAgICAgY2xlYW51cEV4cGlyZWRKb2JzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGpvYiB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGRhdGUgam9iIHByb2dyZXNzIGluIHN0b3JhZ2VcbiAgY29uc3QgdXBkYXRlSm9iUHJvZ3Jlc3MgPSAoam9iSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgcHJvZ3Jlc3NUZXh0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICBpZiAoIWpvYkRhdGEpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3Qgam9iID0gSlNPTi5wYXJzZShqb2JEYXRhKTtcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3NUZXh0ID0gcHJvZ3Jlc3NUZXh0O1xuICAgICAgam9iLmVsYXBzZWRUaW1lID0gY3VycmVudEVsYXBzZWRUaW1lO1xuICAgICAgam9iLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgY2FyZEpvYl8ke2pvYklkfWAsIEpTT04uc3RyaW5naWZ5KGpvYikpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGpvYiBwcm9ncmVzczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZSBqb2IgZnJvbSBzdG9yYWdlXG4gIGNvbnN0IHJlbW92ZUpvYkZyb21TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChpZDogc3RyaW5nKSA9PiBpZCAhPT0gam9iSWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRKb2JzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgam9iIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2xlYW51cCBleHBpcmVkIGpvYnMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgY2xlYW51cEV4cGlyZWRKb2JzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIENoZWNrIGFsbCBsb2NhbFN0b3JhZ2Uga2V5c1xuICAgIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdjYXJkSm9iXycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgaWYgKGpvYkRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IEpTT04ucGFyc2Uoam9iRGF0YSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgaWYgZXhwaXJlZCBvciBjb3JydXB0ZWQgZGF0YVxuICAgICAgICAgICAgaWYgKCFqb2IuZXhwaXJlc0F0IHx8IGpvYi5leHBpcmVzQXQgPCBub3cpIHtcbiAgICAgICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGNvcnJ1cHRlZCBkYXRhXG4gICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGpvYnNcbiAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJlbW92ZWQgZXhwaXJlZCBqb2I6ICR7a2V5fWApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGpvYnMgbGlzdFxuICAgIGlmIChrZXlzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IGNsZWFuZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChqb2JJZDogc3RyaW5nKSA9PiBcbiAgICAgICAgIWtleXNUb1JlbW92ZS5pbmNsdWRlcyhgY2FyZEpvYl8ke2pvYklkfWApXG4gICAgICApO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KGNsZWFuZWRKb2JzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU3RhcnQgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyA9IHVzZUNhbGxiYWNrKChqb2JUeXBlOiAnZHJhZnQnIHwgJ2ZpbmFsJyA9ICdmaW5hbCcpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZShzdGFydCk7XG4gICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lKDApO1xuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICBzZXRDdXJyZW50Sm9iVHlwZShqb2JUeXBlKTtcbiAgICBcbiAgICBpZiAoZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChlbGFwc2VkVGltZUludGVydmFsKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRXhwZWN0ZWQgZHVyYXRpb25zIGluIHNlY29uZHNcbiAgICBjb25zdCBleHBlY3RlZER1cmF0aW9uID0gam9iVHlwZSA9PT0gJ2RyYWZ0JyA/IDQ1IDogMTA1OyAvLyA0NXMgZm9yIGRyYWZ0LCAxMDVzIGZvciBmaW5hbFxuICAgIFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMDtcbiAgICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZShlbGFwc2VkKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHByb2dyZXNzIGJhc2VkIG9uIGVsYXBzZWQgdGltZVxuICAgICAgLy8gUHJvZ3Jlc3MgaW5jcmVhc2VzIGxpbmVhcmx5IHVwIHRvIDk1JSBhdCBleHBlY3RlZCBkdXJhdGlvblxuICAgICAgLy8gVGhlbiBzbG93cyBkb3duIHRvIHJlYWNoIDk5JSBhdCAyeCBleHBlY3RlZCBkdXJhdGlvblxuICAgICAgbGV0IHByb2dyZXNzID0gMDtcbiAgICAgIGlmIChlbGFwc2VkIDwgZXhwZWN0ZWREdXJhdGlvbikge1xuICAgICAgICAvLyBMaW5lYXIgcHJvZ3Jlc3MgdXAgdG8gOTUlXG4gICAgICAgIHByb2dyZXNzID0gKGVsYXBzZWQgLyBleHBlY3RlZER1cmF0aW9uKSAqIDk1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2xvdyBwcm9ncmVzcyBmcm9tIDk1JSB0byA5OSUgb3ZlciB0aGUgbmV4dCBleHBlY3RlZER1cmF0aW9uIHNlY29uZHNcbiAgICAgICAgY29uc3Qgb3ZlcnRpbWUgPSBlbGFwc2VkIC0gZXhwZWN0ZWREdXJhdGlvbjtcbiAgICAgICAgY29uc3Qgb3ZlcnRpbWVQcm9ncmVzcyA9IE1hdGgubWluKG92ZXJ0aW1lIC8gZXhwZWN0ZWREdXJhdGlvbiwgMSkgKiA0OyAvLyA0JSBtb3JlXG4gICAgICAgIHByb2dyZXNzID0gOTUgKyBvdmVydGltZVByb2dyZXNzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoTWF0aC5taW4oTWF0aC5yb3VuZChwcm9ncmVzcyksIDk5KSk7XG4gICAgfSwgMTAwKTsgLy8gVXBkYXRlIGV2ZXJ5IDEwMG1zIGZvciBzbW9vdGggcHJvZ3Jlc3NcbiAgICBcbiAgICBzZXRFbGFwc2VkVGltZUludGVydmFsKGludGVydmFsKTtcbiAgfSwgW2VsYXBzZWRUaW1lSW50ZXJ2YWxdKTtcblxuICAvLyBTdG9wIGVsYXBzZWQgdGltZSB0cmFja2luZ1xuICBjb25zdCBzdG9wRWxhcHNlZFRpbWVUcmFja2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChlbGFwc2VkVGltZUludGVydmFsKTtcbiAgICAgIHNldEVsYXBzZWRUaW1lSW50ZXJ2YWwobnVsbCk7XG4gICAgfVxuICB9LCBbZWxhcHNlZFRpbWVJbnRlcnZhbF0pO1xuXG4gIC8vIENsZWFyIGFsbCBqb2IgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZVxuICBjb25zdCBjbGVhckFsbEpvYkRhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYXJpbmcgYWxsIGpvYiBkYXRhIGZyb20gbG9jYWxTdG9yYWdlJyk7XG4gICAgXG4gICAgLy8gR2V0IGFsbCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFsbCBqb2ItcmVsYXRlZCBrZXlzXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2NhcmRKb2JfJykgfHwga2V5ID09PSAncGVuZGluZ0NhcmRKb2JzJyB8fCBrZXkgPT09ICdnZW5lcmF0aW9uLXN0YXJ0LXRpbWUnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3RhdGVcbiAgICBzZXRDdXJyZW50RWxhcHNlZFRpbWUoMCk7XG4gICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDApO1xuICAgIHNldEdlbmVyYXRpb25TdGFydFRpbWUobnVsbCk7XG4gIH0sIFtdKTtcblxuICAvLyBSZWNvdmVyeSBmdW5jdGlvbiAtIHJlc3VtZSBXZWJTb2NrZXQgc3Vic2NyaXB0aW9ucyBmb3IgcGVuZGluZyBqb2JzXG4gIGNvbnN0IGNoZWNrUGVuZGluZ0pvYnMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJykgfHwgJ1tdJyk7XG4gICAgICBjb25zdCBqb2JzRGF0YSA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGpvYklkIG9mIHBlbmRpbmdKb2JzKSB7XG4gICAgICAgIGNvbnN0IGpvYkRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShgY2FyZEpvYl8ke2pvYklkfWApO1xuICAgICAgICBpZiAoIWpvYkRhdGEpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgam9iID0gSlNPTi5wYXJzZShqb2JEYXRhKTtcbiAgICAgICAgam9ic0RhdGEucHVzaCh7IGpvYklkLCBqb2IgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBqb2JzRGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIHBlbmRpbmcgam9iczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIC8vIExvYWQgbW9zdCByZWNlbnQgZHJhZnQgYmF0Y2ggKDUgY2FyZHMpXG4gIGNvbnN0IGxvYWRNb3N0UmVjZW50RHJhZnRCYXRjaCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgYWxsIGxvY2FsU3RvcmFnZSBrZXlzXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICAgIGNvbnN0IGRyYWZ0Sm9iS2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnY2FyZEpvYl9kcmFmdC0nKSk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBGb3VuZCAke2RyYWZ0Sm9iS2V5cy5sZW5ndGh9IGRyYWZ0IGpvYiBrZXlzIGluIGxvY2FsU3RvcmFnZWApO1xuICAgICAgXG4gICAgICBjb25zdCBkcmFmdEpvYnMgPSBbXTtcbiAgICAgIFxuICAgICAgLy8gRmluZCBhbGwgZHJhZnQgam9iIGVudHJpZXNcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGRyYWZ0Sm9iS2V5cykge1xuICAgICAgICBjb25zdCBqb2JEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKGpvYkRhdGEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gSlNPTi5wYXJzZShqb2JEYXRhKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OEIENoZWNraW5nICR7a2V5fTpgLCB7IFxuICAgICAgICAgICAgICBoYXNEcmFmdENhcmRzOiAhIWpvYi5kcmFmdENhcmRzLCBcbiAgICAgICAgICAgICAgY2FyZENvdW50OiBqb2IuZHJhZnRDYXJkcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogam9iLmNyZWF0ZWRBdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChqb2IuZHJhZnRDYXJkcyAmJiBBcnJheS5pc0FycmF5KGpvYi5kcmFmdENhcmRzKSAmJiBqb2IuZHJhZnRDYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGRyYWZ0Sm9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgam9iLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogam9iLmNyZWF0ZWRBdCB8fCAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSAke2tleX06YCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIG5vIGRyYWZ0IGpvYnMgZm91bmQsIHJldHVybiBudWxsXG4gICAgICBpZiAoZHJhZnRKb2JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICBcbiAgICAgIC8vIFNvcnQgYnkgY3JlYXRpb24gdGltZSAobmV3ZXN0IGZpcnN0KVxuICAgICAgZHJhZnRKb2JzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZEF0IC0gYS5jcmVhdGVkQXQpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIG1vc3QgcmVjZW50IGJhdGNoICh0aGV5IHNob3VsZCBhbGwgaGF2ZSBzaW1pbGFyIHRpbWVzdGFtcHMpXG4gICAgICBjb25zdCBtb3N0UmVjZW50VGltZXN0YW1wID0gZHJhZnRKb2JzWzBdLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IHJlY2VudEJhdGNoID0gZHJhZnRKb2JzLmZpbHRlcihqb2IgPT4ge1xuICAgICAgICAvLyBDb25zaWRlciBqb2JzIHdpdGhpbiA1IG1pbnV0ZXMgb2YgZWFjaCBvdGhlciBhcyB0aGUgc2FtZSBiYXRjaFxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoam9iLmNyZWF0ZWRBdCAtIG1vc3RSZWNlbnRUaW1lc3RhbXApIDwgNSAqIDYwICogMTAwMDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGFsbCBkcmFmdCBjYXJkcyBmcm9tIHRoZSBiYXRjaCwgYXZvaWRpbmcgZHVwbGljYXRlc1xuICAgICAgY29uc3QgZHJhZnRDYXJkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHsgam9iIH0gb2YgcmVjZW50QmF0Y2gpIHtcbiAgICAgICAgaWYgKGpvYi5kcmFmdENhcmRzICYmIGpvYi5kcmFmdENhcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBFYWNoIGpvYiBub3cgc3RvcmVzIG9ubHkgb25lIGRyYWZ0IGNhcmRcbiAgICAgICAgICBjb25zdCBkcmFmdENhcmQgPSBqb2IuZHJhZnRDYXJkc1swXTtcbiAgICAgICAgICBjb25zdCBkcmFmdEluZGV4ID0gam9iLmRyYWZ0SW5kZXggIT09IHVuZGVmaW5lZCA/IGpvYi5kcmFmdEluZGV4IDogXG4gICAgICAgICAgICBwYXJzZUludChkcmFmdENhcmQuaWQubWF0Y2goL2RyYWZ0LShcXGQrKS0vKT8uWzFdIHx8ICcwJykgLSAxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVzZSBkcmFmdCBpbmRleCBhcyBrZXkgdG8gYXZvaWQgZHVwbGljYXRlc1xuICAgICAgICAgIGlmICghZHJhZnRDYXJkTWFwLmhhcyhkcmFmdEluZGV4KSkge1xuICAgICAgICAgICAgZHJhZnRDYXJkTWFwLnNldChkcmFmdEluZGV4LCBkcmFmdENhcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IG1hcCB0byBhcnJheSBhbmQgc29ydCBieSBkcmFmdCBpbmRleFxuICAgICAgY29uc3QgYWxsRHJhZnRDYXJkcyA9IEFycmF5LmZyb20oZHJhZnRDYXJkTWFwLmVudHJpZXMoKSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKVxuICAgICAgICAubWFwKChbXywgY2FyZF0pID0+IGNhcmQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBMb2FkZWQgJHthbGxEcmFmdENhcmRzLmxlbmd0aH0gdW5pcXVlIGRyYWZ0IGNhcmRzIGZyb20gYmF0Y2hgKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIHRoZSBiYXRjaCBpbmZvXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXJkczogYWxsRHJhZnRDYXJkcyxcbiAgICAgICAgY3JlYXRlZEF0OiBtb3N0UmVjZW50VGltZXN0YW1wLFxuICAgICAgICBjb3VudDogYWxsRHJhZnRDYXJkcy5sZW5ndGhcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHJlY2VudCBkcmFmdCBiYXRjaDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUnVuIGNsZWFudXAgb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjbGVhbnVwRXhwaXJlZEpvYnMoKTtcbiAgfSwgW2NsZWFudXBFeHBpcmVkSm9ic10pO1xuXG4gIHJldHVybiB7XG4gICAgY3VycmVudEpvYklkLFxuICAgIHNldEN1cnJlbnRKb2JJZCxcbiAgICBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzLFxuICAgIHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgZ2VuZXJhdGlvblN0YXJ0VGltZSxcbiAgICBzZXRHZW5lcmF0aW9uU3RhcnRUaW1lLFxuICAgIGN1cnJlbnRFbGFwc2VkVGltZSxcbiAgICBzZXRDdXJyZW50RWxhcHNlZFRpbWUsXG4gICAgZWxhcHNlZFRpbWVJbnRlcnZhbCxcbiAgICBzZXRFbGFwc2VkVGltZUludGVydmFsLFxuICAgIGdlbmVyYXRpb25EdXJhdGlvbixcbiAgICBzZXRHZW5lcmF0aW9uRHVyYXRpb24sXG4gICAgc2F2ZUpvYlRvU3RvcmFnZSxcbiAgICB1cGRhdGVKb2JQcm9ncmVzcyxcbiAgICByZW1vdmVKb2JGcm9tU3RvcmFnZSxcbiAgICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmcsXG4gICAgc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcsXG4gICAgY2xlYXJBbGxKb2JEYXRhLFxuICAgIGNoZWNrUGVuZGluZ0pvYnMsXG4gICAgbG9hZE1vc3RSZWNlbnREcmFmdEJhdGNoLFxuICAgIGNsZWFudXBFeHBpcmVkSm9ic1xuICB9O1xufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlSm9iTWFuYWdlbWVudCIsImN1cnJlbnRKb2JJZCIsInNldEN1cnJlbnRKb2JJZCIsImdlbmVyYXRpb25Qcm9ncmVzcyIsInNldEdlbmVyYXRpb25Qcm9ncmVzcyIsInByb2dyZXNzUGVyY2VudGFnZSIsInNldFByb2dyZXNzUGVyY2VudGFnZSIsImdlbmVyYXRpb25TdGFydFRpbWUiLCJzZXRHZW5lcmF0aW9uU3RhcnRUaW1lIiwiY3VycmVudEVsYXBzZWRUaW1lIiwic2V0Q3VycmVudEVsYXBzZWRUaW1lIiwiZWxhcHNlZFRpbWVJbnRlcnZhbCIsInNldEVsYXBzZWRUaW1lSW50ZXJ2YWwiLCJnZW5lcmF0aW9uRHVyYXRpb24iLCJzZXRHZW5lcmF0aW9uRHVyYXRpb24iLCJjdXJyZW50Sm9iVHlwZSIsInNldEN1cnJlbnRKb2JUeXBlIiwic2F2ZUpvYlRvU3RvcmFnZSIsImpvYklkIiwiam9iRGF0YSIsImVuaGFuY2VkSm9iRGF0YSIsImlkIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImV4cGlyZXNBdCIsImxhc3RQcm9ncmVzcyIsImxhc3RQcm9ncmVzc1RleHQiLCJlbGFwc2VkVGltZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwicGVuZGluZ0pvYnMiLCJwYXJzZSIsImdldEl0ZW0iLCJpbmNsdWRlcyIsInB1c2giLCJjbGVhbnVwRXhwaXJlZEpvYnMiLCJlcnJvciIsImNvbnNvbGUiLCJ1cGRhdGVKb2JQcm9ncmVzcyIsInByb2dyZXNzIiwicHJvZ3Jlc3NUZXh0Iiwiam9iIiwibGFzdFVwZGF0ZSIsInJlbW92ZUpvYkZyb21TdG9yYWdlIiwicmVtb3ZlSXRlbSIsInVwZGF0ZWRKb2JzIiwiZmlsdGVyIiwia2V5c1RvUmVtb3ZlIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJzdGFydHNXaXRoIiwibG9nIiwibGVuZ3RoIiwiY2xlYW5lZEpvYnMiLCJzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmciLCJqb2JUeXBlIiwic3RhcnQiLCJjbGVhckludGVydmFsIiwiZXhwZWN0ZWREdXJhdGlvbiIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwib3ZlcnRpbWUiLCJvdmVydGltZVByb2dyZXNzIiwiTWF0aCIsIm1pbiIsInJvdW5kIiwic3RvcEVsYXBzZWRUaW1lVHJhY2tpbmciLCJjbGVhckFsbEpvYkRhdGEiLCJjaGVja1BlbmRpbmdKb2JzIiwiam9ic0RhdGEiLCJsb2FkTW9zdFJlY2VudERyYWZ0QmF0Y2giLCJkcmFmdEpvYktleXMiLCJkcmFmdEpvYnMiLCJoYXNEcmFmdENhcmRzIiwiZHJhZnRDYXJkcyIsImNhcmRDb3VudCIsIkFycmF5IiwiaXNBcnJheSIsImUiLCJzb3J0IiwiYSIsImIiLCJtb3N0UmVjZW50VGltZXN0YW1wIiwicmVjZW50QmF0Y2giLCJhYnMiLCJkcmFmdENhcmRNYXAiLCJNYXAiLCJkcmFmdENhcmQiLCJkcmFmdEluZGV4IiwidW5kZWZpbmVkIiwicGFyc2VJbnQiLCJtYXRjaCIsImhhcyIsInNldCIsImFsbERyYWZ0Q2FyZHMiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsIl8iLCJjYXJkIiwiY2FyZHMiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts":
/*!**********************************************!*\
  !*** ./hooks/cardStudio/useJobManagement.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useJobManagement: function() { return /* binding */ useJobManagement; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useJobManagement auto */ \nfunction useJobManagement() {\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [progressPercentage, setProgressPercentage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [generationStartTime, setGenerationStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentElapsedTime, setCurrentElapsedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [elapsedTimeInterval, setElapsedTimeInterval] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentJobType, setCurrentJobType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Job management functions\n    const saveJobToStorage = (jobId, jobData)=>{\n        if (false) {}\n        try {\n            // Enhanced job data with progress, state, and expiration\n            const enhancedJobData = {\n                ...jobData,\n                id: jobId,\n                status: \"processing\",\n                createdAt: Date.now(),\n                expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,\n                lastProgress: progressPercentage,\n                lastProgressText: generationProgress,\n                elapsedTime: currentElapsedTime\n            };\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(enhancedJobData));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            if (!pendingJobs.includes(jobId)) {\n                pendingJobs.push(jobId);\n                localStorage.setItem(\"pendingCardJobs\", JSON.stringify(pendingJobs));\n            }\n            // Run cleanup of expired jobs\n            cleanupExpiredJobs();\n        } catch (error) {\n            console.error(\"Failed to save job to localStorage:\", error);\n        }\n    };\n    // Update job progress in storage\n    const updateJobProgress = (jobId, progress, progressText)=>{\n        if (false) {}\n        try {\n            const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n            if (!jobData) return;\n            const job = JSON.parse(jobData);\n            job.lastProgress = progress;\n            job.lastProgressText = progressText;\n            job.elapsedTime = currentElapsedTime;\n            job.lastUpdate = Date.now();\n            localStorage.setItem(\"cardJob_\".concat(jobId), JSON.stringify(job));\n        } catch (error) {\n            console.error(\"Failed to update job progress:\", error);\n        }\n    };\n    // Remove job from storage\n    const removeJobFromStorage = (jobId)=>{\n        if (false) {}\n        try {\n            localStorage.removeItem(\"cardJob_\".concat(jobId));\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const updatedJobs = pendingJobs.filter((id)=>id !== jobId);\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(updatedJobs));\n        } catch (error) {\n            console.error(\"Failed to remove job from localStorage:\", error);\n        }\n    };\n    // Cleanup expired jobs from localStorage\n    const cleanupExpiredJobs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        const now = Date.now();\n        const keysToRemove = [];\n        // Check all localStorage keys\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith(\"cardJob_\")) {\n                try {\n                    const jobData = localStorage.getItem(key);\n                    if (jobData) {\n                        const job = JSON.parse(jobData);\n                        // Remove if expired or corrupted data\n                        if (!job.expiresAt || job.expiresAt < now) {\n                            keysToRemove.push(key);\n                        }\n                    }\n                } catch (error) {\n                    // Remove corrupted data\n                    keysToRemove.push(key);\n                }\n            }\n        });\n        // Remove expired jobs\n        keysToRemove.forEach((key)=>{\n            localStorage.removeItem(key);\n            console.log(\"\\uD83E\\uDDF9 Removed expired job: \".concat(key));\n        });\n        // Update pending jobs list\n        if (keysToRemove.length > 0) {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const cleanedJobs = pendingJobs.filter((jobId)=>!keysToRemove.includes(\"cardJob_\".concat(jobId)));\n            localStorage.setItem(\"pendingCardJobs\", JSON.stringify(cleanedJobs));\n        }\n    }, []);\n    // Start elapsed time tracking\n    const startElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let jobType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"final\";\n        const start = Date.now();\n        setGenerationStartTime(start);\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setCurrentJobType(jobType);\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n        }\n        // Expected durations in seconds\n        const expectedDuration = jobType === \"draft\" ? 45 : 105; // 45s for draft, 105s for final\n        const interval = setInterval(()=>{\n            const elapsed = (Date.now() - start) / 1000;\n            setCurrentElapsedTime(elapsed);\n            // Calculate progress based on elapsed time\n            // Progress increases linearly up to 95% at expected duration\n            // Then slows down to reach 99% at 2x expected duration\n            let progress = 0;\n            if (elapsed < expectedDuration) {\n                // Linear progress up to 95%\n                progress = elapsed / expectedDuration * 95;\n            } else {\n                // Slow progress from 95% to 99% over the next expectedDuration seconds\n                const overtime = elapsed - expectedDuration;\n                const overtimeProgress = Math.min(overtime / expectedDuration, 1) * 4; // 4% more\n                progress = 95 + overtimeProgress;\n            }\n            setProgressPercentage(Math.min(Math.round(progress), 99));\n        }, 100); // Update every 100ms for smooth progress\n        setElapsedTimeInterval(interval);\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Stop elapsed time tracking\n    const stopElapsedTimeTracking = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (elapsedTimeInterval) {\n            clearInterval(elapsedTimeInterval);\n            setElapsedTimeInterval(null);\n        }\n        // Set progress to 100% when stopping\n        setProgressPercentage(100);\n    }, [\n        elapsedTimeInterval\n    ]);\n    // Clear all job data from localStorage\n    const clearAllJobData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (false) {}\n        console.log(\"\\uD83E\\uDDF9 Clearing all job data from localStorage\");\n        // Get all keys\n        const keys = Object.keys(localStorage);\n        // Remove all job-related keys\n        keys.forEach((key)=>{\n            if (key.startsWith(\"cardJob_\") || key === \"pendingCardJobs\" || key === \"generation-start-time\") {\n                localStorage.removeItem(key);\n            }\n        });\n        // Reset state\n        setCurrentElapsedTime(0);\n        setProgressPercentage(0);\n        setGenerationStartTime(null);\n    }, []);\n    // Recovery function - resume WebSocket subscriptions for pending jobs\n    const checkPendingJobs = async ()=>{\n        if (false) {}\n        try {\n            const pendingJobs = JSON.parse(localStorage.getItem(\"pendingCardJobs\") || \"[]\");\n            const jobsData = [];\n            for (const jobId of pendingJobs){\n                const jobData = localStorage.getItem(\"cardJob_\".concat(jobId));\n                if (!jobData) continue;\n                const job = JSON.parse(jobData);\n                jobsData.push({\n                    jobId,\n                    job\n                });\n            }\n            return jobsData;\n        } catch (error) {\n            console.error(\"Failed to check pending jobs:\", error);\n            return [];\n        }\n    };\n    // Load most recent draft batch (5 cards)\n    const loadMostRecentDraftBatch = ()=>{\n        if (false) {}\n        try {\n            // Get all localStorage keys\n            const keys = Object.keys(localStorage);\n            const draftJobKeys = keys.filter((key)=>key.startsWith(\"cardJob_draft-\"));\n            console.log(\"\\uD83D\\uDD0D Found \".concat(draftJobKeys.length, \" draft job keys in localStorage\"));\n            const draftJobs = [];\n            // Find all draft job entries\n            for (const key of draftJobKeys){\n                const jobData = localStorage.getItem(key);\n                if (jobData) {\n                    try {\n                        var _job_draftCards;\n                        const job = JSON.parse(jobData);\n                        console.log(\"\\uD83D\\uDCC4 Checking \".concat(key, \":\"), {\n                            hasDraftCards: !!job.draftCards,\n                            cardCount: ((_job_draftCards = job.draftCards) === null || _job_draftCards === void 0 ? void 0 : _job_draftCards.length) || 0,\n                            createdAt: job.createdAt\n                        });\n                        if (job.draftCards && Array.isArray(job.draftCards) && job.draftCards.length > 0) {\n                            draftJobs.push({\n                                key,\n                                job,\n                                createdAt: job.createdAt || 0\n                            });\n                        }\n                    } catch (e) {\n                        console.error(\"Failed to parse \".concat(key, \":\"), e);\n                    }\n                }\n            }\n            // If no draft jobs found, return null\n            if (draftJobs.length === 0) return null;\n            // Sort by creation time (newest first)\n            draftJobs.sort((a, b)=>b.createdAt - a.createdAt);\n            // Get the most recent batch (they should all have similar timestamps)\n            const mostRecentTimestamp = draftJobs[0].createdAt;\n            const recentBatch = draftJobs.filter((job)=>{\n                // Consider jobs within 5 minutes of each other as the same batch\n                return Math.abs(job.createdAt - mostRecentTimestamp) < 5 * 60 * 1000;\n            });\n            // Collect all draft cards from the batch, avoiding duplicates\n            const draftCardMap = new Map();\n            for (const { job } of recentBatch){\n                if (job.draftCards && job.draftCards.length > 0) {\n                    var _draftCard_id_match;\n                    // Each job now stores only one draft card\n                    const draftCard = job.draftCards[0];\n                    const draftIndex = job.draftIndex !== undefined ? job.draftIndex : parseInt(((_draftCard_id_match = draftCard.id.match(/draft-(\\d+)-/)) === null || _draftCard_id_match === void 0 ? void 0 : _draftCard_id_match[1]) || \"0\") - 1;\n                    // Use draft index as key to avoid duplicates\n                    if (!draftCardMap.has(draftIndex)) {\n                        draftCardMap.set(draftIndex, draftCard);\n                    }\n                }\n            }\n            // Convert map to array and sort by draft index\n            const allDraftCards = Array.from(draftCardMap.entries()).sort((a, b)=>a[0] - b[0]).map((param)=>{\n                let [_, card] = param;\n                return card;\n            });\n            console.log(\"\\uD83D\\uDCCB Loaded \".concat(allDraftCards.length, \" unique draft cards from batch\"));\n            // Return the batch info\n            return {\n                cards: allDraftCards,\n                createdAt: mostRecentTimestamp,\n                count: allDraftCards.length\n            };\n        } catch (error) {\n            console.error(\"Failed to load recent draft batch:\", error);\n            return null;\n        }\n    };\n    // Run cleanup on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        cleanupExpiredJobs();\n    }, [\n        cleanupExpiredJobs\n    ]);\n    return {\n        currentJobId,\n        setCurrentJobId,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        generationStartTime,\n        setGenerationStartTime,\n        currentElapsedTime,\n        setCurrentElapsedTime,\n        elapsedTimeInterval,\n        setElapsedTimeInterval,\n        generationDuration,\n        setGenerationDuration,\n        currentJobType,\n        setCurrentJobType,\n        saveJobToStorage,\n        updateJobProgress,\n        removeJobFromStorage,\n        startElapsedTimeTracking,\n        stopElapsedTimeTracking,\n        clearAllJobData,\n        checkPendingJobs,\n        loadMostRecentDraftBatch,\n        cleanupExpiredJobs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlSm9iTWFuYWdlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7c0VBRXlEO0FBSWxELFNBQVNHO0lBQ2QsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR0wsK0NBQVFBLENBQWdCO0lBQ2hFLE1BQU0sQ0FBQ00sb0JBQW9CQyxzQkFBc0IsR0FBR1AsK0NBQVFBLENBQVM7SUFDckUsTUFBTSxDQUFDUSxvQkFBb0JDLHNCQUFzQixHQUFHVCwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUNVLHFCQUFxQkMsdUJBQXVCLEdBQUdYLCtDQUFRQSxDQUFnQjtJQUM5RSxNQUFNLENBQUNZLG9CQUFvQkMsc0JBQXNCLEdBQUdiLCtDQUFRQSxDQUFTO0lBQ3JFLE1BQU0sQ0FBQ2MscUJBQXFCQyx1QkFBdUIsR0FBR2YsK0NBQVFBLENBQXdCO0lBQ3RGLE1BQU0sQ0FBQ2dCLG9CQUFvQkMsc0JBQXNCLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFDNUUsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR25CLCtDQUFRQSxDQUEyQjtJQUUvRSwyQkFBMkI7SUFDM0IsTUFBTW9CLG1CQUFtQixDQUFDQyxPQUFlQztRQUN2QyxJQUFJLEtBQWtCLEVBQWEsRUFBTztRQUUxQyxJQUFJO1lBQ0YseURBQXlEO1lBQ3pELE1BQU1DLGtCQUFrQjtnQkFDdEIsR0FBR0QsT0FBTztnQkFDVkUsSUFBSUg7Z0JBQ0pJLFFBQVE7Z0JBQ1JDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CQyxXQUFXRixLQUFLQyxHQUFHLEtBQU0sS0FBSyxLQUFLLEtBQUssS0FBSztnQkFDN0NFLGNBQWN0QjtnQkFDZHVCLGtCQUFrQnpCO2dCQUNsQjBCLGFBQWFwQjtZQUNmO1lBRUFxQixhQUFhQyxPQUFPLENBQUMsV0FBaUIsT0FBTmIsUUFBU2MsS0FBS0MsU0FBUyxDQUFDYjtZQUV4RCxNQUFNYyxjQUFjRixLQUFLRyxLQUFLLENBQUNM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QUNDLEdBQUdDLEtBQUs7dUJBQUtBOztZQUV0QmpFLFFBQVFnQixHQUFHLENBQUMsdUJBQWtDLE9BQXJCNEMsY0FBYzNDLE1BQU0sRUFBQztZQUU5Qyx3QkFBd0I7WUFDeEIsT0FBTztnQkFDTGlELE9BQU9OO2dCQUNQOUUsV0FBV2tFO2dCQUNYbUIsT0FBT1AsY0FBYzNDLE1BQU07WUFDN0I7UUFDRixFQUFFLE9BQU9sQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE9BQU87UUFDVDtJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCekMsZ0RBQVNBLENBQUM7UUFDUndDO0lBQ0YsR0FBRztRQUFDQTtLQUFtQjtJQUV2QixPQUFPO1FBQ0x0QztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBeUI7UUFDQUs7UUFDQWE7UUFDQWE7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQXRDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy9jYXJkU3R1ZGlvL3VzZUpvYk1hbmFnZW1lbnQudHM/ZmM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgR2VuZXJhdGVkQ2FyZCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUpvYk1hbmFnZW1lbnQoKSB7XG4gIGNvbnN0IFtjdXJyZW50Sm9iSWQsIHNldEN1cnJlbnRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRpb25Qcm9ncmVzcywgc2V0R2VuZXJhdGlvblByb2dyZXNzXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtwcm9ncmVzc1BlcmNlbnRhZ2UsIHNldFByb2dyZXNzUGVyY2VudGFnZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbZ2VuZXJhdGlvblN0YXJ0VGltZSwgc2V0R2VuZXJhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRFbGFwc2VkVGltZSwgc2V0Q3VycmVudEVsYXBzZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtlbGFwc2VkVGltZUludGVydmFsLCBzZXRFbGFwc2VkVGltZUludGVydmFsXSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uRHVyYXRpb24sIHNldEdlbmVyYXRpb25EdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRKb2JUeXBlLCBzZXRDdXJyZW50Sm9iVHlwZV0gPSB1c2VTdGF0ZTwnZHJhZnQnIHwgJ2ZpbmFsJyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEpvYiBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICBjb25zdCBzYXZlSm9iVG9TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcsIGpvYkRhdGE6IGFueSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBFbmhhbmNlZCBqb2IgZGF0YSB3aXRoIHByb2dyZXNzLCBzdGF0ZSwgYW5kIGV4cGlyYXRpb25cbiAgICAgIGNvbnN0IGVuaGFuY2VkSm9iRGF0YSA9IHtcbiAgICAgICAgLi4uam9iRGF0YSxcbiAgICAgICAgaWQ6IGpvYklkLFxuICAgICAgICBzdGF0dXM6ICdwcm9jZXNzaW5nJyxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyAoMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKSwgLy8gMzAgZGF5cyBleHBpcmF0aW9uXG4gICAgICAgIGxhc3RQcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgICAgICBsYXN0UHJvZ3Jlc3NUZXh0OiBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgICAgIGVsYXBzZWRUaW1lOiBjdXJyZW50RWxhcHNlZFRpbWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCwgSlNPTi5zdHJpbmdpZnkoZW5oYW5jZWRKb2JEYXRhKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ0NhcmRKb2JzJykgfHwgJ1tdJyk7XG4gICAgICBpZiAoIXBlbmRpbmdKb2JzLmluY2x1ZGVzKGpvYklkKSkge1xuICAgICAgICBwZW5kaW5nSm9icy5wdXNoKGpvYklkKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHBlbmRpbmdKb2JzKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJ1biBjbGVhbnVwIG9mIGV4cGlyZWQgam9ic1xuICAgICAgY2xlYW51cEV4cGlyZWRKb2JzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGpvYiB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGRhdGUgam9iIHByb2dyZXNzIGluIHN0b3JhZ2VcbiAgY29uc3QgdXBkYXRlSm9iUHJvZ3Jlc3MgPSAoam9iSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgcHJvZ3Jlc3NUZXh0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBjYXJkSm9iXyR7am9iSWR9YCk7XG4gICAgICBpZiAoIWpvYkRhdGEpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3Qgam9iID0gSlNPTi5wYXJzZShqb2JEYXRhKTtcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIGpvYi5sYXN0UHJvZ3Jlc3NUZXh0ID0gcHJvZ3Jlc3NUZXh0O1xuICAgICAgam9iLmVsYXBzZWRUaW1lID0gY3VycmVudEVsYXBzZWRUaW1lO1xuICAgICAgam9iLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgY2FyZEpvYl8ke2pvYklkfWAsIEpTT04uc3RyaW5naWZ5KGpvYikpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGpvYiBwcm9ncmVzczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZSBqb2IgZnJvbSBzdG9yYWdlXG4gIGNvbnN0IHJlbW92ZUpvYkZyb21TdG9yYWdlID0gKGpvYklkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChpZDogc3RyaW5nKSA9PiBpZCAhPT0gam9iSWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRKb2JzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgam9iIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2xlYW51cCBleHBpcmVkIGpvYnMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgY2xlYW51cEV4cGlyZWRKb2JzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIENoZWNrIGFsbCBsb2NhbFN0b3JhZ2Uga2V5c1xuICAgIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdjYXJkSm9iXycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgaWYgKGpvYkRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IEpTT04ucGFyc2Uoam9iRGF0YSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgaWYgZXhwaXJlZCBvciBjb3JydXB0ZWQgZGF0YVxuICAgICAgICAgICAgaWYgKCFqb2IuZXhwaXJlc0F0IHx8IGpvYi5leHBpcmVzQXQgPCBub3cpIHtcbiAgICAgICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGNvcnJ1cHRlZCBkYXRhXG4gICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGpvYnNcbiAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJlbW92ZWQgZXhwaXJlZCBqb2I6ICR7a2V5fWApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGpvYnMgbGlzdFxuICAgIGlmIChrZXlzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZW5kaW5nQ2FyZEpvYnMnKSB8fCAnW10nKTtcbiAgICAgIGNvbnN0IGNsZWFuZWRKb2JzID0gcGVuZGluZ0pvYnMuZmlsdGVyKChqb2JJZDogc3RyaW5nKSA9PiBcbiAgICAgICAgIWtleXNUb1JlbW92ZS5pbmNsdWRlcyhgY2FyZEpvYl8ke2pvYklkfWApXG4gICAgICApO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycsIEpTT04uc3RyaW5naWZ5KGNsZWFuZWRKb2JzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU3RhcnQgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyA9IHVzZUNhbGxiYWNrKChqb2JUeXBlOiAnZHJhZnQnIHwgJ2ZpbmFsJyA9ICdmaW5hbCcpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZShzdGFydCk7XG4gICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lKDApO1xuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICBzZXRDdXJyZW50Sm9iVHlwZShqb2JUeXBlKTtcbiAgICBcbiAgICBpZiAoZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChlbGFwc2VkVGltZUludGVydmFsKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRXhwZWN0ZWQgZHVyYXRpb25zIGluIHNlY29uZHNcbiAgICBjb25zdCBleHBlY3RlZER1cmF0aW9uID0gam9iVHlwZSA9PT0gJ2RyYWZ0JyA/IDQ1IDogMTA1OyAvLyA0NXMgZm9yIGRyYWZ0LCAxMDVzIGZvciBmaW5hbFxuICAgIFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMDtcbiAgICAgIHNldEN1cnJlbnRFbGFwc2VkVGltZShlbGFwc2VkKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHByb2dyZXNzIGJhc2VkIG9uIGVsYXBzZWQgdGltZVxuICAgICAgLy8gUHJvZ3Jlc3MgaW5jcmVhc2VzIGxpbmVhcmx5IHVwIHRvIDk1JSBhdCBleHBlY3RlZCBkdXJhdGlvblxuICAgICAgLy8gVGhlbiBzbG93cyBkb3duIHRvIHJlYWNoIDk5JSBhdCAyeCBleHBlY3RlZCBkdXJhdGlvblxuICAgICAgbGV0IHByb2dyZXNzID0gMDtcbiAgICAgIGlmIChlbGFwc2VkIDwgZXhwZWN0ZWREdXJhdGlvbikge1xuICAgICAgICAvLyBMaW5lYXIgcHJvZ3Jlc3MgdXAgdG8gOTUlXG4gICAgICAgIHByb2dyZXNzID0gKGVsYXBzZWQgLyBleHBlY3RlZER1cmF0aW9uKSAqIDk1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2xvdyBwcm9ncmVzcyBmcm9tIDk1JSB0byA5OSUgb3ZlciB0aGUgbmV4dCBleHBlY3RlZER1cmF0aW9uIHNlY29uZHNcbiAgICAgICAgY29uc3Qgb3ZlcnRpbWUgPSBlbGFwc2VkIC0gZXhwZWN0ZWREdXJhdGlvbjtcbiAgICAgICAgY29uc3Qgb3ZlcnRpbWVQcm9ncmVzcyA9IE1hdGgubWluKG92ZXJ0aW1lIC8gZXhwZWN0ZWREdXJhdGlvbiwgMSkgKiA0OyAvLyA0JSBtb3JlXG4gICAgICAgIHByb2dyZXNzID0gOTUgKyBvdmVydGltZVByb2dyZXNzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoTWF0aC5taW4oTWF0aC5yb3VuZChwcm9ncmVzcyksIDk5KSk7XG4gICAgfSwgMTAwKTsgLy8gVXBkYXRlIGV2ZXJ5IDEwMG1zIGZvciBzbW9vdGggcHJvZ3Jlc3NcbiAgICBcbiAgICBzZXRFbGFwc2VkVGltZUludGVydmFsKGludGVydmFsKTtcbiAgfSwgW2VsYXBzZWRUaW1lSW50ZXJ2YWxdKTtcblxuICAvLyBTdG9wIGVsYXBzZWQgdGltZSB0cmFja2luZ1xuICBjb25zdCBzdG9wRWxhcHNlZFRpbWVUcmFja2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChlbGFwc2VkVGltZUludGVydmFsKTtcbiAgICAgIHNldEVsYXBzZWRUaW1lSW50ZXJ2YWwobnVsbCk7XG4gICAgfVxuICAgIC8vIFNldCBwcm9ncmVzcyB0byAxMDAlIHdoZW4gc3RvcHBpbmdcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMTAwKTtcbiAgfSwgW2VsYXBzZWRUaW1lSW50ZXJ2YWxdKTtcblxuICAvLyBDbGVhciBhbGwgam9iIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgY2xlYXJBbGxKb2JEYXRhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFyaW5nIGFsbCBqb2IgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZScpO1xuICAgIFxuICAgIC8vIEdldCBhbGwga2V5c1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBhbGwgam9iLXJlbGF0ZWQga2V5c1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdjYXJkSm9iXycpIHx8IGtleSA9PT0gJ3BlbmRpbmdDYXJkSm9icycgfHwga2V5ID09PSAnZ2VuZXJhdGlvbi1zdGFydC10aW1lJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lKDApO1xuICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICBzZXRHZW5lcmF0aW9uU3RhcnRUaW1lKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgLy8gUmVjb3ZlcnkgZnVuY3Rpb24gLSByZXN1bWUgV2ViU29ja2V0IHN1YnNjcmlwdGlvbnMgZm9yIHBlbmRpbmcgam9ic1xuICBjb25zdCBjaGVja1BlbmRpbmdKb2JzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwZW5kaW5nSm9icyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BlbmRpbmdDYXJkSm9icycpIHx8ICdbXScpO1xuICAgICAgY29uc3Qgam9ic0RhdGEgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBqb2JJZCBvZiBwZW5kaW5nSm9icykge1xuICAgICAgICBjb25zdCBqb2JEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYGNhcmRKb2JfJHtqb2JJZH1gKTtcbiAgICAgICAgaWYgKCFqb2JEYXRhKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGpvYiA9IEpTT04ucGFyc2Uoam9iRGF0YSk7XG4gICAgICAgIGpvYnNEYXRhLnB1c2goeyBqb2JJZCwgam9iIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gam9ic0RhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBwZW5kaW5nIGpvYnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBMb2FkIG1vc3QgcmVjZW50IGRyYWZ0IGJhdGNoICg1IGNhcmRzKVxuICBjb25zdCBsb2FkTW9zdFJlY2VudERyYWZ0QmF0Y2ggPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGFsbCBsb2NhbFN0b3JhZ2Uga2V5c1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSk7XG4gICAgICBjb25zdCBkcmFmdEpvYktleXMgPSBrZXlzLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2NhcmRKb2JfZHJhZnQtJykpO1xuICAgICAgY29uc29sZS5sb2coYPCflI0gRm91bmQgJHtkcmFmdEpvYktleXMubGVuZ3RofSBkcmFmdCBqb2Iga2V5cyBpbiBsb2NhbFN0b3JhZ2VgKTtcbiAgICAgIFxuICAgICAgY29uc3QgZHJhZnRKb2JzID0gW107XG4gICAgICBcbiAgICAgIC8vIEZpbmQgYWxsIGRyYWZ0IGpvYiBlbnRyaWVzXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBkcmFmdEpvYktleXMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmIChqb2JEYXRhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IEpTT04ucGFyc2Uoam9iRGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+ThCBDaGVja2luZyAke2tleX06YCwgeyBcbiAgICAgICAgICAgICAgaGFzRHJhZnRDYXJkczogISFqb2IuZHJhZnRDYXJkcywgXG4gICAgICAgICAgICAgIGNhcmRDb3VudDogam9iLmRyYWZ0Q2FyZHM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGpvYi5jcmVhdGVkQXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoam9iLmRyYWZ0Q2FyZHMgJiYgQXJyYXkuaXNBcnJheShqb2IuZHJhZnRDYXJkcykgJiYgam9iLmRyYWZ0Q2FyZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBkcmFmdEpvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGpvYi5jcmVhdGVkQXQgfHwgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcGFyc2UgJHtrZXl9OmAsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBubyBkcmFmdCBqb2JzIGZvdW5kLCByZXR1cm4gbnVsbFxuICAgICAgaWYgKGRyYWZ0Sm9icy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgXG4gICAgICAvLyBTb3J0IGJ5IGNyZWF0aW9uIHRpbWUgKG5ld2VzdCBmaXJzdClcbiAgICAgIGRyYWZ0Sm9icy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRBdCAtIGEuY3JlYXRlZEF0KTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBtb3N0IHJlY2VudCBiYXRjaCAodGhleSBzaG91bGQgYWxsIGhhdmUgc2ltaWxhciB0aW1lc3RhbXBzKVxuICAgICAgY29uc3QgbW9zdFJlY2VudFRpbWVzdGFtcCA9IGRyYWZ0Sm9ic1swXS5jcmVhdGVkQXQ7XG4gICAgICBjb25zdCByZWNlbnRCYXRjaCA9IGRyYWZ0Sm9icy5maWx0ZXIoam9iID0+IHtcbiAgICAgICAgLy8gQ29uc2lkZXIgam9icyB3aXRoaW4gNSBtaW51dGVzIG9mIGVhY2ggb3RoZXIgYXMgdGhlIHNhbWUgYmF0Y2hcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGpvYi5jcmVhdGVkQXQgLSBtb3N0UmVjZW50VGltZXN0YW1wKSA8IDUgKiA2MCAqIDEwMDA7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ29sbGVjdCBhbGwgZHJhZnQgY2FyZHMgZnJvbSB0aGUgYmF0Y2gsIGF2b2lkaW5nIGR1cGxpY2F0ZXNcbiAgICAgIGNvbnN0IGRyYWZ0Q2FyZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB7IGpvYiB9IG9mIHJlY2VudEJhdGNoKSB7XG4gICAgICAgIGlmIChqb2IuZHJhZnRDYXJkcyAmJiBqb2IuZHJhZnRDYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gRWFjaCBqb2Igbm93IHN0b3JlcyBvbmx5IG9uZSBkcmFmdCBjYXJkXG4gICAgICAgICAgY29uc3QgZHJhZnRDYXJkID0gam9iLmRyYWZ0Q2FyZHNbMF07XG4gICAgICAgICAgY29uc3QgZHJhZnRJbmRleCA9IGpvYi5kcmFmdEluZGV4ICE9PSB1bmRlZmluZWQgPyBqb2IuZHJhZnRJbmRleCA6IFxuICAgICAgICAgICAgcGFyc2VJbnQoZHJhZnRDYXJkLmlkLm1hdGNoKC9kcmFmdC0oXFxkKyktLyk/LlsxXSB8fCAnMCcpIC0gMTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgZHJhZnQgaW5kZXggYXMga2V5IHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICAgICAgICBpZiAoIWRyYWZ0Q2FyZE1hcC5oYXMoZHJhZnRJbmRleCkpIHtcbiAgICAgICAgICAgIGRyYWZ0Q2FyZE1hcC5zZXQoZHJhZnRJbmRleCwgZHJhZnRDYXJkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBtYXAgdG8gYXJyYXkgYW5kIHNvcnQgYnkgZHJhZnQgaW5kZXhcbiAgICAgIGNvbnN0IGFsbERyYWZ0Q2FyZHMgPSBBcnJheS5mcm9tKGRyYWZ0Q2FyZE1hcC5lbnRyaWVzKCkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcbiAgICAgICAgLm1hcCgoW18sIGNhcmRdKSA9PiBjYXJkKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4sgTG9hZGVkICR7YWxsRHJhZnRDYXJkcy5sZW5ndGh9IHVuaXF1ZSBkcmFmdCBjYXJkcyBmcm9tIGJhdGNoYCk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiB0aGUgYmF0Y2ggaW5mb1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FyZHM6IGFsbERyYWZ0Q2FyZHMsXG4gICAgICAgIGNyZWF0ZWRBdDogbW9zdFJlY2VudFRpbWVzdGFtcCxcbiAgICAgICAgY291bnQ6IGFsbERyYWZ0Q2FyZHMubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCByZWNlbnQgZHJhZnQgYmF0Y2g6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJ1biBjbGVhbnVwIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2xlYW51cEV4cGlyZWRKb2JzKCk7XG4gIH0sIFtjbGVhbnVwRXhwaXJlZEpvYnNdKTtcblxuICByZXR1cm4ge1xuICAgIGN1cnJlbnRKb2JJZCxcbiAgICBzZXRDdXJyZW50Sm9iSWQsXG4gICAgZ2VuZXJhdGlvblByb2dyZXNzLFxuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyxcbiAgICBwcm9ncmVzc1BlcmNlbnRhZ2UsIC8vIFJlYWQtb25seSwgY2FsY3VsYXRlZCBmcm9tIGVsYXBzZWQgdGltZVxuICAgIGdlbmVyYXRpb25TdGFydFRpbWUsXG4gICAgc2V0R2VuZXJhdGlvblN0YXJ0VGltZSxcbiAgICBjdXJyZW50RWxhcHNlZFRpbWUsXG4gICAgc2V0Q3VycmVudEVsYXBzZWRUaW1lLFxuICAgIGVsYXBzZWRUaW1lSW50ZXJ2YWwsXG4gICAgc2V0RWxhcHNlZFRpbWVJbnRlcnZhbCxcbiAgICBnZW5lcmF0aW9uRHVyYXRpb24sXG4gICAgc2V0R2VuZXJhdGlvbkR1cmF0aW9uLFxuICAgIGN1cnJlbnRKb2JUeXBlLFxuICAgIHNldEN1cnJlbnRKb2JUeXBlLFxuICAgIHNhdmVKb2JUb1N0b3JhZ2UsXG4gICAgdXBkYXRlSm9iUHJvZ3Jlc3MsXG4gICAgcmVtb3ZlSm9iRnJvbVN0b3JhZ2UsXG4gICAgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nLFxuICAgIHN0b3BFbGFwc2VkVGltZVRyYWNraW5nLFxuICAgIGNsZWFyQWxsSm9iRGF0YSxcbiAgICBjaGVja1BlbmRpbmdKb2JzLFxuICAgIGxvYWRNb3N0UmVjZW50RHJhZnRCYXRjaCxcbiAgICBjbGVhbnVwRXhwaXJlZEpvYnNcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUpvYk1hbmFnZW1lbnQiLCJjdXJyZW50Sm9iSWQiLCJzZXRDdXJyZW50Sm9iSWQiLCJnZW5lcmF0aW9uUHJvZ3Jlc3MiLCJzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MiLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJzZXRQcm9ncmVzc1BlcmNlbnRhZ2UiLCJnZW5lcmF0aW9uU3RhcnRUaW1lIiwic2V0R2VuZXJhdGlvblN0YXJ0VGltZSIsImN1cnJlbnRFbGFwc2VkVGltZSIsInNldEN1cnJlbnRFbGFwc2VkVGltZSIsImVsYXBzZWRUaW1lSW50ZXJ2YWwiLCJzZXRFbGFwc2VkVGltZUludGVydmFsIiwiZ2VuZXJhdGlvbkR1cmF0aW9uIiwic2V0R2VuZXJhdGlvbkR1cmF0aW9uIiwiY3VycmVudEpvYlR5cGUiLCJzZXRDdXJyZW50Sm9iVHlwZSIsInNhdmVKb2JUb1N0b3JhZ2UiLCJqb2JJZCIsImpvYkRhdGEiLCJlbmhhbmNlZEpvYkRhdGEiLCJpZCIsInN0YXR1cyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJleHBpcmVzQXQiLCJsYXN0UHJvZ3Jlc3MiLCJsYXN0UHJvZ3Jlc3NUZXh0IiwiZWxhcHNlZFRpbWUiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInBlbmRpbmdKb2JzIiwicGFyc2UiLCJnZXRJdGVtIiwiaW5jbHVkZXMiLCJwdXNoIiwiY2xlYW51cEV4cGlyZWRKb2JzIiwiZXJyb3IiLCJjb25zb2xlIiwidXBkYXRlSm9iUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInByb2dyZXNzVGV4dCIsImpvYiIsImxhc3RVcGRhdGUiLCJyZW1vdmVKb2JGcm9tU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJ1cGRhdGVkSm9icyIsImZpbHRlciIsImtleXNUb1JlbW92ZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRzV2l0aCIsImxvZyIsImxlbmd0aCIsImNsZWFuZWRKb2JzIiwic3RhcnRFbGFwc2VkVGltZVRyYWNraW5nIiwiam9iVHlwZSIsInN0YXJ0IiwiY2xlYXJJbnRlcnZhbCIsImV4cGVjdGVkRHVyYXRpb24iLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiZWxhcHNlZCIsIm92ZXJ0aW1lIiwib3ZlcnRpbWVQcm9ncmVzcyIsIk1hdGgiLCJtaW4iLCJyb3VuZCIsInN0b3BFbGFwc2VkVGltZVRyYWNraW5nIiwiY2xlYXJBbGxKb2JEYXRhIiwiY2hlY2tQZW5kaW5nSm9icyIsImpvYnNEYXRhIiwibG9hZE1vc3RSZWNlbnREcmFmdEJhdGNoIiwiZHJhZnRKb2JLZXlzIiwiZHJhZnRKb2JzIiwiaGFzRHJhZnRDYXJkcyIsImRyYWZ0Q2FyZHMiLCJjYXJkQ291bnQiLCJBcnJheSIsImlzQXJyYXkiLCJlIiwic29ydCIsImEiLCJiIiwibW9zdFJlY2VudFRpbWVzdGFtcCIsInJlY2VudEJhdGNoIiwiYWJzIiwiZHJhZnRDYXJkTWFwIiwiTWFwIiwiZHJhZnRDYXJkIiwiZHJhZnRJbmRleCIsInVuZGVmaW5lZCIsInBhcnNlSW50IiwibWF0Y2giLCJoYXMiLCJzZXQiLCJhbGxEcmFmdENhcmRzIiwiZnJvbSIsImVudHJpZXMiLCJtYXAiLCJfIiwiY2FyZCIsImNhcmRzIiwiY291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useJobManagement.ts\n"));

/***/ })

});
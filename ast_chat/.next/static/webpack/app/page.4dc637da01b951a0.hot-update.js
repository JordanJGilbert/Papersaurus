"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardForm.tsx":
/*!*******************************!*\
  !*** ./hooks/useCardForm.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardForm: function() { return /* binding */ useCardForm; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/storageManager */ \"(app-pages-browser)/./lib/storageManager.ts\");\n/* __next_internal_client_entry_do_not_use__ useCardForm auto */ var _s = $RefreshSig$();\n\n\nconst defaultFormData = {\n    // Step 1: Card Basics\n    selectedType: \"birthday\",\n    customCardType: \"\",\n    selectedTone: \"funny\",\n    toField: \"\",\n    fromField: \"\",\n    relationshipField: \"\",\n    // Step 2: Content Creation\n    prompt: \"\",\n    finalCardMessage: \"\",\n    isHandwrittenMessage: false,\n    // Step 3: Personalization\n    selectedArtisticStyle: \"ai-smart-style\",\n    customStyleDescription: \"\",\n    referenceImages: [],\n    referenceImageUrls: [],\n    imageTransformation: \"\",\n    // Step 4: Details\n    userEmail: \"\",\n    selectedImageModel: \"gpt-image-1\",\n    selectedDraftModel: \"gpt-image-1\",\n    selectedPaperSize: \"standard\",\n    numberOfCards: 1,\n    isFrontBackOnly: false\n};\n// Helper function to create serializable form data (excludes File objects)\nconst createSerializableFormData = (formData)=>{\n    const { referenceImages, ...serializableData } = formData;\n    return serializableData;\n};\nfunction useCardForm() {\n    _s();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultFormData);\n    const [wizardState, setWizardState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        currentStep: 1,\n        completedSteps: []\n    });\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Initialize form data from storage on component mount (after hydration)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ( true && !isInitialLoadComplete) {\n            const session = _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.getSession();\n            if (session) {\n                setFormData({\n                    ...defaultFormData,\n                    ...session.formData,\n                    referenceImages: []\n                });\n                setWizardState(session.wizardState);\n            }\n            setIsInitialLoadComplete(true);\n        }\n    }, [\n        isInitialLoadComplete\n    ]);\n    // Save form data to storage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialLoadComplete) return;\n        const serializableData = createSerializableFormData(formData);\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.saveSession(serializableData, wizardState);\n    }, [\n        formData,\n        wizardState,\n        isInitialLoadComplete\n    ]);\n    const updateFormData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setFormData((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const resetForm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFormData(defaultFormData);\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearSession();\n    }, []);\n    const clearStoredData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearAll();\n    }, []);\n    const updateWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const markStepCompleted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                completedSteps: prev.completedSteps.includes(step) ? prev.completedSteps : [\n                    ...prev.completedSteps,\n                    step\n                ]\n            }));\n    }, []);\n    const resetWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n    }, []);\n    const validateStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        switch(step){\n            case 1:\n                // Card type is required\n                if (!formData.selectedType) return false;\n                // If custom type is selected, custom description is required\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) return false;\n                // Tone is required\n                if (!formData.selectedTone) return false;\n                // If photos are uploaded, they must have descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    // Check if we have photoReferences data\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) return false;\n                    // Check if all photos have descriptions\n                    const allHaveDescriptions = formData.photoReferences.every((ref)=>ref.description && ref.description.trim());\n                    if (!allHaveDescriptions) return false;\n                }\n                return true;\n            case 2:\n                // All fields are optional - let AI generate defaults\n                return true;\n            case 3:\n                // All fields are optional\n                // If custom style is selected, description is required\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) return false;\n                // If reference images with incompatible model\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") return false;\n                return true;\n            case 4:\n                // Email is required\n                if (!formData.userEmail.trim()) return false;\n                // Basic email validation\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                if (!emailRegex.test(formData.userEmail)) return false;\n                return true;\n            case 5:\n                // All previous steps must be valid\n                return validateStep(1) && validateStep(2) && validateStep(3) && validateStep(4);\n            default:\n                return false;\n        }\n    }, [\n        formData\n    ]);\n    const getStepSummary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const summary = [];\n        switch(step){\n            case 1:\n                const cardType = formData.selectedType === \"custom\" ? formData.customCardType : formData.selectedType;\n                summary.push(\"Card Type: \".concat(cardType || \"Not selected\"));\n                summary.push(\"Tone: \".concat(formData.selectedTone || \"Not selected\"));\n                if (formData.toField) summary.push(\"To: \".concat(formData.toField));\n                if (formData.fromField) summary.push(\"From: \".concat(formData.fromField));\n                break;\n            case 2:\n                if (formData.prompt) summary.push(\"Description: \".concat(formData.prompt.substring(0, 50), \"...\"));\n                if (formData.finalCardMessage) summary.push(\"Message: \".concat(formData.finalCardMessage.substring(0, 50), \"...\"));\n                if (formData.isHandwrittenMessage) summary.push(\"Handwritten message space included\");\n                break;\n            case 3:\n                summary.push(\"Style: \".concat(formData.selectedArtisticStyle));\n                if (formData.referenceImageUrls.length > 0) {\n                    summary.push(\"Reference photos: \".concat(formData.referenceImageUrls.length, \" uploaded\"));\n                }\n                break;\n            case 4:\n                summary.push(\"Email: \".concat(formData.userEmail));\n                summary.push(\"Model: \".concat(formData.selectedImageModel));\n                summary.push(\"Paper: \".concat(formData.selectedPaperSize));\n                if (formData.isFrontBackOnly) summary.push(\"Front/back only\");\n                break;\n        }\n        return summary;\n    }, [\n        formData\n    ]);\n    const getValidationErrors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const errors = [];\n        switch(step){\n            case 1:\n                if (!formData.selectedType) errors.push(\"Please select a card type\");\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) {\n                    errors.push(\"Please describe your custom card type\");\n                }\n                if (!formData.selectedTone) errors.push(\"Please select a tone\");\n                // Check photo descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) {\n                        errors.push(\"Please describe who's in your photos\");\n                    } else {\n                        const missingDescriptions = formData.photoReferences.filter((ref)=>!ref.description || !ref.description.trim()).length;\n                        if (missingDescriptions > 0) {\n                            errors.push(\"Please describe who's in \".concat(missingDescriptions, \" photo\").concat(missingDescriptions > 1 ? \"s\" : \"\"));\n                        }\n                    }\n                }\n                break;\n            case 3:\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) {\n                    errors.push(\"Please describe your custom artistic style\");\n                }\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") {\n                    errors.push(\"Reference photos are only supported with GPT Image 1 model\");\n                }\n                break;\n            case 4:\n                if (!formData.userEmail.trim()) {\n                    errors.push(\"Email address is required\");\n                } else {\n                    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                    if (!emailRegex.test(formData.userEmail)) {\n                        errors.push(\"Please enter a valid email address\");\n                    }\n                }\n                break;\n        }\n        return errors;\n    }, [\n        formData\n    ]);\n    return {\n        formData,\n        updateFormData,\n        resetForm,\n        clearStoredData,\n        validateStep,\n        getStepSummary,\n        getValidationErrors,\n        isInitialLoadComplete,\n        wizardState: {\n            ...wizardState,\n            updateCurrentStep: (step)=>updateWizardState({\n                    currentStep: step\n                }),\n            markStepCompleted,\n            resetWizardState\n        },\n        updateWizardState\n    };\n}\n_s(useCardForm, \"YXsICAdHNvhScUcXpS7y9ubE7jc=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUV5RDtBQUNWO0FBZ0MvQyxNQUFNSSxrQkFBZ0M7SUFDcEMsc0JBQXNCO0lBQ3RCQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsbUJBQW1CO0lBRW5CLDJCQUEyQjtJQUMzQkMsUUFBUTtJQUNSQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUV0QiwwQkFBMEI7SUFDMUJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxpQkFBaUIsRUFBRTtJQUNuQkMsb0JBQW9CLEVBQUU7SUFDdEJDLHFCQUFxQjtJQUVyQixrQkFBa0I7SUFDbEJDLFdBQVc7SUFDWEMsb0JBQW9CO0lBQ3BCQyxvQkFBb0I7SUFDcEJDLG1CQUFtQjtJQUNuQkMsZUFBZTtJQUNmQyxpQkFBaUI7QUFDbkI7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUMsNkJBQTZCLENBQUNDO0lBQ2xDLE1BQU0sRUFBRVYsZUFBZSxFQUFFLEdBQUdXLGtCQUFrQixHQUFHRDtJQUNqRCxPQUFPQztBQUNUO0FBRU8sU0FBU0M7O0lBQ2QsTUFBTSxDQUFDRixVQUFVRyxZQUFZLEdBQUc3QiwrQ0FBUUEsQ0FBZUk7SUFDdkQsTUFBTSxDQUFDMEIsYUFBYUMsZUFBZSxHQUFHL0IsK0NBQVFBLENBQUM7UUFBRWdDLGFBQWE7UUFBR0MsZ0JBQWdCLEVBQUU7SUFBYTtJQUNoRyxNQUFNLENBQUNDLHVCQUF1QkMseUJBQXlCLEdBQUduQywrQ0FBUUEsQ0FBQztJQUVuRSx5RUFBeUU7SUFDekVFLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxLQUFrQixJQUFlLENBQUNnQyx1QkFBdUI7WUFDM0QsTUFBTUUsVUFBVWpDLHdEQUFPQSxDQUFDa0MsVUFBVTtZQUNsQyxJQUFJRCxTQUFTO2dCQUNYUCxZQUFZO29CQUNWLEdBQUd6QixlQUFlO29CQUNsQixHQUFH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QWhDO1FBQ0FKLGFBQWE7WUFDWCxHQUFHQSxXQUFXO1lBQ2R3QyxtQkFBbUIsQ0FBQ3RCLE9BQWlCRixrQkFBa0I7b0JBQUVkLGFBQWFnQjtnQkFBSztZQUMzRUQ7WUFDQUc7UUFDRjtRQUNBSjtJQUNGO0FBQ0Y7R0FoTmdCbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlQ2FyZEZvcm0udHN4PzRjMzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSBcIkAvbGliL3N0b3JhZ2VNYW5hZ2VyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FyZEZvcm1EYXRhIHtcbiAgLy8gU3RlcCAxOiBDYXJkIEJhc2ljc1xuICBzZWxlY3RlZFR5cGU6IHN0cmluZztcbiAgY3VzdG9tQ2FyZFR5cGU6IHN0cmluZztcbiAgc2VsZWN0ZWRUb25lOiBzdHJpbmc7XG4gIHRvRmllbGQ6IHN0cmluZztcbiAgZnJvbUZpZWxkOiBzdHJpbmc7XG4gIHJlbGF0aW9uc2hpcEZpZWxkOiBzdHJpbmc7XG5cbiAgLy8gU3RlcCAyOiBDb250ZW50IENyZWF0aW9uXG4gIHByb21wdDogc3RyaW5nO1xuICBmaW5hbENhcmRNZXNzYWdlOiBzdHJpbmc7XG4gIGlzSGFuZHdyaXR0ZW5NZXNzYWdlOiBib29sZWFuO1xuXG4gIC8vIFN0ZXAgMzogUGVyc29uYWxpemF0aW9uXG4gIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZTogc3RyaW5nO1xuICBjdXN0b21TdHlsZURlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJlZmVyZW5jZUltYWdlczogRmlsZVtdO1xuICByZWZlcmVuY2VJbWFnZVVybHM6IHN0cmluZ1tdO1xuICBwaG90b1JlZmVyZW5jZXM/OiBBcnJheTx7IGltYWdlVXJsOiBzdHJpbmc7IGltYWdlSW5kZXg6IG51bWJlcjsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IH0+O1xuXG4gIC8vIFN0ZXAgNDogRGV0YWlsc1xuICB1c2VyRW1haWw6IHN0cmluZztcbiAgc2VsZWN0ZWRJbWFnZU1vZGVsOiBzdHJpbmc7XG4gIHNlbGVjdGVkRHJhZnRNb2RlbDogc3RyaW5nO1xuICBzZWxlY3RlZFBhcGVyU2l6ZTogc3RyaW5nO1xuICBudW1iZXJPZkNhcmRzOiBudW1iZXI7XG4gIGlzRnJvbnRCYWNrT25seTogYm9vbGVhbjtcbn1cblxuY29uc3QgZGVmYXVsdEZvcm1EYXRhOiBDYXJkRm9ybURhdGEgPSB7XG4gIC8vIFN0ZXAgMTogQ2FyZCBCYXNpY3NcbiAgc2VsZWN0ZWRUeXBlOiBcImJpcnRoZGF5XCIsXG4gIGN1c3RvbUNhcmRUeXBlOiBcIlwiLFxuICBzZWxlY3RlZFRvbmU6IFwiZnVubnlcIixcbiAgdG9GaWVsZDogXCJcIixcbiAgZnJvbUZpZWxkOiBcIlwiLFxuICByZWxhdGlvbnNoaXBGaWVsZDogXCJcIixcblxuICAvLyBTdGVwIDI6IENvbnRlbnQgQ3JlYXRpb25cbiAgcHJvbXB0OiBcIlwiLFxuICBmaW5hbENhcmRNZXNzYWdlOiBcIlwiLFxuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogZmFsc2UsXG5cbiAgLy8gU3RlcCAzOiBQZXJzb25hbGl6YXRpb25cbiAgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlOiBcImFpLXNtYXJ0LXN0eWxlXCIsXG4gIGN1c3RvbVN0eWxlRGVzY3JpcHRpb246IFwiXCIsXG4gIHJlZmVyZW5jZUltYWdlczogW10sXG4gIHJlZmVyZW5jZUltYWdlVXJsczogW10sXG4gIGltYWdlVHJhbnNmb3JtYXRpb246IFwiXCIsXG5cbiAgLy8gU3RlcCA0OiBEZXRhaWxzXG4gIHVzZXJFbWFpbDogXCJcIixcbiAgc2VsZWN0ZWRJbWFnZU1vZGVsOiBcImdwdC1pbWFnZS0xXCIsXG4gIHNlbGVjdGVkRHJhZnRNb2RlbDogXCJncHQtaW1hZ2UtMVwiLFxuICBzZWxlY3RlZFBhcGVyU2l6ZTogXCJzdGFuZGFyZFwiLFxuICBudW1iZXJPZkNhcmRzOiAxLFxuICBpc0Zyb250QmFja09ubHk6IGZhbHNlLFxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzZXJpYWxpemFibGUgZm9ybSBkYXRhIChleGNsdWRlcyBGaWxlIG9iamVjdHMpXG5jb25zdCBjcmVhdGVTZXJpYWxpemFibGVGb3JtRGF0YSA9IChmb3JtRGF0YTogQ2FyZEZvcm1EYXRhKTogT21pdDxDYXJkRm9ybURhdGEsICdyZWZlcmVuY2VJbWFnZXMnPiA9PiB7XG4gIGNvbnN0IHsgcmVmZXJlbmNlSW1hZ2VzLCAuLi5zZXJpYWxpemFibGVEYXRhIH0gPSBmb3JtRGF0YTtcbiAgcmV0dXJuIHNlcmlhbGl6YWJsZURhdGE7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FyZEZvcm0oKSB7XG4gIGNvbnN0IFtmb3JtRGF0YSwgc2V0Rm9ybURhdGFdID0gdXNlU3RhdGU8Q2FyZEZvcm1EYXRhPihkZWZhdWx0Rm9ybURhdGEpO1xuICBjb25zdCBbd2l6YXJkU3RhdGUsIHNldFdpemFyZFN0YXRlXSA9IHVzZVN0YXRlKHsgY3VycmVudFN0ZXA6IDEsIGNvbXBsZXRlZFN0ZXBzOiBbXSBhcyBudW1iZXJbXSB9KTtcbiAgY29uc3QgW2lzSW5pdGlhbExvYWRDb21wbGV0ZSwgc2V0SXNJbml0aWFsTG9hZENvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBJbml0aWFsaXplIGZvcm0gZGF0YSBmcm9tIHN0b3JhZ2Ugb24gY29tcG9uZW50IG1vdW50IChhZnRlciBoeWRyYXRpb24pXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFpc0luaXRpYWxMb2FkQ29tcGxldGUpIHtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBzdG9yYWdlLmdldFNlc3Npb24oKTtcbiAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgIHNldEZvcm1EYXRhKHtcbiAgICAgICAgICAuLi5kZWZhdWx0Rm9ybURhdGEsXG4gICAgICAgICAgLi4uc2Vzc2lvbi5mb3JtRGF0YSxcbiAgICAgICAgICByZWZlcmVuY2VJbWFnZXM6IFtdLCAvLyBBbHdheXMgcmVzZXQgRmlsZSBvYmplY3RzXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRXaXphcmRTdGF0ZShzZXNzaW9uLndpemFyZFN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHNldElzSW5pdGlhbExvYWRDb21wbGV0ZSh0cnVlKTtcbiAgICB9XG4gIH0sIFtpc0luaXRpYWxMb2FkQ29tcGxldGVdKTtcblxuICAvLyBTYXZlIGZvcm0gZGF0YSB0byBzdG9yYWdlIHdoZW5ldmVyIGl0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzSW5pdGlhbExvYWRDb21wbGV0ZSkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2VyaWFsaXphYmxlRGF0YSA9IGNyZWF0ZVNlcmlhbGl6YWJsZUZvcm1EYXRhKGZvcm1EYXRhKTtcbiAgICBzdG9yYWdlLnNhdmVTZXNzaW9uKHNlcmlhbGl6YWJsZURhdGEsIHdpemFyZFN0YXRlKTtcbiAgfSwgW2Zvcm1EYXRhLCB3aXphcmRTdGF0ZSwgaXNJbml0aWFsTG9hZENvbXBsZXRlXSk7XG5cbiAgY29uc3QgdXBkYXRlRm9ybURhdGEgPSB1c2VDYWxsYmFjaygodXBkYXRlczogUGFydGlhbDxDYXJkRm9ybURhdGE+KSA9PiB7XG4gICAgc2V0Rm9ybURhdGEocHJldiA9PiAoeyAuLi5wcmV2LCAuLi51cGRhdGVzIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlc2V0Rm9ybSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRGb3JtRGF0YShkZWZhdWx0Rm9ybURhdGEpO1xuICAgIHNldFdpemFyZFN0YXRlKHsgY3VycmVudFN0ZXA6IDEsIGNvbXBsZXRlZFN0ZXBzOiBbXSB9KTtcbiAgICBzdG9yYWdlLmNsZWFyU2Vzc2lvbigpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2xlYXJTdG9yZWREYXRhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHN0b3JhZ2UuY2xlYXJBbGwoKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHVwZGF0ZVdpemFyZFN0YXRlID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXM6IFBhcnRpYWw8dHlwZW9mIHdpemFyZFN0YXRlPikgPT4ge1xuICAgIHNldFdpemFyZFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgLi4udXBkYXRlcyB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBtYXJrU3RlcENvbXBsZXRlZCA9IHVzZUNhbGxiYWNrKChzdGVwOiBudW1iZXIpID0+IHtcbiAgICBzZXRXaXphcmRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgY29tcGxldGVkU3RlcHM6IHByZXYuY29tcGxldGVkU3RlcHMuaW5jbHVkZXMoc3RlcCkgXG4gICAgICAgID8gcHJldi5jb21wbGV0ZWRTdGVwcyBcbiAgICAgICAgOiBbLi4ucHJldi5jb21wbGV0ZWRTdGVwcywgc3RlcF1cbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCByZXNldFdpemFyZFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFdpemFyZFN0YXRlKHsgY3VycmVudFN0ZXA6IDEsIGNvbXBsZXRlZFN0ZXBzOiBbXSB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHZhbGlkYXRlU3RlcCA9IHVzZUNhbGxiYWNrKChzdGVwOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTogLy8gQ2FyZCBCYXNpY3NcbiAgICAgICAgLy8gQ2FyZCB0eXBlIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmICghZm9ybURhdGEuc2VsZWN0ZWRUeXBlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIGN1c3RvbSB0eXBlIGlzIHNlbGVjdGVkLCBjdXN0b20gZGVzY3JpcHRpb24gaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKGZvcm1EYXRhLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiAmJiAhZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUudHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRvbmUgaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFRvbmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgcGhvdG9zIGFyZSB1cGxvYWRlZCwgdGhleSBtdXN0IGhhdmUgZGVzY3JpcHRpb25zXG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcGhvdG9SZWZlcmVuY2VzIGRhdGFcbiAgICAgICAgICBpZiAoIWZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcyB8fCBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHBob3RvcyBoYXZlIGRlc2NyaXB0aW9uc1xuICAgICAgICAgIGNvbnN0IGFsbEhhdmVEZXNjcmlwdGlvbnMgPSBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMuZXZlcnkocmVmID0+IHJlZi5kZXNjcmlwdGlvbiAmJiByZWYuZGVzY3JpcHRpb24udHJpbSgpKTtcbiAgICAgICAgICBpZiAoIWFsbEhhdmVEZXNjcmlwdGlvbnMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSAyOiAvLyBDb250ZW50IENyZWF0aW9uXG4gICAgICAgIC8vIEFsbCBmaWVsZHMgYXJlIG9wdGlvbmFsIC0gbGV0IEFJIGdlbmVyYXRlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDM6IC8vIFBlcnNvbmFsaXphdGlvblxuICAgICAgICAvLyBBbGwgZmllbGRzIGFyZSBvcHRpb25hbFxuICAgICAgICAvLyBJZiBjdXN0b20gc3R5bGUgaXMgc2VsZWN0ZWQsIGRlc2NyaXB0aW9uIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbVN0eWxlRGVzY3JpcHRpb24udHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHJlZmVyZW5jZSBpbWFnZXMgd2l0aCBpbmNvbXBhdGlibGUgbW9kZWxcbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIGZvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbCAhPT0gXCJncHQtaW1hZ2UtMVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDQ6IC8vIERldGFpbHNcbiAgICAgICAgLy8gRW1haWwgaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFmb3JtRGF0YS51c2VyRW1haWwudHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEJhc2ljIGVtYWlsIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChmb3JtRGF0YS51c2VyRW1haWwpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDU6IC8vIEdlbmVyYXRlXG4gICAgICAgIC8vIEFsbCBwcmV2aW91cyBzdGVwcyBtdXN0IGJlIHZhbGlkXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVN0ZXAoMSkgJiYgdmFsaWRhdGVTdGVwKDIpICYmIHZhbGlkYXRlU3RlcCgzKSAmJiB2YWxpZGF0ZVN0ZXAoNCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFtmb3JtRGF0YV0pO1xuXG4gIGNvbnN0IGdldFN0ZXBTdW1tYXJ5ID0gdXNlQ2FsbGJhY2soKHN0ZXA6IG51bWJlcik6IHN0cmluZ1tdID0+IHtcbiAgICBjb25zdCBzdW1tYXJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjb25zdCBjYXJkVHlwZSA9IGZvcm1EYXRhLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGZvcm1EYXRhLmN1c3RvbUNhcmRUeXBlIDogZm9ybURhdGEuc2VsZWN0ZWRUeXBlO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYENhcmQgVHlwZTogJHtjYXJkVHlwZSB8fCBcIk5vdCBzZWxlY3RlZFwifWApO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYFRvbmU6ICR7Zm9ybURhdGEuc2VsZWN0ZWRUb25lIHx8IFwiTm90IHNlbGVjdGVkXCJ9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS50b0ZpZWxkKSBzdW1tYXJ5LnB1c2goYFRvOiAke2Zvcm1EYXRhLnRvRmllbGR9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5mcm9tRmllbGQpIHN1bW1hcnkucHVzaChgRnJvbTogJHtmb3JtRGF0YS5mcm9tRmllbGR9YCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmIChmb3JtRGF0YS5wcm9tcHQpIHN1bW1hcnkucHVzaChgRGVzY3JpcHRpb246ICR7Zm9ybURhdGEucHJvbXB0LnN1YnN0cmluZygwLCA1MCl9Li4uYCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5maW5hbENhcmRNZXNzYWdlKSBzdW1tYXJ5LnB1c2goYE1lc3NhZ2U6ICR7Zm9ybURhdGEuZmluYWxDYXJkTWVzc2FnZS5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xuICAgICAgICBpZiAoZm9ybURhdGEuaXNIYW5kd3JpdHRlbk1lc3NhZ2UpIHN1bW1hcnkucHVzaChcIkhhbmR3cml0dGVuIG1lc3NhZ2Ugc3BhY2UgaW5jbHVkZWRcIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN1bW1hcnkucHVzaChgU3R5bGU6ICR7Zm9ybURhdGEuc2VsZWN0ZWRBcnRpc3RpY1N0eWxlfWApO1xuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdW1tYXJ5LnB1c2goYFJlZmVyZW5jZSBwaG90b3M6ICR7Zm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aH0gdXBsb2FkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA0OlxuICAgICAgICBzdW1tYXJ5LnB1c2goYEVtYWlsOiAke2Zvcm1EYXRhLnVzZXJFbWFpbH1gKTtcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBNb2RlbDogJHtmb3JtRGF0YS5zZWxlY3RlZEltYWdlTW9kZWx9YCk7XG4gICAgICAgIHN1bW1hcnkucHVzaChgUGFwZXI6ICR7Zm9ybURhdGEuc2VsZWN0ZWRQYXBlclNpemV9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5pc0Zyb250QmFja09ubHkpIHN1bW1hcnkucHVzaChcIkZyb250L2JhY2sgb25seVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bW1hcnk7XG4gIH0sIFtmb3JtRGF0YV0pO1xuXG4gIGNvbnN0IGdldFZhbGlkYXRpb25FcnJvcnMgPSB1c2VDYWxsYmFjaygoc3RlcDogbnVtYmVyKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoIWZvcm1EYXRhLnNlbGVjdGVkVHlwZSkgZXJyb3JzLnB1c2goXCJQbGVhc2Ugc2VsZWN0IGEgY2FyZCB0eXBlXCIpO1xuICAgICAgICBpZiAoZm9ybURhdGEuc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiICYmICFmb3JtRGF0YS5jdXN0b21DYXJkVHlwZS50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBkZXNjcmliZSB5b3VyIGN1c3RvbSBjYXJkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFRvbmUpIGVycm9ycy5wdXNoKFwiUGxlYXNlIHNlbGVjdCBhIHRvbmVcIik7XG4gICAgICAgIC8vIENoZWNrIHBob3RvIGRlc2NyaXB0aW9uc1xuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoIWZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcyB8fCBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBkZXNjcmliZSB3aG8ncyBpbiB5b3VyIHBob3Rvc1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0Rlc2NyaXB0aW9ucyA9IGZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcy5maWx0ZXIocmVmID0+ICFyZWYuZGVzY3JpcHRpb24gfHwgIXJlZi5kZXNjcmlwdGlvbi50cmltKCkpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nRGVzY3JpcHRpb25zID4gMCkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChgUGxlYXNlIGRlc2NyaWJlIHdobydzIGluICR7bWlzc2luZ0Rlc2NyaXB0aW9uc30gcGhvdG8ke21pc3NpbmdEZXNjcmlwdGlvbnMgPiAxID8gJ3MnIDogJyd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbVN0eWxlRGVzY3JpcHRpb24udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIGZvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbCAhPT0gXCJncHQtaW1hZ2UtMVwiKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJSZWZlcmVuY2UgcGhvdG9zIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIEdQVCBJbWFnZSAxIG1vZGVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICghZm9ybURhdGEudXNlckVtYWlsLnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiRW1haWwgYWRkcmVzcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoZm9ybURhdGEudXNlckVtYWlsKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9LCBbZm9ybURhdGFdKTtcblxuICByZXR1cm4ge1xuICAgIGZvcm1EYXRhLFxuICAgIHVwZGF0ZUZvcm1EYXRhLFxuICAgIHJlc2V0Rm9ybSxcbiAgICBjbGVhclN0b3JlZERhdGEsXG4gICAgdmFsaWRhdGVTdGVwLFxuICAgIGdldFN0ZXBTdW1tYXJ5LFxuICAgIGdldFZhbGlkYXRpb25FcnJvcnMsXG4gICAgaXNJbml0aWFsTG9hZENvbXBsZXRlLFxuICAgIHdpemFyZFN0YXRlOiB7XG4gICAgICAuLi53aXphcmRTdGF0ZSxcbiAgICAgIHVwZGF0ZUN1cnJlbnRTdGVwOiAoc3RlcDogbnVtYmVyKSA9PiB1cGRhdGVXaXphcmRTdGF0ZSh7IGN1cnJlbnRTdGVwOiBzdGVwIH0pLFxuICAgICAgbWFya1N0ZXBDb21wbGV0ZWQsXG4gICAgICByZXNldFdpemFyZFN0YXRlLFxuICAgIH0sXG4gICAgdXBkYXRlV2l6YXJkU3RhdGUsXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0Iiwic3RvcmFnZSIsImRlZmF1bHRGb3JtRGF0YSIsInNlbGVjdGVkVHlwZSIsImN1c3RvbUNhcmRUeXBlIiwic2VsZWN0ZWRUb25lIiwidG9GaWVsZCIsImZyb21GaWVsZCIsInJlbGF0aW9uc2hpcEZpZWxkIiwicHJvbXB0IiwiZmluYWxDYXJkTWVzc2FnZSIsImlzSGFuZHdyaXR0ZW5NZXNzYWdlIiwic2VsZWN0ZWRBcnRpc3RpY1N0eWxlIiwiY3VzdG9tU3R5bGVEZXNjcmlwdGlvbiIsInJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlVXJscyIsImltYWdlVHJhbnNmb3JtYXRpb24iLCJ1c2VyRW1haWwiLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJzZWxlY3RlZERyYWZ0TW9kZWwiLCJzZWxlY3RlZFBhcGVyU2l6ZSIsIm51bWJlck9mQ2FyZHMiLCJpc0Zyb250QmFja09ubHkiLCJjcmVhdGVTZXJpYWxpemFibGVGb3JtRGF0YSIsImZvcm1EYXRhIiwic2VyaWFsaXphYmxlRGF0YSIsInVzZUNhcmRGb3JtIiwic2V0Rm9ybURhdGEiLCJ3aXphcmRTdGF0ZSIsInNldFdpemFyZFN0YXRlIiwiY3VycmVudFN0ZXAiLCJjb21wbGV0ZWRTdGVwcyIsImlzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNldElzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNlc3Npb24iLCJnZXRTZXNzaW9uIiwic2F2ZVNlc3Npb24iLCJ1cGRhdGVGb3JtRGF0YSIsInVwZGF0ZXMiLCJwcmV2IiwicmVzZXRGb3JtIiwiY2xlYXJTZXNzaW9uIiwiY2xlYXJTdG9yZWREYXRhIiwiY2xlYXJBbGwiLCJ1cGRhdGVXaXphcmRTdGF0ZSIsIm1hcmtTdGVwQ29tcGxldGVkIiwic3RlcCIsImluY2x1ZGVzIiwicmVzZXRXaXphcmRTdGF0ZSIsInZhbGlkYXRlU3RlcCIsInRyaW0iLCJsZW5ndGgiLCJwaG90b1JlZmVyZW5jZXMiLCJhbGxIYXZlRGVzY3JpcHRpb25zIiwiZXZlcnkiLCJyZWYiLCJkZXNjcmlwdGlvbiIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwiZ2V0U3RlcFN1bW1hcnkiLCJzdW1tYXJ5IiwiY2FyZFR5cGUiLCJwdXNoIiwic3Vic3RyaW5nIiwiZ2V0VmFsaWRhdGlvbkVycm9ycyIsImVycm9ycyIsIm1pc3NpbmdEZXNjcmlwdGlvbnMiLCJmaWx0ZXIiLCJ1cGRhdGVDdXJyZW50U3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardForm.tsx\n"));

/***/ })

});
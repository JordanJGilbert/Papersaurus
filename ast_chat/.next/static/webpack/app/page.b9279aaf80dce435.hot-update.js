"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts":
/*!*********************************************!*\
  !*** ./hooks/cardStudio/useFileHandling.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFileHandling: function() { return /* binding */ useFileHandling; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useFileHandling auto */ \n\n\nfunction useFileHandling() {\n    const [handwritingSample, setHandwritingSample] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [handwritingSampleUrl, setHandwritingSampleUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [referenceImages, setReferenceImages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [referenceImageUrls, setReferenceImageUrls] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [imageTransformation, setImageTransformation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Photo analysis state\n    const [photoAnalyses, setPhotoAnalyses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isAnalyzing, setIsAnalyzing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [showAnalysisModal, setShowAnalysisModal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [pendingAnalysisIndex, setPendingAnalysisIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // File upload handler\n    const handleFileUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (file, type)=>{\n        if (!file.type.startsWith(\"image/\")) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please upload an image file\");\n            return;\n        }\n        setIsUploading(true);\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_2__.BACKEND_API_BASE_URL, \"/upload\"), {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Upload failed: \".concat(response.status));\n            const result = await response.json();\n            if (type === \"handwriting\") {\n                setHandwritingSample(file);\n                setHandwritingSampleUrl(result.url);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Handwriting sample uploaded!\");\n            } else {\n                const newImageIndex = referenceImages.length;\n                setReferenceImages((prev)=>[\n                        ...prev,\n                        file\n                    ]);\n                setReferenceImageUrls((prev)=>[\n                        ...prev,\n                        result.url\n                    ]);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image uploaded! \".concat(referenceImages.length + 1, \" photo\").concat(referenceImages.length + 1 > 1 ? \"s\" : \"\", \" ready for character creation.\"));\n                // Store the URL and index for later analysis\n                const analysisData = {\n                    url: result.url,\n                    index: newImageIndex\n                };\n                // Auto-analyze the photo in the background after state updates\n                setTimeout(()=>{\n                    console.log(\"\\uD83E\\uDD16 Auto-analyzing uploaded photo...\");\n                    analyzePhoto(analysisData.url, analysisData.index).then((analysisResult)=>{\n                        if (analysisResult && analysisResult.peopleCount > 0) {\n                            console.log(\"✅ Photo analysis complete: \".concat(analysisResult.peopleCount, \" people detected\"));\n                            // Create default photo analysis with all people included\n                            const defaultAnalysis = {\n                                imageUrl: analysisData.url,\n                                imageIndex: analysisData.index,\n                                analysisResult: analysisResult,\n                                selectedPeople: analysisResult.people.map((person)=>({\n                                        ...person,\n                                        includeInCard: true,\n                                        name: \"\",\n                                        relationshipToRecipient: \"\"\n                                    })),\n                                includeEveryone: true,\n                                excludedCount: 0,\n                                analyzed: true,\n                                analysisFailed: false\n                            };\n                            // Save the analysis silently\n                            setPhotoAnalyses((prev)=>{\n                                const newAnalyses = [\n                                    ...prev\n                                ];\n                                newAnalyses[analysisData.index] = defaultAnalysis;\n                                return newAnalyses;\n                            });\n                            // Subtle notification that analysis is complete\n                            if (analysisResult.peopleCount === 1) {\n                                console.log(\"\\uD83D\\uDCF8 1 person detected and ready for card creation\");\n                            } else {\n                                console.log(\"\\uD83D\\uDCF8 \".concat(analysisResult.peopleCount, \" people detected and ready for card creation\"));\n                            }\n                        } else if (analysisResult && analysisResult.peopleCount === 0) {\n                            console.log(\"\\uD83D\\uDCF8 No people detected in photo, but it can still be used for reference\");\n                        } else {\n                            console.log(\"⚠️ Photo analysis failed, but photo can still be used\");\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to auto-analyze photo:\", error);\n                    // Don't show error toast - silent failure is OK since analysis is optional\n                    });\n                }, 100); // Small delay to ensure state updates are complete\n            }\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Upload failed. Please try again.\");\n        } finally{\n            setIsUploading(false);\n        }\n    }, [\n        referenceImages.length\n    ]);\n    const handleRemoveReferenceImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index)=>{\n        const removedImage = referenceImages[index];\n        const removedUrl = referenceImageUrls[index];\n        setReferenceImages((prev)=>prev.filter((_, i)=>i !== index));\n        setReferenceImageUrls((prev)=>prev.filter((_, i)=>i !== index));\n        // Also remove associated photo analysis\n        setPhotoAnalyses((prev)=>prev.filter((_, i)=>i !== index));\n        console.log(\"\\uD83D\\uDD0D DEBUG: Reference image removed:\", {\n            fileName: removedImage === null || removedImage === void 0 ? void 0 : removedImage.name,\n            url: removedUrl,\n            remainingImages: referenceImages.length - 1\n        });\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image removed! \".concat(referenceImages.length - 1, \" photo\").concat(referenceImages.length - 1 !== 1 ? \"s\" : \"\", \" remaining.\"));\n    }, [\n        referenceImages,\n        referenceImageUrls\n    ]);\n    // Analyze a photo using AI vision\n    const analyzePhoto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (imageUrl, imageIndex)=>{\n        console.log(\"\\uD83D\\uDCF8 Starting photo analysis for:\", imageUrl);\n        setIsAnalyzing(true);\n        try {\n            // Ensure the image URL is absolute\n            let fullImageUrl = imageUrl;\n            if (imageUrl.startsWith(\"/\")) {\n                fullImageUrl = \"\".concat(window.location.origin).concat(imageUrl);\n            }\n            console.log(\"\\uD83D\\uDCF8 Using full image URL:\", fullImageUrl);\n            const analysisPrompt = 'Analyze this photo and provide a detailed JSON response with the following structure:\\n{\\n  \"peopleCount\": <number of people in photo>,\\n  \"people\": [\\n    {\\n      \"id\": \"person-1\",\\n      \"position\": <one of: \"far-left\", \"left\", \"center-left\", \"center\", \"center-right\", \"right\", \"far-right\">,\\n      \"positionDescription\": <natural description like \"person on the far left wearing blue\">,\\n      \"description\": <overall appearance description>,\\n      \"apparentAge\": <age range like \"20-25\" or \"40s\">,\\n      \"gender\": <apparent gender if identifiable>,\\n      \"hairColor\": <hair color>,\\n      \"hairStyle\": <hair style/length>,\\n      \"distinguishingFeatures\": <notable features like glasses, beard, etc.>,\\n      \"clothing\": <what they\\'re wearing>,\\n      \"expression\": <facial expression/mood>\\n    }\\n  ],\\n  \"hasPets\": <boolean>,\\n  \"petDescription\": <description of pets if present>,\\n  \"backgroundDescription\": <description of the background/environment>,\\n  \"setting\": <type of setting like \"outdoor park\", \"beach\", \"indoor\", etc.>,\\n  \"overallMood\": <overall mood/atmosphere of the photo>,\\n  \"lighting\": <lighting conditions>\\n}\\n\\nFor each person:\\n1. Describe their position in the image using the enum values\\n2. Provide a brief description of their appearance  \\n3. Estimate their apparent age range\\n4. Note their hair color and style\\n5. Describe their clothing\\n6. Note any distinguishing features\\n7. Describe their expression/mood\\n\\nReturn ONLY the JSON response, no additional text.';\n            // Use the analyze_images tool through the MCP service\n            const response = await fetch(\"/internal/call_mcp_tool\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    tool_name: \"analyze_images\",\n                    arguments: {\n                        urls: [\n                            fullImageUrl\n                        ],\n                        analysis_prompt: analysisPrompt\n                    }\n                })\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"analyze_images error response:\", errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log(\"\\uD83E\\uDD16 analyze_images response data:\", data);\n            if (data.error && data.error !== \"None\" && data.error !== null) {\n                throw new Error(data.error);\n            }\n            let result;\n            if (typeof data.result === \"string\") {\n                try {\n                    result = JSON.parse(data.result);\n                } catch (e) {\n                    result = {\n                        status: \"error\",\n                        message: \"Invalid JSON response from MCP\"\n                    };\n                }\n            } else {\n                result = data.result;\n            }\n            if (result.status === \"error\") {\n                throw new Error(result.message);\n            }\n            // Extract the analysis from the results array\n            if (result.results && result.results.length > 0) {\n                const imageResult = result.results[0];\n                if (imageResult.status === \"success\" && imageResult.analysis) {\n                    console.log(\"\\uD83D\\uDCF8 Raw analysis text:\", imageResult.analysis);\n                    // Try to parse the analysis as JSON\n                    try {\n                        // Extract JSON from the analysis text\n                        let jsonText = imageResult.analysis;\n                        // If the response contains markdown code blocks, extract the JSON\n                        const jsonMatch = jsonText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n                        if (jsonMatch) {\n                            jsonText = jsonMatch[1];\n                        }\n                        // Parse the JSON\n                        const analysisData = JSON.parse(jsonText);\n                        console.log(\"\\uD83D\\uDCF8 Parsed analysis data:\", analysisData);\n                        // Ensure the data matches our expected structure\n                        if (typeof analysisData.peopleCount === \"number\" && Array.isArray(analysisData.people)) {\n                            setIsAnalyzing(false);\n                            return analysisData;\n                        } else {\n                            console.error(\"Analysis data doesn't match expected structure\");\n                            setIsAnalyzing(false);\n                            return null;\n                        }\n                    } catch (parseError) {\n                        console.error(\"Failed to parse analysis as JSON:\", parseError);\n                        console.error(\"Raw analysis:\", imageResult.analysis);\n                        setIsAnalyzing(false);\n                        return null;\n                    }\n                } else {\n                    console.error(\"Image analysis failed:\", imageResult.message);\n                    setIsAnalyzing(false);\n                    return null;\n                }\n            } else {\n                console.error(\"No results returned from analyze_images\");\n                setIsAnalyzing(false);\n                return null;\n            }\n        } catch (error) {\n            console.error(\"Failed to analyze photo:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to analyze photo. You can still use it without analysis.\");\n            setIsAnalyzing(false);\n            return null;\n        }\n    }, []);\n    // Save photo analysis results\n    const savePhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((analysis)=>{\n        setPhotoAnalyses((prev)=>{\n            const newAnalyses = [\n                ...prev\n            ];\n            newAnalyses[analysis.imageIndex] = analysis;\n            return newAnalyses;\n        });\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, []);\n    // Skip photo analysis\n    const skipPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pendingAnalysisIndex !== null) {\n            const skippedAnalysis = {\n                imageUrl: referenceImageUrls[pendingAnalysisIndex],\n                imageIndex: pendingAnalysisIndex,\n                analysisResult: {\n                    peopleCount: 0,\n                    people: [],\n                    hasPets: false,\n                    backgroundDescription: \"\",\n                    setting: \"\",\n                    overallMood: \"\",\n                    lighting: \"\"\n                },\n                selectedPeople: [],\n                includeEveryone: true,\n                excludedCount: 0,\n                analyzed: false,\n                analysisFailed: false\n            };\n            savePhotoAnalysis(skippedAnalysis);\n        }\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, [\n        pendingAnalysisIndex,\n        referenceImageUrls,\n        savePhotoAnalysis\n    ]);\n    // Get combined analysis for all photos\n    const getCombinedPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const analyzedPhotos = photoAnalyses.filter((a)=>a.analyzed && !a.analysisFailed);\n        if (analyzedPhotos.length === 0) return null;\n        const allSelectedPeople = analyzedPhotos.flatMap((a)=>a.selectedPeople);\n        const totalPeopleCount = analyzedPhotos.reduce((sum, a)=>sum + a.analysisResult.peopleCount, 0);\n        const totalSelectedCount = allSelectedPeople.length;\n        const totalExcludedCount = totalPeopleCount - totalSelectedCount;\n        return {\n            analyzedPhotos,\n            allSelectedPeople,\n            totalPeopleCount,\n            totalSelectedCount,\n            totalExcludedCount,\n            hasMultiplePhotos: analyzedPhotos.length > 1\n        };\n    }, [\n        photoAnalyses\n    ]);\n    // Manually trigger photo analysis for a specific image\n    const triggerPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageIndex)=>{\n        if (imageIndex >= 0 && imageIndex < referenceImageUrls.length) {\n            setPendingAnalysisIndex(imageIndex);\n            setShowAnalysisModal(true);\n        }\n    }, [\n        referenceImageUrls.length\n    ]);\n    return {\n        handwritingSample,\n        setHandwritingSample,\n        handwritingSampleUrl,\n        setHandwritingSampleUrl,\n        referenceImages,\n        setReferenceImages,\n        referenceImageUrls,\n        setReferenceImageUrls,\n        imageTransformation,\n        setImageTransformation,\n        isUploading,\n        setIsUploading,\n        handleFileUpload,\n        handleRemoveReferenceImage,\n        // Photo analysis\n        photoAnalyses,\n        setPhotoAnalyses,\n        isAnalyzing,\n        showAnalysisModal,\n        setShowAnalysisModal,\n        pendingAnalysisIndex,\n        setPendingAnalysisIndex,\n        analyzePhoto,\n        savePhotoAnalysis,\n        skipPhotoAnalysis,\n        getCombinedPhotoAnalysis,\n        triggerPhotoAnalysis\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRmlsZUhhbmRsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FFQUU4QztBQUNmO0FBQ3dFO0FBR2hHLFNBQVNJO0lBQ2QsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHTiwrQ0FBUUEsQ0FBYztJQUN4RSxNQUFNLENBQUNPLHNCQUFzQkMsd0JBQXdCLEdBQUdSLCtDQUFRQSxDQUFnQjtJQUNoRixNQUFNLENBQUNTLGlCQUFpQkMsbUJBQW1CLEdBQUdWLCtDQUFRQSxDQUFTLEVBQUU7SUFDakUsTUFBTSxDQUFDVyxvQkFBb0JDLHNCQUFzQixHQUFHWiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3pFLE1BQU0sQ0FBQ2EscUJBQXFCQyx1QkFBdUIsR0FBR2QsK0NBQVFBLENBQVM7SUFDdkUsTUFBTSxDQUFDZSxhQUFhQyxlQUFlLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUUvQyx1QkFBdUI7SUFDdkIsTUFBTSxDQUFDaUIsZUFBZUMsaUJBQWlCLEdBQUdsQiwrQ0FBUUEsQ0FBa0IsRUFBRTtJQUN0RSxNQUFNLENBQUNtQixhQUFhQyxlQUFlLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNxQixtQkFBbUJDLHFCQUFxQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDdUIsc0JBQXNCQyx3QkFBd0IsR0FBR3hCLCtDQUFRQSxDQUFnQjtJQUVoRixzQkFBc0I7SUFDdEIsTUFBTXlCLG1CQUFtQnhCLGtEQUFXQSxDQUFDLE9BQU95QixNQUFZQztRQUN0RCxJQUFJLENBQUNELEtBQUtDLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFdBQVc7WUFDbkMxQix5Q0FBS0EsQ0FBQzJCLEtBQUssQ0FBQztZQUNaO1FBQ0Y7UUFFQWIsZUFBZTtRQUVmLElBQUk7WUFDRixNQUFNYyxXQUFXLElBQUlDO1lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsUUFBUU47WUFFeEIsTUFBTU8sV0FBVyxN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R0FBRyxPQUFPO1FBRXhDLE1BQU13RSxvQkFBb0JGLGVBQWVHLE9BQU8sQ0FBQ0YsQ0FBQUEsSUFBS0EsRUFBRXpELGNBQWM7UUFDdEUsTUFBTTRELG1CQUFtQkosZUFBZUssTUFBTSxDQUFDLENBQUNDLEtBQUtMLElBQU1LLE1BQU1MLEVBQUU5RCxjQUFjLENBQUNDLFdBQVcsRUFBRTtRQUMvRixNQUFNbUUscUJBQXFCTCxrQkFBa0J4RSxNQUFNO1FBQ25ELE1BQU04RSxxQkFBcUJKLG1CQUFtQkc7UUFFOUMsT0FBTztZQUNMUDtZQUNBRTtZQUNBRTtZQUNBRztZQUNBQztZQUNBQyxtQkFBbUJULGVBQWV0RSxNQUFNLEdBQUc7UUFDN0M7SUFDRixHQUFHO1FBQUM1QjtLQUFjO0lBRWxCLHVEQUF1RDtJQUN2RCxNQUFNNEcsdUJBQXVCNUgsa0RBQVdBLENBQUMsQ0FBQ3lEO1FBQ3hDLElBQUlBLGNBQWMsS0FBS0EsYUFBYS9DLG1CQUFtQmtDLE1BQU0sRUFBRTtZQUM3RHJCLHdCQUF3QmtDO1lBQ3hCcEMscUJBQXFCO1FBQ3ZCO0lBQ0YsR0FBRztRQUFDWCxtQkFBbUJrQyxNQUFNO0tBQUM7SUFFOUIsT0FBTztRQUNMeEM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQVM7UUFDQStDO1FBQ0EsaUJBQWlCO1FBQ2pCdkQ7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQTRCO1FBQ0FzRDtRQUNBQztRQUNBTztRQUNBVztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvY2FyZFN0dWRpby91c2VGaWxlSGFuZGxpbmcudHM/YzRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJzb25uZXJcIjtcbmltcG9ydCB7IEJBQ0tFTkRfQVBJX0JBU0VfVVJMLCBQaG90b0FuYWx5c2lzLCBQaG90b0FuYWx5c2lzUmVzdWx0LCBTZWxlY3RlZFBlcnNvbiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNoYXRXaXRoQUkgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbGVIYW5kbGluZygpIHtcbiAgY29uc3QgW2hhbmR3cml0aW5nU2FtcGxlLCBzZXRIYW5kd3JpdGluZ1NhbXBsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtoYW5kd3JpdGluZ1NhbXBsZVVybCwgc2V0SGFuZHdyaXRpbmdTYW1wbGVVcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtyZWZlcmVuY2VJbWFnZXMsIHNldFJlZmVyZW5jZUltYWdlc10gPSB1c2VTdGF0ZTxGaWxlW10+KFtdKTtcbiAgY29uc3QgW3JlZmVyZW5jZUltYWdlVXJscywgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtpbWFnZVRyYW5zZm9ybWF0aW9uLCBzZXRJbWFnZVRyYW5zZm9ybWF0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtpc1VwbG9hZGluZywgc2V0SXNVcGxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gUGhvdG8gYW5hbHlzaXMgc3RhdGVcbiAgY29uc3QgW3Bob3RvQW5hbHlzZXMsIHNldFBob3RvQW5hbHlzZXNdID0gdXNlU3RhdGU8UGhvdG9BbmFseXNpc1tdPihbXSk7XG4gIGNvbnN0IFtpc0FuYWx5emluZywgc2V0SXNBbmFseXppbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0FuYWx5c2lzTW9kYWwsIHNldFNob3dBbmFseXNpc01vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3BlbmRpbmdBbmFseXNpc0luZGV4LCBzZXRQZW5kaW5nQW5hbHlzaXNJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAvLyBGaWxlIHVwbG9hZCBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUZpbGVVcGxvYWQgPSB1c2VDYWxsYmFjayhhc3luYyAoZmlsZTogRmlsZSwgdHlwZTogJ2hhbmR3cml0aW5nJyB8ICdyZWZlcmVuY2UnKSA9PiB7XG4gICAgaWYgKCFmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIHVwbG9hZCBhbiBpbWFnZSBmaWxlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldElzVXBsb2FkaW5nKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L3VwbG9hZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihgVXBsb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGUgPT09ICdoYW5kd3JpdGluZycpIHtcbiAgICAgICAgc2V0SGFuZHdyaXRpbmdTYW1wbGUoZmlsZSk7XG4gICAgICAgIHNldEhhbmR3cml0aW5nU2FtcGxlVXJsKHJlc3VsdC51cmwpO1xuICAgICAgICB0b2FzdC5zdWNjZXNzKFwiSGFuZHdyaXRpbmcgc2FtcGxlIHVwbG9hZGVkIVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0ltYWdlSW5kZXggPSByZWZlcmVuY2VJbWFnZXMubGVuZ3RoO1xuICAgICAgICBzZXRSZWZlcmVuY2VJbWFnZXMocHJldiA9PiBbLi4ucHJldiwgZmlsZV0pO1xuICAgICAgICBzZXRSZWZlcmVuY2VJbWFnZVVybHMocHJldiA9PiBbLi4ucHJldiwgcmVzdWx0LnVybF0pO1xuICAgICAgICB0b2FzdC5zdWNjZXNzKGBSZWZlcmVuY2UgaW1hZ2UgdXBsb2FkZWQhICR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCArIDF9IHBob3RvJHtyZWZlcmVuY2VJbWFnZXMubGVuZ3RoICsgMSA+IDEgPyAncycgOiAnJ30gcmVhZHkgZm9yIGNoYXJhY3RlciBjcmVhdGlvbi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHRoZSBVUkwgYW5kIGluZGV4IGZvciBsYXRlciBhbmFseXNpc1xuICAgICAgICBjb25zdCBhbmFseXNpc0RhdGEgPSB7IHVybDogcmVzdWx0LnVybCwgaW5kZXg6IG5ld0ltYWdlSW5kZXggfTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF1dG8tYW5hbHl6ZSB0aGUgcGhvdG8gaW4gdGhlIGJhY2tncm91bmQgYWZ0ZXIgc3RhdGUgdXBkYXRlc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfpJYgQXV0by1hbmFseXppbmcgdXBsb2FkZWQgcGhvdG8uLi5cIik7XG4gICAgICAgICAgYW5hbHl6ZVBob3RvKGFuYWx5c2lzRGF0YS51cmwsIGFuYWx5c2lzRGF0YS5pbmRleCkudGhlbihhbmFseXNpc1Jlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoYW5hbHlzaXNSZXN1bHQgJiYgYW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGhvdG8gYW5hbHlzaXMgY29tcGxldGU6ICR7YW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnR9IHBlb3BsZSBkZXRlY3RlZGApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgcGhvdG8gYW5hbHlzaXMgd2l0aCBhbGwgcGVvcGxlIGluY2x1ZGVkXG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBbmFseXNpczogUGhvdG9BbmFseXNpcyA9IHtcbiAgICAgICAgICAgICAgICBpbWFnZVVybDogYW5hbHlzaXNEYXRhLnVybCxcbiAgICAgICAgICAgICAgICBpbWFnZUluZGV4OiBhbmFseXNpc0RhdGEuaW5kZXgsXG4gICAgICAgICAgICAgICAgYW5hbHlzaXNSZXN1bHQ6IGFuYWx5c2lzUmVzdWx0LFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkUGVvcGxlOiBhbmFseXNpc1Jlc3VsdC5wZW9wbGUubWFwKHBlcnNvbiA9PiAoe1xuICAgICAgICAgICAgICAgICAgLi4ucGVyc29uLFxuICAgICAgICAgICAgICAgICAgaW5jbHVkZUluQ2FyZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLCAvLyBObyBuYW1lIGJ5IGRlZmF1bHQsIHVzZXIgY2FuIGFkZCB2aWEgXCJDdXN0b21pemUgcGVvcGxlXCJcbiAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcFRvUmVjaXBpZW50OiAnJ1xuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRXZlcnlvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhjbHVkZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgICBhbmFseXplZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbmFseXNpc0ZhaWxlZDogZmFsc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGFuYWx5c2lzIHNpbGVudGx5XG4gICAgICAgICAgICAgIHNldFBob3RvQW5hbHlzZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QW5hbHlzZXMgPSBbLi4ucHJldl07XG4gICAgICAgICAgICAgICAgbmV3QW5hbHlzZXNbYW5hbHlzaXNEYXRhLmluZGV4XSA9IGRlZmF1bHRBbmFseXNpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3QW5hbHlzZXM7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU3VidGxlIG5vdGlmaWNhdGlvbiB0aGF0IGFuYWx5c2lzIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICAgIGlmIChhbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCAxIHBlcnNvbiBkZXRlY3RlZCBhbmQgcmVhZHkgZm9yIGNhcmQgY3JlYXRpb25cIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk7ggJHthbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudH0gcGVvcGxlIGRldGVjdGVkIGFuZCByZWFkeSBmb3IgY2FyZCBjcmVhdGlvbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuYWx5c2lzUmVzdWx0ICYmIGFuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCBObyBwZW9wbGUgZGV0ZWN0ZWQgaW4gcGhvdG8sIGJ1dCBpdCBjYW4gc3RpbGwgYmUgdXNlZCBmb3IgcmVmZXJlbmNlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLimqDvuI8gUGhvdG8gYW5hbHlzaXMgZmFpbGVkLCBidXQgcGhvdG8gY2FuIHN0aWxsIGJlIHVzZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBhdXRvLWFuYWx5emUgcGhvdG86XCIsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgZXJyb3IgdG9hc3QgLSBzaWxlbnQgZmFpbHVyZSBpcyBPSyBzaW5jZSBhbmFseXNpcyBpcyBvcHRpb25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDApOyAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgc3RhdGUgdXBkYXRlcyBhcmUgY29tcGxldGVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdG9hc3QuZXJyb3IoXCJVcGxvYWQgZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNVcGxvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUltYWdlcy5sZW5ndGhdKTtcblxuICBjb25zdCBoYW5kbGVSZW1vdmVSZWZlcmVuY2VJbWFnZSA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlZEltYWdlID0gcmVmZXJlbmNlSW1hZ2VzW2luZGV4XTtcbiAgICBjb25zdCByZW1vdmVkVXJsID0gcmVmZXJlbmNlSW1hZ2VVcmxzW2luZGV4XTtcbiAgICBcbiAgICBzZXRSZWZlcmVuY2VJbWFnZXMocHJldiA9PiBwcmV2LmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpKTtcbiAgICBzZXRSZWZlcmVuY2VJbWFnZVVybHMocHJldiA9PiBwcmV2LmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpKTtcbiAgICBcbiAgICAvLyBBbHNvIHJlbW92ZSBhc3NvY2lhdGVkIHBob3RvIGFuYWx5c2lzXG4gICAgc2V0UGhvdG9BbmFseXNlcyhwcmV2ID0+IHByZXYuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCkpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBERUJVRzogUmVmZXJlbmNlIGltYWdlIHJlbW92ZWQ6XCIsIHtcbiAgICAgIGZpbGVOYW1lOiByZW1vdmVkSW1hZ2U/Lm5hbWUsXG4gICAgICB1cmw6IHJlbW92ZWRVcmwsXG4gICAgICByZW1haW5pbmdJbWFnZXM6IHJlZmVyZW5jZUltYWdlcy5sZW5ndGggLSAxXG4gICAgfSk7XG4gICAgXG4gICAgdG9hc3Quc3VjY2VzcyhgUmVmZXJlbmNlIGltYWdlIHJlbW92ZWQhICR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCAtIDF9IHBob3RvJHtyZWZlcmVuY2VJbWFnZXMubGVuZ3RoIC0gMSAhPT0gMSA/ICdzJyA6ICcnfSByZW1haW5pbmcuYCk7XG4gIH0sIFtyZWZlcmVuY2VJbWFnZXMsIHJlZmVyZW5jZUltYWdlVXJsc10pO1xuXG4gIC8vIEFuYWx5emUgYSBwaG90byB1c2luZyBBSSB2aXNpb25cbiAgY29uc3QgYW5hbHl6ZVBob3RvID0gdXNlQ2FsbGJhY2soYXN5bmMgKGltYWdlVXJsOiBzdHJpbmcsIGltYWdlSW5kZXg6IG51bWJlcik6IFByb21pc2U8UGhvdG9BbmFseXNpc1Jlc3VsdCB8IG51bGw+ID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIvCfk7ggU3RhcnRpbmcgcGhvdG8gYW5hbHlzaXMgZm9yOlwiLCBpbWFnZVVybCk7XG4gICAgc2V0SXNBbmFseXppbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgaW1hZ2UgVVJMIGlzIGFic29sdXRlXG4gICAgICBsZXQgZnVsbEltYWdlVXJsID0gaW1hZ2VVcmw7XG4gICAgICBpZiAoaW1hZ2VVcmwuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIGZ1bGxJbWFnZVVybCA9IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59JHtpbWFnZVVybH1gO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coXCLwn5O4IFVzaW5nIGZ1bGwgaW1hZ2UgVVJMOlwiLCBmdWxsSW1hZ2VVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCBhbmFseXNpc1Byb21wdCA9IGBBbmFseXplIHRoaXMgcGhvdG8gYW5kIHByb3ZpZGUgYSBkZXRhaWxlZCBKU09OIHJlc3BvbnNlIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG57XG4gIFwicGVvcGxlQ291bnRcIjogPG51bWJlciBvZiBwZW9wbGUgaW4gcGhvdG8+LFxuICBcInBlb3BsZVwiOiBbXG4gICAge1xuICAgICAgXCJpZFwiOiBcInBlcnNvbi0xXCIsXG4gICAgICBcInBvc2l0aW9uXCI6IDxvbmUgb2Y6IFwiZmFyLWxlZnRcIiwgXCJsZWZ0XCIsIFwiY2VudGVyLWxlZnRcIiwgXCJjZW50ZXJcIiwgXCJjZW50ZXItcmlnaHRcIiwgXCJyaWdodFwiLCBcImZhci1yaWdodFwiPixcbiAgICAgIFwicG9zaXRpb25EZXNjcmlwdGlvblwiOiA8bmF0dXJhbCBkZXNjcmlwdGlvbiBsaWtlIFwicGVyc29uIG9uIHRoZSBmYXIgbGVmdCB3ZWFyaW5nIGJsdWVcIj4sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IDxvdmVyYWxsIGFwcGVhcmFuY2UgZGVzY3JpcHRpb24+LFxuICAgICAgXCJhcHBhcmVudEFnZVwiOiA8YWdlIHJhbmdlIGxpa2UgXCIyMC0yNVwiIG9yIFwiNDBzXCI+LFxuICAgICAgXCJnZW5kZXJcIjogPGFwcGFyZW50IGdlbmRlciBpZiBpZGVudGlmaWFibGU+LFxuICAgICAgXCJoYWlyQ29sb3JcIjogPGhhaXIgY29sb3I+LFxuICAgICAgXCJoYWlyU3R5bGVcIjogPGhhaXIgc3R5bGUvbGVuZ3RoPixcbiAgICAgIFwiZGlzdGluZ3Vpc2hpbmdGZWF0dXJlc1wiOiA8bm90YWJsZSBmZWF0dXJlcyBsaWtlIGdsYXNzZXMsIGJlYXJkLCBldGMuPixcbiAgICAgIFwiY2xvdGhpbmdcIjogPHdoYXQgdGhleSdyZSB3ZWFyaW5nPixcbiAgICAgIFwiZXhwcmVzc2lvblwiOiA8ZmFjaWFsIGV4cHJlc3Npb24vbW9vZD5cbiAgICB9XG4gIF0sXG4gIFwiaGFzUGV0c1wiOiA8Ym9vbGVhbj4sXG4gIFwicGV0RGVzY3JpcHRpb25cIjogPGRlc2NyaXB0aW9uIG9mIHBldHMgaWYgcHJlc2VudD4sXG4gIFwiYmFja2dyb3VuZERlc2NyaXB0aW9uXCI6IDxkZXNjcmlwdGlvbiBvZiB0aGUgYmFja2dyb3VuZC9lbnZpcm9ubWVudD4sXG4gIFwic2V0dGluZ1wiOiA8dHlwZSBvZiBzZXR0aW5nIGxpa2UgXCJvdXRkb29yIHBhcmtcIiwgXCJiZWFjaFwiLCBcImluZG9vclwiLCBldGMuPixcbiAgXCJvdmVyYWxsTW9vZFwiOiA8b3ZlcmFsbCBtb29kL2F0bW9zcGhlcmUgb2YgdGhlIHBob3RvPixcbiAgXCJsaWdodGluZ1wiOiA8bGlnaHRpbmcgY29uZGl0aW9ucz5cbn1cblxuRm9yIGVhY2ggcGVyc29uOlxuMS4gRGVzY3JpYmUgdGhlaXIgcG9zaXRpb24gaW4gdGhlIGltYWdlIHVzaW5nIHRoZSBlbnVtIHZhbHVlc1xuMi4gUHJvdmlkZSBhIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZWlyIGFwcGVhcmFuY2UgIFxuMy4gRXN0aW1hdGUgdGhlaXIgYXBwYXJlbnQgYWdlIHJhbmdlXG40LiBOb3RlIHRoZWlyIGhhaXIgY29sb3IgYW5kIHN0eWxlXG41LiBEZXNjcmliZSB0aGVpciBjbG90aGluZ1xuNi4gTm90ZSBhbnkgZGlzdGluZ3Vpc2hpbmcgZmVhdHVyZXNcbjcuIERlc2NyaWJlIHRoZWlyIGV4cHJlc3Npb24vbW9vZFxuXG5SZXR1cm4gT05MWSB0aGUgSlNPTiByZXNwb25zZSwgbm8gYWRkaXRpb25hbCB0ZXh0LmA7XG5cbiAgICAgIC8vIFVzZSB0aGUgYW5hbHl6ZV9pbWFnZXMgdG9vbCB0aHJvdWdoIHRoZSBNQ1Agc2VydmljZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2ludGVybmFsL2NhbGxfbWNwX3Rvb2wnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHRvb2xfbmFtZTogJ2FuYWx5emVfaW1hZ2VzJyxcbiAgICAgICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgICAgIHVybHM6IFtmdWxsSW1hZ2VVcmxdLFxuICAgICAgICAgICAgYW5hbHlzaXNfcHJvbXB0OiBhbmFseXNpc1Byb21wdFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcImFuYWx5emVfaW1hZ2VzIGVycm9yIHJlc3BvbnNlOlwiLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+kliBhbmFseXplX2ltYWdlcyByZXNwb25zZSBkYXRhOlwiLCBkYXRhKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuZXJyb3IgJiYgZGF0YS5lcnJvciAhPT0gXCJOb25lXCIgJiYgZGF0YS5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGRhdGEucmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXN1bHQgPSB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiByZXNwb25zZSBmcm9tIE1DUCcgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZGF0YS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgdGhlIGFuYWx5c2lzIGZyb20gdGhlIHJlc3VsdHMgYXJyYXlcbiAgICAgIGlmIChyZXN1bHQucmVzdWx0cyAmJiByZXN1bHQucmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gcmVzdWx0LnJlc3VsdHNbMF07XG4gICAgICAgIGlmIChpbWFnZVJlc3VsdC5zdGF0dXMgPT09ICdzdWNjZXNzJyAmJiBpbWFnZVJlc3VsdC5hbmFseXNpcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCBSYXcgYW5hbHlzaXMgdGV4dDpcIiwgaW1hZ2VSZXN1bHQuYW5hbHlzaXMpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgYW5hbHlzaXMgYXMgSlNPTlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IEpTT04gZnJvbSB0aGUgYW5hbHlzaXMgdGV4dFxuICAgICAgICAgICAgbGV0IGpzb25UZXh0ID0gaW1hZ2VSZXN1bHQuYW5hbHlzaXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXNwb25zZSBjb250YWlucyBtYXJrZG93biBjb2RlIGJsb2NrcywgZXh0cmFjdCB0aGUgSlNPTlxuICAgICAgICAgICAgY29uc3QganNvbk1hdGNoID0ganNvblRleHQubWF0Y2goL2BgYGpzb25cXHMqKFtcXHNcXFNdKj8pXFxzKmBgYC8pO1xuICAgICAgICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICAgICAgICBqc29uVGV4dCA9IGpzb25NYXRjaFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIEpTT05cbiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzRGF0YSA9IEpTT04ucGFyc2UoanNvblRleHQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5O4IFBhcnNlZCBhbmFseXNpcyBkYXRhOlwiLCBhbmFseXNpc0RhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGRhdGEgbWF0Y2hlcyBvdXIgZXhwZWN0ZWQgc3RydWN0dXJlXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuYWx5c2lzRGF0YS5wZW9wbGVDb3VudCA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhbmFseXNpc0RhdGEucGVvcGxlKSkge1xuICAgICAgICAgICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBhbmFseXNpc0RhdGEgYXMgUGhvdG9BbmFseXNpc1Jlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbmFseXNpcyBkYXRhIGRvZXNuJ3QgbWF0Y2ggZXhwZWN0ZWQgc3RydWN0dXJlXCIpO1xuICAgICAgICAgICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgYW5hbHlzaXMgYXMgSlNPTjpcIiwgcGFyc2VFcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUmF3IGFuYWx5c2lzOlwiLCBpbWFnZVJlc3VsdC5hbmFseXNpcyk7XG4gICAgICAgICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkltYWdlIGFuYWx5c2lzIGZhaWxlZDpcIiwgaW1hZ2VSZXN1bHQubWVzc2FnZSk7XG4gICAgICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gcmVzdWx0cyByZXR1cm5lZCBmcm9tIGFuYWx5emVfaW1hZ2VzXCIpO1xuICAgICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gYW5hbHl6ZSBwaG90bzpcIiwgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoXCJGYWlsZWQgdG8gYW5hbHl6ZSBwaG90by4gWW91IGNhbiBzdGlsbCB1c2UgaXQgd2l0aG91dCBhbmFseXNpcy5cIik7XG4gICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHBob3RvIGFuYWx5c2lzIHJlc3VsdHNcbiAgY29uc3Qgc2F2ZVBob3RvQW5hbHlzaXMgPSB1c2VDYWxsYmFjaygoYW5hbHlzaXM6IFBob3RvQW5hbHlzaXMpID0+IHtcbiAgICBzZXRQaG90b0FuYWx5c2VzKHByZXYgPT4ge1xuICAgICAgY29uc3QgbmV3QW5hbHlzZXMgPSBbLi4ucHJldl07XG4gICAgICBuZXdBbmFseXNlc1thbmFseXNpcy5pbWFnZUluZGV4XSA9IGFuYWx5c2lzO1xuICAgICAgcmV0dXJuIG5ld0FuYWx5c2VzO1xuICAgIH0pO1xuICAgIHNldFNob3dBbmFseXNpc01vZGFsKGZhbHNlKTtcbiAgICBzZXRQZW5kaW5nQW5hbHlzaXNJbmRleChudWxsKTtcbiAgfSwgW10pO1xuXG4gIC8vIFNraXAgcGhvdG8gYW5hbHlzaXNcbiAgY29uc3Qgc2tpcFBob3RvQW5hbHlzaXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHBlbmRpbmdBbmFseXNpc0luZGV4ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBza2lwcGVkQW5hbHlzaXM6IFBob3RvQW5hbHlzaXMgPSB7XG4gICAgICAgIGltYWdlVXJsOiByZWZlcmVuY2VJbWFnZVVybHNbcGVuZGluZ0FuYWx5c2lzSW5kZXhdLFxuICAgICAgICBpbWFnZUluZGV4OiBwZW5kaW5nQW5hbHlzaXNJbmRleCxcbiAgICAgICAgYW5hbHlzaXNSZXN1bHQ6IHtcbiAgICAgICAgICBwZW9wbGVDb3VudDogMCxcbiAgICAgICAgICBwZW9wbGU6IFtdLFxuICAgICAgICAgIGhhc1BldHM6IGZhbHNlLFxuICAgICAgICAgIGJhY2tncm91bmREZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgICBzZXR0aW5nOiBcIlwiLFxuICAgICAgICAgIG92ZXJhbGxNb29kOiBcIlwiLFxuICAgICAgICAgIGxpZ2h0aW5nOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkUGVvcGxlOiBbXSxcbiAgICAgICAgaW5jbHVkZUV2ZXJ5b25lOiB0cnVlLFxuICAgICAgICBleGNsdWRlZENvdW50OiAwLFxuICAgICAgICBhbmFseXplZDogZmFsc2UsXG4gICAgICAgIGFuYWx5c2lzRmFpbGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHNhdmVQaG90b0FuYWx5c2lzKHNraXBwZWRBbmFseXNpcyk7XG4gICAgfVxuICAgIHNldFNob3dBbmFseXNpc01vZGFsKGZhbHNlKTtcbiAgICBzZXRQZW5kaW5nQW5hbHlzaXNJbmRleChudWxsKTtcbiAgfSwgW3BlbmRpbmdBbmFseXNpc0luZGV4LCByZWZlcmVuY2VJbWFnZVVybHMsIHNhdmVQaG90b0FuYWx5c2lzXSk7XG5cbiAgLy8gR2V0IGNvbWJpbmVkIGFuYWx5c2lzIGZvciBhbGwgcGhvdG9zXG4gIGNvbnN0IGdldENvbWJpbmVkUGhvdG9BbmFseXNpcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBhbmFseXplZFBob3RvcyA9IHBob3RvQW5hbHlzZXMuZmlsdGVyKGEgPT4gYS5hbmFseXplZCAmJiAhYS5hbmFseXNpc0ZhaWxlZCk7XG4gICAgaWYgKGFuYWx5emVkUGhvdG9zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBhbGxTZWxlY3RlZFBlb3BsZSA9IGFuYWx5emVkUGhvdG9zLmZsYXRNYXAoYSA9PiBhLnNlbGVjdGVkUGVvcGxlKTtcbiAgICBjb25zdCB0b3RhbFBlb3BsZUNvdW50ID0gYW5hbHl6ZWRQaG90b3MucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEuYW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnQsIDApO1xuICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWRDb3VudCA9IGFsbFNlbGVjdGVkUGVvcGxlLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbEV4Y2x1ZGVkQ291bnQgPSB0b3RhbFBlb3BsZUNvdW50IC0gdG90YWxTZWxlY3RlZENvdW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuYWx5emVkUGhvdG9zLFxuICAgICAgYWxsU2VsZWN0ZWRQZW9wbGUsXG4gICAgICB0b3RhbFBlb3BsZUNvdW50LFxuICAgICAgdG90YWxTZWxlY3RlZENvdW50LFxuICAgICAgdG90YWxFeGNsdWRlZENvdW50LFxuICAgICAgaGFzTXVsdGlwbGVQaG90b3M6IGFuYWx5emVkUGhvdG9zLmxlbmd0aCA+IDFcbiAgICB9O1xuICB9LCBbcGhvdG9BbmFseXNlc10pO1xuXG4gIC8vIE1hbnVhbGx5IHRyaWdnZXIgcGhvdG8gYW5hbHlzaXMgZm9yIGEgc3BlY2lmaWMgaW1hZ2VcbiAgY29uc3QgdHJpZ2dlclBob3RvQW5hbHlzaXMgPSB1c2VDYWxsYmFjaygoaW1hZ2VJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGltYWdlSW5kZXggPj0gMCAmJiBpbWFnZUluZGV4IDwgcmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCkge1xuICAgICAgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXgoaW1hZ2VJbmRleCk7XG4gICAgICBzZXRTaG93QW5hbHlzaXNNb2RhbCh0cnVlKTtcbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kd3JpdGluZ1NhbXBsZSxcbiAgICBzZXRIYW5kd3JpdGluZ1NhbXBsZSxcbiAgICBoYW5kd3JpdGluZ1NhbXBsZVVybCxcbiAgICBzZXRIYW5kd3JpdGluZ1NhbXBsZVVybCxcbiAgICByZWZlcmVuY2VJbWFnZXMsXG4gICAgc2V0UmVmZXJlbmNlSW1hZ2VzLFxuICAgIHJlZmVyZW5jZUltYWdlVXJscyxcbiAgICBzZXRSZWZlcmVuY2VJbWFnZVVybHMsXG4gICAgaW1hZ2VUcmFuc2Zvcm1hdGlvbixcbiAgICBzZXRJbWFnZVRyYW5zZm9ybWF0aW9uLFxuICAgIGlzVXBsb2FkaW5nLFxuICAgIHNldElzVXBsb2FkaW5nLFxuICAgIGhhbmRsZUZpbGVVcGxvYWQsXG4gICAgaGFuZGxlUmVtb3ZlUmVmZXJlbmNlSW1hZ2UsXG4gICAgLy8gUGhvdG8gYW5hbHlzaXNcbiAgICBwaG90b0FuYWx5c2VzLFxuICAgIHNldFBob3RvQW5hbHlzZXMsXG4gICAgaXNBbmFseXppbmcsXG4gICAgc2hvd0FuYWx5c2lzTW9kYWwsXG4gICAgc2V0U2hvd0FuYWx5c2lzTW9kYWwsXG4gICAgcGVuZGluZ0FuYWx5c2lzSW5kZXgsXG4gICAgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXgsXG4gICAgYW5hbHl6ZVBob3RvLFxuICAgIHNhdmVQaG90b0FuYWx5c2lzLFxuICAgIHNraXBQaG90b0FuYWx5c2lzLFxuICAgIGdldENvbWJpbmVkUGhvdG9BbmFseXNpcyxcbiAgICB0cmlnZ2VyUGhvdG9BbmFseXNpc1xuICB9O1xufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidG9hc3QiLCJCQUNLRU5EX0FQSV9CQVNFX1VSTCIsInVzZUZpbGVIYW5kbGluZyIsImhhbmR3cml0aW5nU2FtcGxlIiwic2V0SGFuZHdyaXRpbmdTYW1wbGUiLCJoYW5kd3JpdGluZ1NhbXBsZVVybCIsInNldEhhbmR3cml0aW5nU2FtcGxlVXJsIiwicmVmZXJlbmNlSW1hZ2VzIiwic2V0UmVmZXJlbmNlSW1hZ2VzIiwicmVmZXJlbmNlSW1hZ2VVcmxzIiwic2V0UmVmZXJlbmNlSW1hZ2VVcmxzIiwiaW1hZ2VUcmFuc2Zvcm1hdGlvbiIsInNldEltYWdlVHJhbnNmb3JtYXRpb24iLCJpc1VwbG9hZGluZyIsInNldElzVXBsb2FkaW5nIiwicGhvdG9BbmFseXNlcyIsInNldFBob3RvQW5hbHlzZXMiLCJpc0FuYWx5emluZyIsInNldElzQW5hbHl6aW5nIiwic2hvd0FuYWx5c2lzTW9kYWwiLCJzZXRTaG93QW5hbHlzaXNNb2RhbCIsInBlbmRpbmdBbmFseXNpc0luZGV4Iiwic2V0UGVuZGluZ0FuYWx5c2lzSW5kZXgiLCJoYW5kbGVGaWxlVXBsb2FkIiwiZmlsZSIsInR5cGUiLCJzdGFydHNXaXRoIiwiZXJyb3IiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsInVybCIsInN1Y2Nlc3MiLCJuZXdJbWFnZUluZGV4IiwibGVuZ3RoIiwicHJldiIsImFuYWx5c2lzRGF0YSIsImluZGV4Iiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJhbmFseXplUGhvdG8iLCJ0aGVuIiwiYW5hbHlzaXNSZXN1bHQiLCJwZW9wbGVDb3VudCIsImRlZmF1bHRBbmFseXNpcyIsImltYWdlVXJsIiwiaW1hZ2VJbmRleCIsInNlbGVjdGVkUGVvcGxlIiwicGVvcGxlIiwibWFwIiwicGVyc29uIiwiaW5jbHVkZUluQ2FyZCIsIm5hbWUiLCJyZWxhdGlvbnNoaXBUb1JlY2lwaWVudCIsImluY2x1ZGVFdmVyeW9uZSIsImV4Y2x1ZGVkQ291bnQiLCJhbmFseXplZCIsImFuYWx5c2lzRmFpbGVkIiwibmV3QW5hbHlzZXMiLCJjYXRjaCIsImhhbmRsZVJlbW92ZVJlZmVyZW5jZUltYWdlIiwicmVtb3ZlZEltYWdlIiwicmVtb3ZlZFVybCIsImZpbHRlciIsIl8iLCJpIiwiZmlsZU5hbWUiLCJyZW1haW5pbmdJbWFnZXMiLCJmdWxsSW1hZ2VVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFuYWx5c2lzUHJvbXB0IiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b29sX25hbWUiLCJhcmd1bWVudHMiLCJ1cmxzIiwiYW5hbHlzaXNfcHJvbXB0IiwiZXJyb3JUZXh0IiwidGV4dCIsImRhdGEiLCJwYXJzZSIsIm1lc3NhZ2UiLCJyZXN1bHRzIiwiaW1hZ2VSZXN1bHQiLCJhbmFseXNpcyIsImpzb25UZXh0IiwianNvbk1hdGNoIiwibWF0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUVycm9yIiwic2F2ZVBob3RvQW5hbHlzaXMiLCJza2lwUGhvdG9BbmFseXNpcyIsInNraXBwZWRBbmFseXNpcyIsImhhc1BldHMiLCJiYWNrZ3JvdW5kRGVzY3JpcHRpb24iLCJzZXR0aW5nIiwib3ZlcmFsbE1vb2QiLCJsaWdodGluZyIsImdldENvbWJpbmVkUGhvdG9BbmFseXNpcyIsImFuYWx5emVkUGhvdG9zIiwiYSIsImFsbFNlbGVjdGVkUGVvcGxlIiwiZmxhdE1hcCIsInRvdGFsUGVvcGxlQ291bnQiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbFNlbGVjdGVkQ291bnQiLCJ0b3RhbEV4Y2x1ZGVkQ291bnQiLCJoYXNNdWx0aXBsZVBob3RvcyIsInRyaWdnZXJQaG90b0FuYWx5c2lzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts\n"));

/***/ })

});
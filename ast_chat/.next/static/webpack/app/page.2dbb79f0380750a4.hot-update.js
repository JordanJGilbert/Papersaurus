"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/previewExtractors.ts":
/*!************************************!*\
  !*** ./utils/previewExtractors.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractCodeDiffPreview: function() { return /* binding */ extractCodeDiffPreview; },\n/* harmony export */   extractCodePreview: function() { return /* binding */ extractCodePreview; },\n/* harmony export */   extractPreviewFromToolCall: function() { return /* binding */ extractPreviewFromToolCall; },\n/* harmony export */   extractWebAppPreview: function() { return /* binding */ extractWebAppPreview; },\n/* harmony export */   shouldExtractPreview: function() { return /* binding */ shouldExtractPreview; }\n/* harmony export */ });\n// Extract web app preview data from create_web_app or edit_web_app tool calls\nconst extractWebAppPreview = (toolCall)=>{\n    if (![\n        \"create_web_app\",\n        \"edit_web_app\"\n    ].includes(toolCall.name)) {\n        return null;\n    }\n    if (!toolCall.result || toolCall.is_error || toolCall.is_partial) {\n        return null;\n    }\n    try {\n        const result = JSON.parse(toolCall.result);\n        if (result.status === \"success\" && result.url) {\n            // Extract app name from arguments\n            let appName = \"Web Application\";\n            try {\n                const args = JSON.parse(toolCall.arguments);\n                appName = args.app_name || appName;\n            } catch (e) {\n                console.warn(\"Failed to parse tool arguments for app name:\", e);\n            }\n            // Use app name as the unique ID for persistence\n            const id = appName.replace(/[^a-zA-Z0-9_-]/g, \"_\").toLowerCase();\n            // Check if this is an edit with diff data\n            if (toolCall.name === \"edit_web_app\" && result.original_html && result.modified_html) {\n                return {\n                    id: \"\".concat(id, \"_diff\"),\n                    type: \"diff\",\n                    data: {\n                        original: result.original_html,\n                        modified: result.modified_html,\n                        filename: \"\".concat(appName, \".html\"),\n                        language: \"html\",\n                        url: result.url,\n                        appName,\n                        status: result.status,\n                        message: result.message,\n                        backup_created: result.backup_created\n                    },\n                    shouldShow: true\n                };\n            }\n            // Regular web app preview (create or edit without diff data)\n            return {\n                id,\n                type: \"web_app\",\n                data: {\n                    url: result.url,\n                    appName,\n                    status: result.status,\n                    message: result.message,\n                    backup_created: result.backup_created\n                },\n                shouldShow: true\n            };\n        }\n    } catch (e) {\n        console.warn(\"Failed to parse web app tool result:\", e);\n    }\n    return null;\n};\n// Extract code diff preview from edit_mcp_server tool calls\nconst extractCodeDiffPreview = (toolCall)=>{\n    if (toolCall.name !== \"edit_mcp_server\") {\n        return null;\n    }\n    if (!toolCall.result || toolCall.is_error || toolCall.is_partial) {\n        return null;\n    }\n    try {\n        const result = JSON.parse(toolCall.result);\n        if (result.original_code && result.modified_code) {\n            const serverName = result.server_name || \"unknown_server\";\n            const id = \"mcp_server_\".concat(serverName);\n            return {\n                id,\n                type: \"diff\",\n                data: {\n                    original: result.original_code,\n                    modified: result.modified_code,\n                    filename: \"\".concat(serverName, \".py\"),\n                    language: \"python\",\n                    serverName,\n                    status: result.status,\n                    message: result.message,\n                    changesApplied: result.changes_applied,\n                    reloadResult: result.reload_result\n                },\n                shouldShow: true\n            };\n        }\n    } catch (e) {\n        console.warn(\"Failed to parse edit_mcp_server tool result:\", e);\n    }\n    return null;\n};\n// Extract code preview from other code-related tool calls\nconst extractCodePreview = (toolCall)=>{\n    // Add more code extraction logic here for other tools that generate code\n    // For now, this is a placeholder for future expansion\n    return null;\n};\n// Main function to extract any preview from a tool call\nconst extractPreviewFromToolCall = (toolCall)=>{\n    // Try each extractor in order\n    const extractors = [\n        extractWebAppPreview,\n        extractCodeDiffPreview,\n        extractCodePreview\n    ];\n    for (const extractor of extractors){\n        const preview = extractor(toolCall);\n        if (preview) {\n            return preview;\n        }\n    }\n    return null;\n};\n// Helper to determine if a tool call should trigger preview extraction\nconst shouldExtractPreview = (toolCall)=>{\n    const previewToolNames = [\n        \"create_web_app\",\n        \"edit_web_app\",\n        \"edit_mcp_server\"\n    ];\n    return previewToolNames.includes(toolCall.name) && !toolCall.is_error && !toolCall.is_partial && toolCall.status === \"Completed\";\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3ByZXZpZXdFeHRyYWN0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBaUJBLDhFQUE4RTtBQUN2RSxNQUFNQSx1QkFBdUIsQ0FBQ0M7SUFDbkMsSUFBSSxDQUFDO1FBQUM7UUFBa0I7S0FBZSxDQUFDQyxRQUFRLENBQUNELFNBQVNFLElBQUksR0FBRztRQUMvRCxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNGLFNBQVNHLE1BQU0sSUFBSUgsU0FBU0ksUUFBUSxJQUFJSixTQUFTSyxVQUFVLEVBQUU7UUFDaEUsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGLE1BQU1GLFNBQVNHLEtBQUtDLEtBQUssQ0FBQ1AsU0FBU0csTUFBTTtRQUV6QyxJQUFJQSxPQUFPSyxNQUFNLEtBQUssYUFBYUwsT0FBT00sR0FBRyxFQUFFO1lBQzdDLGtDQUFrQztZQUNsQyxJQUFJQyxVQUFVO1lBQ2QsSUFBSTtnQkFDRixNQUFNQyxPQUFPTCxLQUFLQyxLQUFLLENBQUNQLFNBQVNZLFNBQVM7Z0JBQzFDRixVQUFVQyxLQUFLRSxRQUFRLElBQUlIO1lBQzdCLEVBQUUsT0FBT0ksR0FBRztnQkFDVkMsUUFBUUMsSUFBSSxDQUFDLGdEQUFnREY7WUFDL0Q7WUFFQSxnREFBZ0Q7WUFDaEQsTUFBTUcsS0FBS1AsUUFBUVEsT0FBTyxDQUFDLG1CQUFtQixLQUFLQyxXQUFXO1lBRTlELDBDQUEwQztZQUMxQyxJQUFJbkIsU0FBU0UsSUFBSSxLQUFLLGtCQUFrQkMsT0FBT2lCLGFBQWEsSUFBSWpCLE9BQU9rQixhQUFhLEVBQUU7Z0JBQ3BGLE9BQU87b0JBQ0xKLElBQUksR0FBTSxPQUFIQSxJQUFHO29CQUNWSyxNQUFNO29CQUNOQyxNQUFNO3dCQUNKQyxVQUFVckIsT0FBT2lCLGFBQWE7d0JBQzlCSyxVQUFVdEIsT0FBT2tCLGFBQWE7d0JBQzlCSyxVQUFVLEdBQVcsT0FBUmhCLFNBQVE7d0JBQ3JCaUIsVUFBVTt3QkFDVmxCLEtBQUtOLE9BQU9NLEdBQUc7d0JBQ2ZDO3dCQUNBRixRQUFRTCxPQUFPSyxNQUFNO3dCQUNyQm9CLFNBQVN6QixPQUFPeUIsT0FBTzt3QkFDdkJDLGdCQUFnQjFCLE9BQU8wQixjQUFjO29CQUN2QztvQkFDQUMsWUFBWTtnQkFDZDtZQUNGO1lBRUEsNkRBQTZEO1lBQzdELE9BQU87Z0JBQ0xiO2dCQUNBSyxNQUFNO2dCQUNOQyxNQUFNO29CQUNKZCxLQUFLTixPQUFPTSxHQUFHO29CQUNmQztvQkFDQUYsUUFBUUwsT0FBT0ssTUFBTTtvQkFDckJvQixTQUFTekIsT0FBT3lCLE9BQU87b0JBQ3ZCQyxnQkFBZ0IxQixPQUFPMEIsY0FBYztnQkFDdkM7Z0JBQ0FDLFlBQVk7WUFDZDtRQUNGO0lBQ0YsRUFBRSxPQUFPaEIsR0FBRztRQUNWQyxRQUFRQyxJQUFJLENBQUMsd0NBQXdDRjtJQUN2RDtJQUVBLE9BQU87QUFDVCxFQUFFO0FBRUYsNERBQTREO0FBQ3JELE1BQU1pQix5QkFBeUIsQ0FBQy9CO0lBQ3JDLElBQUlBLFNBQVNFLElBQUksS0FBSyxtQkFBbUI7UUFDdkMsT0FBTztJQUNUO0lBRUEsSUFBSSxDQUFDRixTQUFTRyxNQUFNLElBQUlILFNBQVNJLFFBQVEsSUFBSUosU0FBU0ssVUFBVSxFQUFFO1FBQ2hFLE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixNQUFNRixTQUFTRyxLQUFLQyxLQUFLLENBQUNQLFNBQVNHLE1BQU07UUFFekMsSUFBSUEsT0FBTzZCLGFBQWEsSUFBSTdCLE9BQU84QixhQUFhLEVBQUU7WUFDaEQsTUFBTUMsYUFBYS9CLE9BQU9nQyxXQUFXLElBQUk7WUFDekMsTUFBTWxCLEtBQUssY0FBeUIsT0FBWGlCO1lBRXpCLE9BQU87Z0JBQ0xqQjtnQkFDQUssTUFBTTtnQkFDTkMsTUFBTTtvQkFDSkMsVUFBVXJCLE9BQU82QixhQUFhO29CQUM5QlAsVUFBVXRCLE9BQU84QixhQUFhO29CQUM5QlAsVUFBVSxHQUFjLE9BQVhRLFlBQVc7b0JBQ3hCUCxVQUFVO29CQUNWTztvQkFDQTFCLFFBQVFMLE9BQU9LLE1BQU07b0JBQ3JCb0IsU0FBU3pCLE9BQU95QixPQUFPO29CQUN2QlEsZ0JBQWdCakMsT0FBT2tDLGVBQWU7b0JBQ3RDQyxjQUFjbkMsT0FBT29DLGFBQWE7Z0JBQ3BDO2dCQUNBVCxZQUFZO1lBQ2Q7UUFDRjtJQUNGLEVBQUUsT0FBT2hCLEdBQUc7UUFDVkMsUUFBUUMsSUFBSSxDQUFDLGdEQUFnREY7SUFDL0Q7SUFFQSxPQUFPO0FBQ1QsRUFBRTtBQUVGLDBEQUEwRDtBQUNuRCxNQUFNMEIscUJBQXFCLENBQUN4QztJQUNqQyx5RUFBeUU7SUFDekUsc0RBQXNEO0lBRXRELE9BQU87QUFDVCxFQUFFO0FBRUYsd0RBQXdEO0FBQ2pELE1BQU15Qyw2QkFBNkIsQ0FBQ3pDO0lBQ3pDLDhCQUE4QjtJQUM5QixNQUFNMEMsYUFBYTtRQUNqQjNDO1FBQ0FnQztRQUNBUztLQUNEO0lBRUQsS0FBSyxNQUFNRyxhQUFhRCxXQUFZO1FBQ2xDLE1BQU1FLFVBQVVELFVBQVUzQztRQUMxQixJQUFJNEMsU0FBUztZQUNYLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCxFQUFFO0FBRUYsdUVBQXVFO0FBQ2hFLE1BQU1DLHVCQUF1QixDQUFDN0M7SUFDbkMsTUFBTThDLG1CQUFtQjtRQUN2QjtRQUNBO1FBQ0E7S0FFRDtJQUVELE9BQU9BLGlCQUFpQjdDLFFBQVEsQ0FBQ0QsU0FBU0UsSUFBSSxLQUN2QyxDQUFDRixTQUFTSSxRQUFRLElBQ2xCLENBQUNKLFNBQVNLLFVBQVUsSUFDcEJMLFNBQVNRLE1BQU0sS0FBSztBQUM3QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3ByZXZpZXdFeHRyYWN0b3JzLnRzPzY2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFRvb2xDYWxsRGF0YSB7XG4gIGNhbGxfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhcmd1bWVudHM6IHN0cmluZztcbiAgcmVzdWx0Pzogc3RyaW5nO1xuICBzdGF0dXM/OiBcIlBlbmRpbmcuLi5cIiB8IFwiQ29tcGxldGVkXCIgfCBcIkVycm9yXCIgfCBcIlN0cmVhbWluZy4uLlwiO1xuICBpc19lcnJvcj86IGJvb2xlYW47XG4gIGlzX3BhcnRpYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZFByZXZpZXcge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiAnd2ViX2FwcCcgfCAnY29kZScgfCAnZGlmZic7XG4gIGRhdGE6IGFueTtcbiAgc2hvdWxkU2hvdzogYm9vbGVhbjtcbn1cblxuLy8gRXh0cmFjdCB3ZWIgYXBwIHByZXZpZXcgZGF0YSBmcm9tIGNyZWF0ZV93ZWJfYXBwIG9yIGVkaXRfd2ViX2FwcCB0b29sIGNhbGxzXG5leHBvcnQgY29uc3QgZXh0cmFjdFdlYkFwcFByZXZpZXcgPSAodG9vbENhbGw6IFRvb2xDYWxsRGF0YSk6IEV4dHJhY3RlZFByZXZpZXcgfCBudWxsID0+IHtcbiAgaWYgKCFbJ2NyZWF0ZV93ZWJfYXBwJywgJ2VkaXRfd2ViX2FwcCddLmluY2x1ZGVzKHRvb2xDYWxsLm5hbWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXRvb2xDYWxsLnJlc3VsdCB8fCB0b29sQ2FsbC5pc19lcnJvciB8fCB0b29sQ2FsbC5pc19wYXJ0aWFsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodG9vbENhbGwucmVzdWx0KTtcbiAgICBcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHJlc3VsdC51cmwpIHtcbiAgICAgIC8vIEV4dHJhY3QgYXBwIG5hbWUgZnJvbSBhcmd1bWVudHNcbiAgICAgIGxldCBhcHBOYW1lID0gJ1dlYiBBcHBsaWNhdGlvbic7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcmdzID0gSlNPTi5wYXJzZSh0b29sQ2FsbC5hcmd1bWVudHMpO1xuICAgICAgICBhcHBOYW1lID0gYXJncy5hcHBfbmFtZSB8fCBhcHBOYW1lO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSB0b29sIGFyZ3VtZW50cyBmb3IgYXBwIG5hbWU6JywgZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhcHAgbmFtZSBhcyB0aGUgdW5pcXVlIElEIGZvciBwZXJzaXN0ZW5jZVxuICAgICAgY29uc3QgaWQgPSBhcHBOYW1lLnJlcGxhY2UoL1teYS16QS1aMC05Xy1dL2csICdfJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBlZGl0IHdpdGggZGlmZiBkYXRhXG4gICAgICBpZiAodG9vbENhbGwubmFtZSA9PT0gJ2VkaXRfd2ViX2FwcCcgJiYgcmVzdWx0Lm9yaWdpbmFsX2h0bWwgJiYgcmVzdWx0Lm1vZGlmaWVkX2h0bWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogYCR7aWR9X2RpZmZgLFxuICAgICAgICAgIHR5cGU6ICdkaWZmJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBvcmlnaW5hbDogcmVzdWx0Lm9yaWdpbmFsX2h0bWwsXG4gICAgICAgICAgICBtb2RpZmllZDogcmVzdWx0Lm1vZGlmaWVkX2h0bWwsXG4gICAgICAgICAgICBmaWxlbmFtZTogYCR7YXBwTmFtZX0uaHRtbGAsXG4gICAgICAgICAgICBsYW5ndWFnZTogJ2h0bWwnLFxuICAgICAgICAgICAgdXJsOiByZXN1bHQudXJsLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlLFxuICAgICAgICAgICAgYmFja3VwX2NyZWF0ZWQ6IHJlc3VsdC5iYWNrdXBfY3JlYXRlZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3VsZFNob3c6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ3VsYXIgd2ViIGFwcCBwcmV2aWV3IChjcmVhdGUgb3IgZWRpdCB3aXRob3V0IGRpZmYgZGF0YSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlOiAnd2ViX2FwcCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1cmw6IHJlc3VsdC51cmwsXG4gICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgYmFja3VwX2NyZWF0ZWQ6IHJlc3VsdC5iYWNrdXBfY3JlYXRlZCxcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkU2hvdzogdHJ1ZSxcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugd2ViIGFwcCB0b29sIHJlc3VsdDonLCBlKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gRXh0cmFjdCBjb2RlIGRpZmYgcHJldmlldyBmcm9tIGVkaXRfbWNwX3NlcnZlciB0b29sIGNhbGxzXG5leHBvcnQgY29uc3QgZXh0cmFjdENvZGVEaWZmUHJldmlldyA9ICh0b29sQ2FsbDogVG9vbENhbGxEYXRhKTogRXh0cmFjdGVkUHJldmlldyB8IG51bGwgPT4ge1xuICBpZiAodG9vbENhbGwubmFtZSAhPT0gJ2VkaXRfbWNwX3NlcnZlcicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdG9vbENhbGwucmVzdWx0IHx8IHRvb2xDYWxsLmlzX2Vycm9yIHx8IHRvb2xDYWxsLmlzX3BhcnRpYWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0b29sQ2FsbC5yZXN1bHQpO1xuICAgIFxuICAgIGlmIChyZXN1bHQub3JpZ2luYWxfY29kZSAmJiByZXN1bHQubW9kaWZpZWRfY29kZSkge1xuICAgICAgY29uc3Qgc2VydmVyTmFtZSA9IHJlc3VsdC5zZXJ2ZXJfbmFtZSB8fCAndW5rbm93bl9zZXJ2ZXInO1xuICAgICAgY29uc3QgaWQgPSBgbWNwX3NlcnZlcl8ke3NlcnZlck5hbWV9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6ICdkaWZmJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIG9yaWdpbmFsOiByZXN1bHQub3JpZ2luYWxfY29kZSxcbiAgICAgICAgICBtb2RpZmllZDogcmVzdWx0Lm1vZGlmaWVkX2NvZGUsXG4gICAgICAgICAgZmlsZW5hbWU6IGAke3NlcnZlck5hbWV9LnB5YCxcbiAgICAgICAgICBsYW5ndWFnZTogJ3B5dGhvbicsXG4gICAgICAgICAgc2VydmVyTmFtZSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgY2hhbmdlc0FwcGxpZWQ6IHJlc3VsdC5jaGFuZ2VzX2FwcGxpZWQsXG4gICAgICAgICAgcmVsb2FkUmVzdWx0OiByZXN1bHQucmVsb2FkX3Jlc3VsdCxcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkU2hvdzogdHJ1ZSxcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZWRpdF9tY3Bfc2VydmVyIHRvb2wgcmVzdWx0OicsIGUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBFeHRyYWN0IGNvZGUgcHJldmlldyBmcm9tIG90aGVyIGNvZGUtcmVsYXRlZCB0b29sIGNhbGxzXG5leHBvcnQgY29uc3QgZXh0cmFjdENvZGVQcmV2aWV3ID0gKHRvb2xDYWxsOiBUb29sQ2FsbERhdGEpOiBFeHRyYWN0ZWRQcmV2aWV3IHwgbnVsbCA9PiB7XG4gIC8vIEFkZCBtb3JlIGNvZGUgZXh0cmFjdGlvbiBsb2dpYyBoZXJlIGZvciBvdGhlciB0b29scyB0aGF0IGdlbmVyYXRlIGNvZGVcbiAgLy8gRm9yIG5vdywgdGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBmdXR1cmUgZXhwYW5zaW9uXG4gIFxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIE1haW4gZnVuY3Rpb24gdG8gZXh0cmFjdCBhbnkgcHJldmlldyBmcm9tIGEgdG9vbCBjYWxsXG5leHBvcnQgY29uc3QgZXh0cmFjdFByZXZpZXdGcm9tVG9vbENhbGwgPSAodG9vbENhbGw6IFRvb2xDYWxsRGF0YSk6IEV4dHJhY3RlZFByZXZpZXcgfCBudWxsID0+IHtcbiAgLy8gVHJ5IGVhY2ggZXh0cmFjdG9yIGluIG9yZGVyXG4gIGNvbnN0IGV4dHJhY3RvcnMgPSBbXG4gICAgZXh0cmFjdFdlYkFwcFByZXZpZXcsXG4gICAgZXh0cmFjdENvZGVEaWZmUHJldmlldyxcbiAgICBleHRyYWN0Q29kZVByZXZpZXcsXG4gIF07XG5cbiAgZm9yIChjb25zdCBleHRyYWN0b3Igb2YgZXh0cmFjdG9ycykge1xuICAgIGNvbnN0IHByZXZpZXcgPSBleHRyYWN0b3IodG9vbENhbGwpO1xuICAgIGlmIChwcmV2aWV3KSB7XG4gICAgICByZXR1cm4gcHJldmlldztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIEhlbHBlciB0byBkZXRlcm1pbmUgaWYgYSB0b29sIGNhbGwgc2hvdWxkIHRyaWdnZXIgcHJldmlldyBleHRyYWN0aW9uXG5leHBvcnQgY29uc3Qgc2hvdWxkRXh0cmFjdFByZXZpZXcgPSAodG9vbENhbGw6IFRvb2xDYWxsRGF0YSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBwcmV2aWV3VG9vbE5hbWVzID0gW1xuICAgICdjcmVhdGVfd2ViX2FwcCcsXG4gICAgJ2VkaXRfd2ViX2FwcCcsIFxuICAgICdlZGl0X21jcF9zZXJ2ZXInLFxuICAgIC8vIEFkZCBtb3JlIHRvb2wgbmFtZXMgaGVyZSBhcyB3ZSBzdXBwb3J0IHRoZW1cbiAgXTtcblxuICByZXR1cm4gcHJldmlld1Rvb2xOYW1lcy5pbmNsdWRlcyh0b29sQ2FsbC5uYW1lKSAmJiBcbiAgICAgICAgICF0b29sQ2FsbC5pc19lcnJvciAmJiBcbiAgICAgICAgICF0b29sQ2FsbC5pc19wYXJ0aWFsICYmXG4gICAgICAgICB0b29sQ2FsbC5zdGF0dXMgPT09ICdDb21wbGV0ZWQnO1xufTsgIl0sIm5hbWVzIjpbImV4dHJhY3RXZWJBcHBQcmV2aWV3IiwidG9vbENhbGwiLCJpbmNsdWRlcyIsIm5hbWUiLCJyZXN1bHQiLCJpc19lcnJvciIsImlzX3BhcnRpYWwiLCJKU09OIiwicGFyc2UiLCJzdGF0dXMiLCJ1cmwiLCJhcHBOYW1lIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcF9uYW1lIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiaWQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJvcmlnaW5hbF9odG1sIiwibW9kaWZpZWRfaHRtbCIsInR5cGUiLCJkYXRhIiwib3JpZ2luYWwiLCJtb2RpZmllZCIsImZpbGVuYW1lIiwibGFuZ3VhZ2UiLCJtZXNzYWdlIiwiYmFja3VwX2NyZWF0ZWQiLCJzaG91bGRTaG93IiwiZXh0cmFjdENvZGVEaWZmUHJldmlldyIsIm9yaWdpbmFsX2NvZGUiLCJtb2RpZmllZF9jb2RlIiwic2VydmVyTmFtZSIsInNlcnZlcl9uYW1lIiwiY2hhbmdlc0FwcGxpZWQiLCJjaGFuZ2VzX2FwcGxpZWQiLCJyZWxvYWRSZXN1bHQiLCJyZWxvYWRfcmVzdWx0IiwiZXh0cmFjdENvZGVQcmV2aWV3IiwiZXh0cmFjdFByZXZpZXdGcm9tVG9vbENhbGwiLCJleHRyYWN0b3JzIiwiZXh0cmFjdG9yIiwicHJldmlldyIsInNob3VsZEV4dHJhY3RQcmV2aWV3IiwicHJldmlld1Rvb2xOYW1lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/previewExtractors.ts\n"));

/***/ })

});
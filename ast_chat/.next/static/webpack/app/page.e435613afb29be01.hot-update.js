"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useDraftGeneration.ts":
/*!************************************************!*\
  !*** ./hooks/cardStudio/useDraftGeneration.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDraftGeneration: function() { return /* binding */ useDraftGeneration; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/promptGenerator */ \"(app-pages-browser)/./lib/promptGenerator.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useDraftGeneration auto */ \n\n\n\n\nfunction useDraftGeneration(props) {\n    // Draft mode state\n    const [isDraftMode, setIsDraftMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draftCards, setDraftCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedDraftIndex, setSelectedDraftIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);\n    const [isGeneratingFinalCard, setIsGeneratingFinalCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [previewingDraftIndex, setPreviewingDraftIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);\n    const [draftCompletionShown, setDraftCompletionShown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draftCompletionCount, setDraftCompletionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isGenerating, setIsGenerating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [generatedCard, setGeneratedCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generatedCards, setGeneratedCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isCardCompleted, setIsCardCompleted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [currentJobId, setCurrentJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Draft mode generation - creates 5 front cover variations\n    const handleGenerateDraftCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const { userEmail, selectedArtisticStyle, customStyleDescription, referenceImageUrls, selectedDraftModel, selectedType, customCardType, selectedTone, prompt, personalTraits, toField, fromField, selectedPaperSize, finalCardMessage, isHandwrittenMessage, isFrontBackOnly, saveJobToStorage, subscribeToJob, startElapsedTimeTracking } = props;\n        if (!userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter your email address\");\n            return;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(userEmail)) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter a valid email address\");\n            return;\n        }\n        // Validate custom style if selected\n        if (selectedArtisticStyle === \"custom\" && !customStyleDescription.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom artistic style\");\n            return;\n        }\n        // Validate reference images with model compatibility\n        if (referenceImageUrls.length > 0 && selectedDraftModel !== \"gpt-image-1\") {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Reference photos are only supported with GPT Image 1 model. Please switch to GPT Image 1 for draft mode or remove reference photos.\");\n            return;\n        }\n        // Stop any existing timers first\n        props.stopElapsedTimeTracking();\n        // Clear ALL WebSocket subscriptions before starting\n        if (props.unsubscribeFromAllJobs) {\n            props.unsubscribeFromAllJobs();\n        }\n        // No longer need to clear old draft jobs - storage manager handles this automatically\n        setIsDraftMode(true);\n        setIsGenerating(true);\n        startElapsedTimeTracking(\"draft\");\n        setGenerationProgress(\"\\uD83C\\uDFA8 Creating 5 front cover variations for you to choose from...\");\n        setDraftCards([\n            null,\n            null,\n            null,\n            null,\n            null\n        ]); // Initialize with 5 empty slots\n        setSelectedDraftIndex(-1);\n        setDraftCompletionShown(false);\n        setDraftCompletionCount(0);\n        // Clear any previous card state\n        setGeneratedCard(null);\n        setGeneratedCards([]);\n        setIsCardCompleted(false);\n        try {\n            console.log(\"\\uD83D\\uDE80 Starting draft mode generation with 5 variations\");\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = _constants__WEBPACK_IMPORTED_MODULE_3__.cardTones.find((tone)=>tone.id === selectedTone);\n            const toneDescription = selectedToneObj ? selectedToneObj.description.toLowerCase() : \"heartfelt and sincere\";\n            // Use prompt if provided, otherwise create a simple default\n            let effectivePrompt = prompt.trim();\n            if (!effectivePrompt) {\n                effectivePrompt = \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(toneDescription, \" style\");\n            }\n            // Generate 5 draft variations\n            const draftPromises = Array.from({\n                length: 5\n            }, async (_, index)=>{\n                try {\n                    var _paperSizes_find, _paperSizes_find1;\n                    console.log(\"\\uD83C\\uDFA8 Starting draft variation \".concat(index + 1));\n                    // Validate required props\n                    if (!selectedDraftModel) {\n                        throw new Error(\"selectedDraftModel is required but not provided\");\n                    }\n                    if (!selectedPaperSize) {\n                        throw new Error(\"selectedPaperSize is required but not provided\");\n                    }\n                    if (!userEmail) {\n                        throw new Error(\"userEmail is required but not provided\");\n                    }\n                    // For smart style, use predefined styles\n                    let styleOverride = undefined;\n                    let styleLabel = undefined;\n                    if (selectedArtisticStyle === \"ai-smart-style\") {\n                        const predefinedStyles = [\n                            \"watercolor\",\n                            \"botanical\",\n                            \"comic-book\",\n                            \"dreamy-fantasy\",\n                            \"minimalist\"\n                        ];\n                        const styleLabels = [\n                            \"\\uD83C\\uDFA8 Watercolor\",\n                            \"\\uD83C\\uDF3F Botanical\",\n                            \"\\uD83D\\uDCA5 Comic Book\",\n                            \"\\uD83C\\uDF38 Dreamy Fantasy\",\n                            \"✨ Minimalist\"\n                        ];\n                        styleOverride = predefinedStyles[index];\n                        styleLabel = styleLabels[index];\n                    }\n                    // Generate only front cover prompt for draft\n                    const selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_3__.artisticStyles.find((style)=>style.id === (styleOverride || selectedArtisticStyle));\n                    // Use draft prompt generation config for front cover only\n                    const draftConfig = {\n                        cardType: selectedType,\n                        customCardType: customCardType,\n                        tone: selectedTone,\n                        toneLabel: selectedToneObj ? selectedToneObj.label : \"Heartfelt\",\n                        toneDescription: toneDescription,\n                        theme: effectivePrompt,\n                        toField: toField,\n                        fromField: fromField,\n                        relationshipField: props.relationshipField,\n                        personalTraits: props.personalTraits,\n                        artisticStyle: selectedStyle,\n                        referenceImageUrls: referenceImageUrls,\n                        photoReferences: props.photoReferences,\n                        isDraftVariation: selectedArtisticStyle === \"ai-smart-style\",\n                        variationIndex: index\n                    };\n                    // Generate creative front cover prompt using AI\n                    const frontCoverPrompt = await _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.generateCreativeDraftPrompt(draftConfig);\n                    if (!(frontCoverPrompt === null || frontCoverPrompt === void 0 ? void 0 : frontCoverPrompt.trim())) {\n                        throw new Error(\"Failed to generate front cover prompt\");\n                    }\n                    // Generate the images\n                    const jobId = \"draft-\".concat(index, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])());\n                    const inputImages = [];\n                    if (referenceImageUrls.length > 0 && selectedDraftModel === \"gpt-image-1\") {\n                        inputImages.push(...referenceImageUrls);\n                    }\n                    // Log the request payload for debugging\n                    const requestPayload = {\n                        jobId,\n                        prompts: {\n                            frontCover: frontCoverPrompt\n                        },\n                        config: {\n                            userNumber: \"+17145986105\",\n                            modelVersion: selectedDraftModel,\n                            aspectRatio: ((_paperSizes_find = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find === void 0 ? void 0 : _paperSizes_find.aspectRatio) || \"9:16\",\n                            quality: \"medium\",\n                            outputFormat: \"jpeg\",\n                            outputCompression: 85,\n                            moderation: \"low\",\n                            dimensions: ((_paperSizes_find1 = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find1 === void 0 ? void 0 : _paperSizes_find1.dimensions) || \"1024x1536\",\n                            isFrontBackOnly: true,\n                            userEmail,\n                            cardType: cardTypeForPrompt,\n                            toField,\n                            fromField,\n                            isDraftMode: true,\n                            ...inputImages.length > 0 && {\n                                input_images: inputImages,\n                                input_images_mode: \"front_cover_only\"\n                            }\n                        }\n                    };\n                    console.log(\"\\uD83D\\uDCE6 Draft \".concat(index + 1, \" request payload:\"), {\n                        jobId,\n                        promptsExist: !!frontCoverPrompt,\n                        promptKeys: [\n                            \"frontCover\"\n                        ],\n                        modelVersion: selectedDraftModel,\n                        paperSize: selectedPaperSize,\n                        email: userEmail\n                    });\n                    const response = await fetch(\"/api/generate-card-async\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify(requestPayload)\n                    });\n                    if (!response.ok) {\n                        const errorText = await response.text();\n                        console.error(\"Server error response for draft \".concat(index + 1, \":\"), errorText);\n                        throw new Error(\"Server error: \".concat(response.status, \" - \").concat(errorText));\n                    }\n                    const result = await response.json();\n                    if (result.status !== \"processing\") {\n                        throw new Error(result.message || \"Failed to start draft generation\");\n                    }\n                    console.log(\"✅ Draft variation \".concat(index + 1, \" job started:\"), jobId);\n                    // Save draft job to storage for recovery\n                    saveJobToStorage(jobId, {\n                        isDraft: true,\n                        draftIndex: index,\n                        styleInfo: styleOverride ? {\n                            styleName: styleOverride,\n                            styleLabel: styleLabel\n                        } : undefined,\n                        frontCoverPrompt: frontCoverPrompt,\n                        generatedPrompts: {\n                            frontCover: frontCoverPrompt\n                        },\n                        userEmail,\n                        selectedType,\n                        selectedTone,\n                        toField,\n                        fromField,\n                        draftCards: [] // Will be updated as drafts complete\n                    });\n                    // Subscribe to WebSocket updates\n                    subscribeToJob(jobId);\n                } catch (error) {\n                    console.error(\"❌ Draft variation \".concat(index + 1, \" failed:\"), error);\n                    console.error(\"Full error details:\", {\n                        message: error instanceof Error ? error.message : \"Unknown error\",\n                        stack: error instanceof Error ? error.stack : \"No stack trace\",\n                        error: error\n                    });\n                    sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Draft variation \".concat(index + 1, \" failed: \").concat(error instanceof Error ? error.message : \"Unknown error\"));\n                }\n            });\n            // Wait for all draft generations to start\n            await Promise.allSettled(draftPromises);\n            console.log(\"\\uD83D\\uDE80 All draft variations started\");\n        } catch (error) {\n            console.error(\"Draft card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to start draft generation: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n            setIsGenerating(false);\n            setIsDraftMode(false);\n            setDraftCompletionShown(false);\n            setDraftCompletionCount(0);\n            setGenerationProgress(\"\");\n            props.stopElapsedTimeTracking();\n        }\n    }, [\n        props\n    ]);\n    // Generate final high-quality card from selected draft\n    const handleGenerateFinalFromDraft = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (displayIndex)=>{\n        // Prevent duplicate calls\n        if (isGeneratingFinalCard) {\n            console.log(\"⚠️ Final card generation already in progress, skipping duplicate call\");\n            return;\n        }\n        const selectedDraft = draftCards[displayIndex];\n        if (!selectedDraft) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please wait for the draft to complete before selecting\");\n            return;\n        }\n        const { selectedType, customCardType, selectedTone, prompt, personalTraits, toField, fromField, finalCardMessage, isHandwrittenMessage, selectedArtisticStyle, customStyleDescription, isFrontBackOnly, selectedImageModel, selectedPaperSize, userEmail, referenceImageUrls, startElapsedTimeTracking, subscribeToJob } = props;\n        // Stop any existing timers first\n        props.stopElapsedTimeTracking();\n        setIsGeneratingFinalCard(true);\n        setIsDraftMode(false); // Switch out of draft mode for final generation\n        setSelectedDraftIndex(displayIndex);\n        startElapsedTimeTracking(\"final\");\n        setGenerationProgress(\"\\uD83C\\uDFA8 Creating the complete card based on your selected front cover...\");\n        try {\n            var _selectedDraft_generatedPrompts, _paperSizes_find, _paperSizes_find1;\n            const jobId = (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n            // Generate the missing prompts\n            const storedFrontCoverPrompt = (_selectedDraft_generatedPrompts = selectedDraft.generatedPrompts) === null || _selectedDraft_generatedPrompts === void 0 ? void 0 : _selectedDraft_generatedPrompts.frontCover;\n            if (!storedFrontCoverPrompt) {\n                throw new Error(\"Selected draft is missing frontCover prompt\");\n            }\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = _constants__WEBPACK_IMPORTED_MODULE_3__.cardTones.find((tone)=>tone.id === selectedTone);\n            const toneDescription = selectedToneObj ? selectedToneObj.description.toLowerCase() : \"heartfelt and sincere\";\n            const effectivePrompt = prompt.trim() || \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(toneDescription, \" style\");\n            let messageContent = finalCardMessage;\n            if (isHandwrittenMessage) {\n                messageContent = \"[Blank space for handwritten message]\";\n            }\n            // Get style from the selected draft\n            const draftStyleInfo = selectedDraft.styleInfo;\n            let selectedStyle;\n            if (draftStyleInfo && draftStyleInfo.styleName) {\n                selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_3__.artisticStyles.find((style)=>style.id === draftStyleInfo.styleName);\n            } else {\n                selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_3__.artisticStyles.find((style)=>style.id === selectedArtisticStyle);\n            }\n            // Use PromptGenerator for final card from draft\n            const finalFromDraftConfig = {\n                frontCoverPrompt: storedFrontCoverPrompt,\n                cardType: selectedType,\n                customCardType: customCardType,\n                theme: effectivePrompt,\n                tone: selectedTone,\n                toneDescription: toneDescription,\n                toField: toField,\n                fromField: fromField,\n                relationshipField: props.relationshipField,\n                personalTraits: props.personalTraits,\n                photoReferences: props.photoReferences,\n                message: messageContent,\n                isHandwrittenMessage: isHandwrittenMessage,\n                artisticStyle: selectedStyle,\n                isFrontBackOnly: isFrontBackOnly\n            };\n            const finalPrompts = await _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.generateFinalFromDraftPromptsCombined(finalFromDraftConfig);\n            if (!finalPrompts || !finalPrompts.frontCover || !finalPrompts.backCover) {\n                throw new Error(\"Failed to generate complete prompts for final card\");\n            }\n            // Prepare input images for final generation\n            const inputImages = [];\n            // Add the selected draft's front cover as a reference image for the final front cover\n            if (selectedDraft.frontCover) {\n                inputImages.push(selectedDraft.frontCover);\n                console.log(\"\\uD83D\\uDDBC️ Adding draft front cover as reference for final front cover generation\");\n            }\n            // Also include any user-uploaded reference images\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-image-1\") {\n                inputImages.push(...referenceImageUrls);\n            }\n            const response = await fetch(\"/api/generate-card-async\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobId,\n                    prompts: finalPrompts,\n                    config: {\n                        userNumber: \"+17145986105\",\n                        modelVersion: selectedImageModel,\n                        aspectRatio: ((_paperSizes_find = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find === void 0 ? void 0 : _paperSizes_find.aspectRatio) || \"9:16\",\n                        quality: \"high\",\n                        outputFormat: \"jpeg\",\n                        outputCompression: 100,\n                        moderation: \"low\",\n                        dimensions: ((_paperSizes_find1 = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize)) === null || _paperSizes_find1 === void 0 ? void 0 : _paperSizes_find1.dimensions) || \"1024x1536\",\n                        isFrontBackOnly,\n                        userEmail,\n                        cardType: selectedType === \"custom\" ? customCardType : selectedType,\n                        toField,\n                        fromField,\n                        isDraftMode: false,\n                        ...inputImages.length > 0 && {\n                            input_images: inputImages,\n                            input_images_mode: \"front_cover_only\" // Use images as reference for front cover only\n                        }\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.status !== \"processing\") {\n                throw new Error(result.message || \"Failed to start final card generation\");\n            }\n            setCurrentJobId(jobId);\n            // Save job data for recovery\n            const jobData = {\n                jobId,\n                selectedDraftIndex: displayIndex,\n                cardType: selectedType,\n                customCardType,\n                tone: selectedTone,\n                prompt,\n                personalTraits,\n                toField,\n                fromField,\n                finalCardMessage,\n                isHandwrittenMessage,\n                selectedArtisticStyle,\n                isFrontBackOnly,\n                selectedPaperSize,\n                userEmail,\n                referenceImageUrls\n            };\n            props.saveJobToStorage(jobId, jobData);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDFA8 Generating high-quality version of your selected design!\");\n            // Subscribe to WebSocket updates\n            subscribeToJob(jobId);\n        } catch (error) {\n            console.error(\"Final card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate final card. Please try again.\");\n            setIsGeneratingFinalCard(false);\n            setGenerationProgress(\"\");\n            props.stopElapsedTimeTracking(); // Clear time-based progress on error\n        }\n    }, [\n        draftCards,\n        isGeneratingFinalCard,\n        props\n    ]);\n    return {\n        isDraftMode,\n        setIsDraftMode,\n        draftCards,\n        setDraftCards,\n        selectedDraftIndex,\n        setSelectedDraftIndex,\n        isGeneratingFinalCard,\n        setIsGeneratingFinalCard,\n        previewingDraftIndex,\n        setPreviewingDraftIndex,\n        draftCompletionShown,\n        setDraftCompletionShown,\n        draftCompletionCount,\n        setDraftCompletionCount,\n        handleGenerateDraftCards,\n        handleGenerateFinalFromDraft,\n        isGenerating,\n        setIsGenerating,\n        generationProgress,\n        setGenerationProgress,\n        generatedCard,\n        setGeneratedCard,\n        generatedCards,\n        setGeneratedCards,\n        isCardCompleted,\n        setIsCardCompleted,\n        currentJobId,\n        setCurrentJobId\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRHJhZnRHZW5lcmF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7d0VBRThDO0FBQ2Y7QUFDSztBQUNtRTtBQUNKO0FBaUM1RixTQUFTUyxtQkFBbUJDLEtBQTJCO0lBQzVELG1CQUFtQjtJQUNuQixNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBR1osK0NBQVFBLENBQVU7SUFDeEQsTUFBTSxDQUFDYSxZQUFZQyxjQUFjLEdBQUdkLCtDQUFRQSxDQUEyQixFQUFFO0lBQ3pFLE1BQU0sQ0FBQ2Usb0JBQW9CQyxzQkFBc0IsR0FBR2hCLCtDQUFRQSxDQUFTLENBQUM7SUFDdEUsTUFBTSxDQUFDaUIsdUJBQXVCQyx5QkFBeUIsR0FBR2xCLCtDQUFRQSxDQUFVO0lBQzVFLE1BQU0sQ0FBQ21CLHNCQUFzQkMsd0JBQXdCLEdBQUdwQiwrQ0FBUUEsQ0FBUyxDQUFDO0lBQzFFLE1BQU0sQ0FBQ3FCLHNCQUFzQkMsd0JBQXdCLEdBQUd0QiwrQ0FBUUEsQ0FBVTtJQUMxRSxNQUFNLENBQUN1QixzQkFBc0JDLHdCQUF3QixHQUFHeEIsK0NBQVFBLENBQVM7SUFDekUsTUFBTSxDQUFDeUIsY0FBY0MsZ0JBQWdCLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUMyQixvQkFBb0JDLHNCQUFzQixHQUFHNUIsK0NBQVFBLENBQUM7SUFDN0QsTUFBTSxDQUFDNkIsZUFBZUMsaUJBQWlCLEdBQUc5QiwrQ0FBUUEsQ0FBdUI7SUFDekUsTUFBTSxDQUFDK0IsZ0JBQWdCQyxrQkFBa0IsR0FBR2hDLCtDQUFRQSxDQUFrQixFQUFFO0lBQ3hFLE1BQU0sQ0FBQ2lDLGlCQUFpQkMsbUJBQW1CLEdBQUdsQywrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUNtQyxjQUFjQyxnQkFBZ0IsR0FBR3BDLCtDQUFRQSxDQUFnQjtJQUVoRSwyREFBMkQ7SUFDM0QsTUFBTXFDLDJCQUEyQnBDLGtEQUFXQSxDQUFD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QUNqQ3JHLGVBQWU2QztRQUVqQixFQUFFLE9BQU8xQyxPQUFPO1lBQ2RNLFFBQVFOLEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDeEQseUNBQUtBLENBQUN3RCxLQUFLLENBQUM7WUFDWnhDLHlCQUF5QjtZQUN6QlUsc0JBQXNCO1lBQ3RCbEIsTUFBTW9ELHVCQUF1QixJQUFJLHFDQUFxQztRQUN4RTtJQUNGLEdBQUc7UUFBQ2pEO1FBQVlJO1FBQXVCUDtLQUFNO0lBRTdDLE9BQU87UUFDTEM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQWE7UUFDQTJHO1FBQ0F2SDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvY2FyZFN0dWRpby91c2VEcmFmdEdlbmVyYXRpb24udHM/NGM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJzb25uZXJcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgUHJvbXB0R2VuZXJhdG9yLCBEcmFmdENvbmZpZywgRmluYWxGcm9tRHJhZnRDb25maWcsIENhcmRDb25maWcgfSBmcm9tICdAL2xpYi9wcm9tcHRHZW5lcmF0b3InO1xuaW1wb3J0IHsgR2VuZXJhdGVkQ2FyZCwgYXJ0aXN0aWNTdHlsZXMsIHBhcGVyU2l6ZXMsIGNhcmRUb25lcywgUGhvdG9SZWZlcmVuY2UgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjaGF0V2l0aEFJIH0gZnJvbSAnLi91dGlscyc7XG5cbmludGVyZmFjZSBEcmFmdEdlbmVyYXRpb25Qcm9wcyB7XG4gIC8vIEZvcm0gZGF0YVxuICBzZWxlY3RlZFR5cGU6IHN0cmluZztcbiAgY3VzdG9tQ2FyZFR5cGU6IHN0cmluZztcbiAgc2VsZWN0ZWRUb25lOiBzdHJpbmc7XG4gIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZTogc3RyaW5nO1xuICBjdXN0b21TdHlsZURlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHNlbGVjdGVkRHJhZnRNb2RlbDogc3RyaW5nO1xuICBzZWxlY3RlZEltYWdlTW9kZWw6IHN0cmluZztcbiAgc2VsZWN0ZWRQYXBlclNpemU6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIHBlcnNvbmFsVHJhaXRzPzogc3RyaW5nO1xuICB0b0ZpZWxkOiBzdHJpbmc7XG4gIGZyb21GaWVsZDogc3RyaW5nO1xuICByZWxhdGlvbnNoaXBGaWVsZDogc3RyaW5nO1xuICB1c2VyRW1haWw6IHN0cmluZztcbiAgZmluYWxDYXJkTWVzc2FnZTogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogYm9vbGVhbjtcbiAgaXNGcm9udEJhY2tPbmx5OiBib29sZWFuO1xuICByZWZlcmVuY2VJbWFnZVVybHM6IHN0cmluZ1tdO1xuICBwaG90b1JlZmVyZW5jZXM/OiBQaG90b1JlZmVyZW5jZVtdO1xuICBcbiAgLy8gSm9iIG1hbmFnZW1lbnRcbiAgc2F2ZUpvYlRvU3RvcmFnZTogKGpvYklkOiBzdHJpbmcsIGpvYkRhdGE6IGFueSkgPT4gdm9pZDtcbiAgc3Vic2NyaWJlVG9Kb2I6IChqb2JJZDogc3RyaW5nKSA9PiB2b2lkO1xuICB1bnN1YnNjcmliZUZyb21BbGxKb2JzPzogKCkgPT4gdm9pZDtcbiAgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nOiAoam9iVHlwZT86ICdkcmFmdCcgfCAnZmluYWwnKSA9PiB2b2lkO1xuICBzdG9wRWxhcHNlZFRpbWVUcmFja2luZzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyYWZ0R2VuZXJhdGlvbihwcm9wczogRHJhZnRHZW5lcmF0aW9uUHJvcHMpIHtcbiAgLy8gRHJhZnQgbW9kZSBzdGF0ZVxuICBjb25zdCBbaXNEcmFmdE1vZGUsIHNldElzRHJhZnRNb2RlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2RyYWZ0Q2FyZHMsIHNldERyYWZ0Q2FyZHNdID0gdXNlU3RhdGU8KEdlbmVyYXRlZENhcmQgfCBudWxsKVtdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZERyYWZ0SW5kZXgsIHNldFNlbGVjdGVkRHJhZnRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXI+KC0xKTtcbiAgY29uc3QgW2lzR2VuZXJhdGluZ0ZpbmFsQ2FyZCwgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3ByZXZpZXdpbmdEcmFmdEluZGV4LCBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXI+KC0xKTtcbiAgY29uc3QgW2RyYWZ0Q29tcGxldGlvblNob3duLCBzZXREcmFmdENvbXBsZXRpb25TaG93bl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtkcmFmdENvbXBsZXRpb25Db3VudCwgc2V0RHJhZnRDb21wbGV0aW9uQ291bnRdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2lzR2VuZXJhdGluZywgc2V0SXNHZW5lcmF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2dlbmVyYXRpb25Qcm9ncmVzcywgc2V0R2VuZXJhdGlvblByb2dyZXNzXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbZ2VuZXJhdGVkQ2FyZCwgc2V0R2VuZXJhdGVkQ2FyZF0gPSB1c2VTdGF0ZTxHZW5lcmF0ZWRDYXJkIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0ZWRDYXJkcywgc2V0R2VuZXJhdGVkQ2FyZHNdID0gdXNlU3RhdGU8R2VuZXJhdGVkQ2FyZFtdPihbXSk7XG4gIGNvbnN0IFtpc0NhcmRDb21wbGV0ZWQsIHNldElzQ2FyZENvbXBsZXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50Sm9iSWQsIHNldEN1cnJlbnRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBEcmFmdCBtb2RlIGdlbmVyYXRpb24gLSBjcmVhdGVzIDUgZnJvbnQgY292ZXIgdmFyaWF0aW9uc1xuICBjb25zdCBoYW5kbGVHZW5lcmF0ZURyYWZ0Q2FyZHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdXNlckVtYWlsLFxuICAgICAgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlLFxuICAgICAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbixcbiAgICAgIHJlZmVyZW5jZUltYWdlVXJscyxcbiAgICAgIHNlbGVjdGVkRHJhZnRNb2RlbCxcbiAgICAgIHNlbGVjdGVkVHlwZSxcbiAgICAgIGN1c3RvbUNhcmRUeXBlLFxuICAgICAgc2VsZWN0ZWRUb25lLFxuICAgICAgcHJvbXB0LFxuICAgICAgcGVyc29uYWxUcmFpdHMsXG4gICAgICB0b0ZpZWxkLFxuICAgICAgZnJvbUZpZWxkLFxuICAgICAgc2VsZWN0ZWRQYXBlclNpemUsXG4gICAgICBmaW5hbENhcmRNZXNzYWdlLFxuICAgICAgaXNIYW5kd3JpdHRlbk1lc3NhZ2UsXG4gICAgICBpc0Zyb250QmFja09ubHksXG4gICAgICBzYXZlSm9iVG9TdG9yYWdlLFxuICAgICAgc3Vic2NyaWJlVG9Kb2IsXG4gICAgICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmdcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoIXVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIHlvdXIgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBlbWFpbCB2YWxpZGF0aW9uXG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgIGlmICghZW1haWxSZWdleC50ZXN0KHVzZXJFbWFpbCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjdXN0b20gc3R5bGUgaWYgc2VsZWN0ZWRcbiAgICBpZiAoc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFjdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlIGltYWdlcyB3aXRoIG1vZGVsIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWREcmFmdE1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUmVmZXJlbmNlIHBob3RvcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBHUFQgSW1hZ2UgMSBtb2RlbC4gUGxlYXNlIHN3aXRjaCB0byBHUFQgSW1hZ2UgMSBmb3IgZHJhZnQgbW9kZSBvciByZW1vdmUgcmVmZXJlbmNlIHBob3Rvcy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcCBhbnkgZXhpc3RpbmcgdGltZXJzIGZpcnN0XG4gICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICBcbiAgICAvLyBDbGVhciBBTEwgV2ViU29ja2V0IHN1YnNjcmlwdGlvbnMgYmVmb3JlIHN0YXJ0aW5nXG4gICAgaWYgKHByb3BzLnVuc3Vic2NyaWJlRnJvbUFsbEpvYnMpIHtcbiAgICAgIHByb3BzLnVuc3Vic2NyaWJlRnJvbUFsbEpvYnMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTm8gbG9uZ2VyIG5lZWQgdG8gY2xlYXIgb2xkIGRyYWZ0IGpvYnMgLSBzdG9yYWdlIG1hbmFnZXIgaGFuZGxlcyB0aGlzIGF1dG9tYXRpY2FsbHlcbiAgICBcbiAgICBzZXRJc0RyYWZ0TW9kZSh0cnVlKTtcbiAgICBzZXRJc0dlbmVyYXRpbmcodHJ1ZSk7XG4gICAgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nKCdkcmFmdCcpO1xuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIvCfjqggQ3JlYXRpbmcgNSBmcm9udCBjb3ZlciB2YXJpYXRpb25zIGZvciB5b3UgdG8gY2hvb3NlIGZyb20uLi5cIik7XG4gICAgc2V0RHJhZnRDYXJkcyhbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0pOyAvLyBJbml0aWFsaXplIHdpdGggNSBlbXB0eSBzbG90c1xuICAgIHNldFNlbGVjdGVkRHJhZnRJbmRleCgtMSk7XG4gICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24oZmFsc2UpO1xuICAgIHNldERyYWZ0Q29tcGxldGlvbkNvdW50KDApO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBjYXJkIHN0YXRlXG4gICAgc2V0R2VuZXJhdGVkQ2FyZChudWxsKTtcbiAgICBzZXRHZW5lcmF0ZWRDYXJkcyhbXSk7XG4gICAgc2V0SXNDYXJkQ29tcGxldGVkKGZhbHNlKTtcbiAgICBcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfmoAgU3RhcnRpbmcgZHJhZnQgbW9kZSBnZW5lcmF0aW9uIHdpdGggNSB2YXJpYXRpb25zXCIpO1xuICAgICAgXG4gICAgICBjb25zdCBjYXJkVHlwZUZvclByb21wdCA9IHNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiA/IGN1c3RvbUNhcmRUeXBlIDogc2VsZWN0ZWRUeXBlO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRUb25lT2JqID0gY2FyZFRvbmVzLmZpbmQodG9uZSA9PiB0b25lLmlkID09PSBzZWxlY3RlZFRvbmUpO1xuICAgICAgY29uc3QgdG9uZURlc2NyaXB0aW9uID0gc2VsZWN0ZWRUb25lT2JqID8gc2VsZWN0ZWRUb25lT2JqLmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkgOiBcImhlYXJ0ZmVsdCBhbmQgc2luY2VyZVwiO1xuICAgICAgXG4gICAgICAvLyBVc2UgcHJvbXB0IGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY3JlYXRlIGEgc2ltcGxlIGRlZmF1bHRcbiAgICAgIGxldCBlZmZlY3RpdmVQcm9tcHQgPSBwcm9tcHQudHJpbSgpO1xuICAgICAgXG4gICAgICBpZiAoIWVmZmVjdGl2ZVByb21wdCkge1xuICAgICAgICBlZmZlY3RpdmVQcm9tcHQgPSBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZCB3aXRoICR7dG9uZURlc2NyaXB0aW9ufSBzdHlsZWA7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIDUgZHJhZnQgdmFyaWF0aW9uc1xuICAgICAgY29uc3QgZHJhZnRQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgYXN5bmMgKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjqggU3RhcnRpbmcgZHJhZnQgdmFyaWF0aW9uICR7aW5kZXggKyAxfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIHByb3BzXG4gICAgICAgICAgaWYgKCFzZWxlY3RlZERyYWZ0TW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VsZWN0ZWREcmFmdE1vZGVsIGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJvdmlkZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxlY3RlZFBhcGVyU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWxlY3RlZFBhcGVyU2l6ZSBpcyByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdXNlckVtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJFbWFpbCBpcyByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBzbWFydCBzdHlsZSwgdXNlIHByZWRlZmluZWQgc3R5bGVzXG4gICAgICAgICAgbGV0IHN0eWxlT3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgc3R5bGVMYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiYWktc21hcnQtc3R5bGVcIikge1xuICAgICAgICAgICAgY29uc3QgcHJlZGVmaW5lZFN0eWxlcyA9IFtcIndhdGVyY29sb3JcIiwgXCJib3RhbmljYWxcIiwgXCJjb21pYy1ib29rXCIsIFwiZHJlYW15LWZhbnRhc3lcIiwgXCJtaW5pbWFsaXN0XCJdO1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVMYWJlbHMgPSBbXCLwn46oIFdhdGVyY29sb3JcIiwgXCLwn4y/IEJvdGFuaWNhbFwiLCBcIvCfkqUgQ29taWMgQm9va1wiLCBcIvCfjLggRHJlYW15IEZhbnRhc3lcIiwgXCLinKggTWluaW1hbGlzdFwiXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3R5bGVPdmVycmlkZSA9IHByZWRlZmluZWRTdHlsZXNbaW5kZXhdO1xuICAgICAgICAgICAgc3R5bGVMYWJlbCA9IHN0eWxlTGFiZWxzW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgb25seSBmcm9udCBjb3ZlciBwcm9tcHQgZm9yIGRyYWZ0XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRTdHlsZSA9IGFydGlzdGljU3R5bGVzLmZpbmQoc3R5bGUgPT4gc3R5bGUuaWQgPT09IChzdHlsZU92ZXJyaWRlIHx8IHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVzZSBkcmFmdCBwcm9tcHQgZ2VuZXJhdGlvbiBjb25maWcgZm9yIGZyb250IGNvdmVyIG9ubHlcbiAgICAgICAgICBjb25zdCBkcmFmdENvbmZpZzogRHJhZnRDb25maWcgPSB7XG4gICAgICAgICAgICBjYXJkVHlwZTogc2VsZWN0ZWRUeXBlLFxuICAgICAgICAgICAgY3VzdG9tQ2FyZFR5cGU6IGN1c3RvbUNhcmRUeXBlLFxuICAgICAgICAgICAgdG9uZTogc2VsZWN0ZWRUb25lLFxuICAgICAgICAgICAgdG9uZUxhYmVsOiBzZWxlY3RlZFRvbmVPYmogPyBzZWxlY3RlZFRvbmVPYmoubGFiZWwgOiBcIkhlYXJ0ZmVsdFwiLFxuICAgICAgICAgICAgdG9uZURlc2NyaXB0aW9uOiB0b25lRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB0aGVtZTogZWZmZWN0aXZlUHJvbXB0LFxuICAgICAgICAgICAgdG9GaWVsZDogdG9GaWVsZCxcbiAgICAgICAgICAgIGZyb21GaWVsZDogZnJvbUZpZWxkLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwRmllbGQ6IHByb3BzLnJlbGF0aW9uc2hpcEZpZWxkLFxuICAgICAgICAgICAgcGVyc29uYWxUcmFpdHM6IHByb3BzLnBlcnNvbmFsVHJhaXRzLFxuICAgICAgICAgICAgYXJ0aXN0aWNTdHlsZTogc2VsZWN0ZWRTdHlsZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlVXJsczogcmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgICAgICAgICAgcGhvdG9SZWZlcmVuY2VzOiBwcm9wcy5waG90b1JlZmVyZW5jZXMsXG4gICAgICAgICAgICBpc0RyYWZ0VmFyaWF0aW9uOiBzZWxlY3RlZEFydGlzdGljU3R5bGUgPT09IFwiYWktc21hcnQtc3R5bGVcIixcbiAgICAgICAgICAgIHZhcmlhdGlvbkluZGV4OiBpbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZSBjcmVhdGl2ZSBmcm9udCBjb3ZlciBwcm9tcHQgdXNpbmcgQUlcbiAgICAgICAgICBjb25zdCBmcm9udENvdmVyUHJvbXB0ID0gYXdhaXQgUHJvbXB0R2VuZXJhdG9yLmdlbmVyYXRlQ3JlYXRpdmVEcmFmdFByb21wdChkcmFmdENvbmZpZyk7XG5cbiAgICAgICAgICBpZiAoIWZyb250Q292ZXJQcm9tcHQ/LnRyaW0oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGZyb250IGNvdmVyIHByb21wdFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgaW1hZ2VzXG4gICAgICAgICAgY29uc3Qgam9iSWQgPSBgZHJhZnQtJHtpbmRleH0tJHt1dWlkdjQoKX1gO1xuICAgICAgICAgIGNvbnN0IGlucHV0SW1hZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGlmIChyZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZERyYWZ0TW9kZWwgPT09IFwiZ3B0LWltYWdlLTFcIikge1xuICAgICAgICAgICAgaW5wdXRJbWFnZXMucHVzaCguLi5yZWZlcmVuY2VJbWFnZVVybHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIExvZyB0aGUgcmVxdWVzdCBwYXlsb2FkIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgcHJvbXB0czoge1xuICAgICAgICAgICAgICBmcm9udENvdmVyOiBmcm9udENvdmVyUHJvbXB0XG4gICAgICAgICAgICAgIC8vIE9ubHkgc2VuZCBmcm9udCBjb3ZlciBwcm9tcHQgZm9yIGRyYWZ0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICB1c2VyTnVtYmVyOiBcIisxNzE0NTk4NjEwNVwiLFxuICAgICAgICAgICAgICBtb2RlbFZlcnNpb246IHNlbGVjdGVkRHJhZnRNb2RlbCxcbiAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IHBhcGVyU2l6ZXMuZmluZChzaXplID0+IHNpemUuaWQgPT09IHNlbGVjdGVkUGFwZXJTaXplKT8uYXNwZWN0UmF0aW8gfHwgXCI5OjE2XCIsXG4gICAgICAgICAgICAgIHF1YWxpdHk6IFwibWVkaXVtXCIsIC8vIFVzZSBtZWRpdW0gcXVhbGl0eSBmb3IgZHJhZnRzIChiZXR0ZXIgdGhhbiBsb3csIGZhc3RlciB0aGFuIGhpZ2gpXG4gICAgICAgICAgICAgIG91dHB1dEZvcm1hdDogXCJqcGVnXCIsXG4gICAgICAgICAgICAgIG91dHB1dENvbXByZXNzaW9uOiA4NSwgLy8gU2xpZ2h0bHkgbG93ZXIgY29tcHJlc3Npb24gZm9yIGRyYWZ0c1xuICAgICAgICAgICAgICBtb2RlcmF0aW9uOiBcImxvd1wiLFxuICAgICAgICAgICAgICBkaW1lbnNpb25zOiBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSk/LmRpbWVuc2lvbnMgfHwgXCIxMDI0eDE1MzZcIixcbiAgICAgICAgICAgICAgaXNGcm9udEJhY2tPbmx5OiB0cnVlLCAvLyBGb3JjZSBmcm9udC1vbmx5IGZvciBkcmFmdHNcbiAgICAgICAgICAgICAgdXNlckVtYWlsLFxuICAgICAgICAgICAgICBjYXJkVHlwZTogY2FyZFR5cGVGb3JQcm9tcHQsXG4gICAgICAgICAgICAgIHRvRmllbGQsXG4gICAgICAgICAgICAgIGZyb21GaWVsZCxcbiAgICAgICAgICAgICAgaXNEcmFmdE1vZGU6IHRydWUsXG4gICAgICAgICAgICAgIC4uLihpbnB1dEltYWdlcy5sZW5ndGggPiAwICYmIHsgXG4gICAgICAgICAgICAgICAgaW5wdXRfaW1hZ2VzOiBpbnB1dEltYWdlcyxcbiAgICAgICAgICAgICAgICBpbnB1dF9pbWFnZXNfbW9kZTogXCJmcm9udF9jb3Zlcl9vbmx5XCJcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk6YgRHJhZnQgJHtpbmRleCArIDF9IHJlcXVlc3QgcGF5bG9hZDpgLCB7XG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIHByb21wdHNFeGlzdDogISFmcm9udENvdmVyUHJvbXB0LFxuICAgICAgICAgICAgcHJvbXB0S2V5czogWydmcm9udENvdmVyJ10sXG4gICAgICAgICAgICBtb2RlbFZlcnNpb246IHNlbGVjdGVkRHJhZnRNb2RlbCxcbiAgICAgICAgICAgIHBhcGVyU2l6ZTogc2VsZWN0ZWRQYXBlclNpemUsXG4gICAgICAgICAgICBlbWFpbDogdXNlckVtYWlsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2dlbmVyYXRlLWNhcmQtYXN5bmMnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdFBheWxvYWQpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgZXJyb3IgcmVzcG9uc2UgZm9yIGRyYWZ0ICR7aW5kZXggKyAxfTpgLCBlcnJvclRleHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAtICR7ZXJyb3JUZXh0fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gJ3Byb2Nlc3NpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBzdGFydCBkcmFmdCBnZW5lcmF0aW9uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBEcmFmdCB2YXJpYXRpb24gJHtpbmRleCArIDF9IGpvYiBzdGFydGVkOmAsIGpvYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIGRyYWZ0IGpvYiB0byBzdG9yYWdlIGZvciByZWNvdmVyeVxuICAgICAgICAgIHNhdmVKb2JUb1N0b3JhZ2Uoam9iSWQsIHtcbiAgICAgICAgICAgIGlzRHJhZnQ6IHRydWUsXG4gICAgICAgICAgICBkcmFmdEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHN0eWxlSW5mbzogc3R5bGVPdmVycmlkZSA/IHsgc3R5bGVOYW1lOiBzdHlsZU92ZXJyaWRlLCBzdHlsZUxhYmVsOiBzdHlsZUxhYmVsIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmcm9udENvdmVyUHJvbXB0OiBmcm9udENvdmVyUHJvbXB0LFxuICAgICAgICAgICAgZ2VuZXJhdGVkUHJvbXB0czogeyBmcm9udENvdmVyOiBmcm9udENvdmVyUHJvbXB0IH0sIC8vIFN0b3JlIG9ubHkgZnJvbnQgY292ZXIgcHJvbXB0XG4gICAgICAgICAgICB1c2VyRW1haWwsXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGUsXG4gICAgICAgICAgICBzZWxlY3RlZFRvbmUsXG4gICAgICAgICAgICB0b0ZpZWxkLFxuICAgICAgICAgICAgZnJvbUZpZWxkLFxuICAgICAgICAgICAgZHJhZnRDYXJkczogW10gIC8vIFdpbGwgYmUgdXBkYXRlZCBhcyBkcmFmdHMgY29tcGxldGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJTb2NrZXQgdXBkYXRlc1xuICAgICAgICAgIHN1YnNjcmliZVRvSm9iKGpvYklkKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBEcmFmdCB2YXJpYXRpb24gJHtpbmRleCArIDF9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRnVsbCBlcnJvciBkZXRhaWxzOicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6ICdObyBzdGFjayB0cmFjZScsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b2FzdC5lcnJvcihgRHJhZnQgdmFyaWF0aW9uICR7aW5kZXggKyAxfSBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBhbGwgZHJhZnQgZ2VuZXJhdGlvbnMgdG8gc3RhcnRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChkcmFmdFByb21pc2VzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+agCBBbGwgZHJhZnQgdmFyaWF0aW9ucyBzdGFydGVkXCIpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RyYWZ0IGNhcmQgZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIHN0YXJ0IGRyYWZ0IGdlbmVyYXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICBcbiAgICAgIHNldElzR2VuZXJhdGluZyhmYWxzZSk7XG4gICAgICBzZXRJc0RyYWZ0TW9kZShmYWxzZSk7XG4gICAgICBzZXREcmFmdENvbXBsZXRpb25TaG93bihmYWxzZSk7XG4gICAgICBzZXREcmFmdENvbXBsZXRpb25Db3VudCgwKTtcbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlwiKTtcbiAgICAgIHByb3BzLnN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgfVxuICB9LCBbcHJvcHNdKTtcblxuICAvLyBHZW5lcmF0ZSBmaW5hbCBoaWdoLXF1YWxpdHkgY2FyZCBmcm9tIHNlbGVjdGVkIGRyYWZ0XG4gIGNvbnN0IGhhbmRsZUdlbmVyYXRlRmluYWxGcm9tRHJhZnQgPSB1c2VDYWxsYmFjayhhc3luYyAoZGlzcGxheUluZGV4OiBudW1iZXIpID0+IHtcbiAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBjYWxsc1xuICAgIGlmIChpc0dlbmVyYXRpbmdGaW5hbENhcmQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gRmluYWwgY2FyZCBnZW5lcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIGR1cGxpY2F0ZSBjYWxsJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlbGVjdGVkRHJhZnQgPSBkcmFmdENhcmRzW2Rpc3BsYXlJbmRleF07XG4gICAgaWYgKCFzZWxlY3RlZERyYWZ0KSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSB3YWl0IGZvciB0aGUgZHJhZnQgdG8gY29tcGxldGUgYmVmb3JlIHNlbGVjdGluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RlZFR5cGUsXG4gICAgICBjdXN0b21DYXJkVHlwZSxcbiAgICAgIHNlbGVjdGVkVG9uZSxcbiAgICAgIHByb21wdCxcbiAgICAgIHBlcnNvbmFsVHJhaXRzLFxuICAgICAgdG9GaWVsZCxcbiAgICAgIGZyb21GaWVsZCxcbiAgICAgIGZpbmFsQ2FyZE1lc3NhZ2UsXG4gICAgICBpc0hhbmR3cml0dGVuTWVzc2FnZSxcbiAgICAgIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSxcbiAgICAgIGN1c3RvbVN0eWxlRGVzY3JpcHRpb24sXG4gICAgICBpc0Zyb250QmFja09ubHksXG4gICAgICBzZWxlY3RlZEltYWdlTW9kZWwsXG4gICAgICBzZWxlY3RlZFBhcGVyU2l6ZSxcbiAgICAgIHVzZXJFbWFpbCxcbiAgICAgIHJlZmVyZW5jZUltYWdlVXJscyxcbiAgICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZyxcbiAgICAgIHN1YnNjcmliZVRvSm9iXG4gICAgfSA9IHByb3BzO1xuXG4gICAgLy8gU3RvcCBhbnkgZXhpc3RpbmcgdGltZXJzIGZpcnN0XG4gICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICBcbiAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQodHJ1ZSk7XG4gICAgc2V0SXNEcmFmdE1vZGUoZmFsc2UpOyAvLyBTd2l0Y2ggb3V0IG9mIGRyYWZ0IG1vZGUgZm9yIGZpbmFsIGdlbmVyYXRpb25cbiAgICBzZXRTZWxlY3RlZERyYWZ0SW5kZXgoZGlzcGxheUluZGV4KTtcbiAgICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmcoJ2ZpbmFsJyk7XG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi8J+OqCBDcmVhdGluZyB0aGUgY29tcGxldGUgY2FyZCBiYXNlZCBvbiB5b3VyIHNlbGVjdGVkIGZyb250IGNvdmVyLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpvYklkID0gdXVpZHY0KCk7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIHRoZSBtaXNzaW5nIHByb21wdHNcbiAgICAgIGNvbnN0IHN0b3JlZEZyb250Q292ZXJQcm9tcHQgPSBzZWxlY3RlZERyYWZ0LmdlbmVyYXRlZFByb21wdHM/LmZyb250Q292ZXI7XG4gICAgICBpZiAoIXN0b3JlZEZyb250Q292ZXJQcm9tcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0ZWQgZHJhZnQgaXMgbWlzc2luZyBmcm9udENvdmVyIHByb21wdFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2FyZFR5cGVGb3JQcm9tcHQgPSBzZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBjdXN0b21DYXJkVHlwZSA6IHNlbGVjdGVkVHlwZTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVG9uZU9iaiA9IGNhcmRUb25lcy5maW5kKHRvbmUgPT4gdG9uZS5pZCA9PT0gc2VsZWN0ZWRUb25lKTtcbiAgICAgIGNvbnN0IHRvbmVEZXNjcmlwdGlvbiA9IHNlbGVjdGVkVG9uZU9iaiA/IHNlbGVjdGVkVG9uZU9iai5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpIDogXCJoZWFydGZlbHQgYW5kIHNpbmNlcmVcIjtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVByb21wdCA9IHByb21wdC50cmltKCkgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmQgd2l0aCAke3RvbmVEZXNjcmlwdGlvbn0gc3R5bGVgO1xuICAgICAgXG4gICAgICBsZXQgbWVzc2FnZUNvbnRlbnQgPSBmaW5hbENhcmRNZXNzYWdlO1xuICAgICAgaWYgKGlzSGFuZHdyaXR0ZW5NZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50ID0gXCJbQmxhbmsgc3BhY2UgZm9yIGhhbmR3cml0dGVuIG1lc3NhZ2VdXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBzdHlsZSBmcm9tIHRoZSBzZWxlY3RlZCBkcmFmdFxuICAgICAgY29uc3QgZHJhZnRTdHlsZUluZm8gPSBzZWxlY3RlZERyYWZ0LnN0eWxlSW5mbztcbiAgICAgIGxldCBzZWxlY3RlZFN0eWxlO1xuICAgICAgaWYgKGRyYWZ0U3R5bGVJbmZvICYmIGRyYWZ0U3R5bGVJbmZvLnN0eWxlTmFtZSkge1xuICAgICAgICBzZWxlY3RlZFN0eWxlID0gYXJ0aXN0aWNTdHlsZXMuZmluZChzdHlsZSA9PiBzdHlsZS5pZCA9PT0gZHJhZnRTdHlsZUluZm8uc3R5bGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkU3R5bGUgPSBhcnRpc3RpY1N0eWxlcy5maW5kKHN0eWxlID0+IHN0eWxlLmlkID09PSBzZWxlY3RlZEFydGlzdGljU3R5bGUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2UgUHJvbXB0R2VuZXJhdG9yIGZvciBmaW5hbCBjYXJkIGZyb20gZHJhZnRcbiAgICAgIGNvbnN0IGZpbmFsRnJvbURyYWZ0Q29uZmlnOiBGaW5hbEZyb21EcmFmdENvbmZpZyA9IHtcbiAgICAgICAgZnJvbnRDb3ZlclByb21wdDogc3RvcmVkRnJvbnRDb3ZlclByb21wdCxcbiAgICAgICAgY2FyZFR5cGU6IHNlbGVjdGVkVHlwZSxcbiAgICAgICAgY3VzdG9tQ2FyZFR5cGU6IGN1c3RvbUNhcmRUeXBlLFxuICAgICAgICB0aGVtZTogZWZmZWN0aXZlUHJvbXB0LFxuICAgICAgICB0b25lOiBzZWxlY3RlZFRvbmUsXG4gICAgICAgIHRvbmVEZXNjcmlwdGlvbjogdG9uZURlc2NyaXB0aW9uLFxuICAgICAgICB0b0ZpZWxkOiB0b0ZpZWxkLFxuICAgICAgICBmcm9tRmllbGQ6IGZyb21GaWVsZCxcbiAgICAgICAgcmVsYXRpb25zaGlwRmllbGQ6IHByb3BzLnJlbGF0aW9uc2hpcEZpZWxkLFxuICAgICAgICBwZXJzb25hbFRyYWl0czogcHJvcHMucGVyc29uYWxUcmFpdHMsXG4gICAgICAgIHBob3RvUmVmZXJlbmNlczogcHJvcHMucGhvdG9SZWZlcmVuY2VzLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgaXNIYW5kd3JpdHRlbk1lc3NhZ2U6IGlzSGFuZHdyaXR0ZW5NZXNzYWdlLFxuICAgICAgICBhcnRpc3RpY1N0eWxlOiBzZWxlY3RlZFN0eWxlLFxuICAgICAgICBpc0Zyb250QmFja09ubHk6IGlzRnJvbnRCYWNrT25seVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZmluYWxQcm9tcHRzID0gYXdhaXQgUHJvbXB0R2VuZXJhdG9yLmdlbmVyYXRlRmluYWxGcm9tRHJhZnRQcm9tcHRzQ29tYmluZWQoZmluYWxGcm9tRHJhZnRDb25maWcpO1xuXG4gICAgICBpZiAoIWZpbmFsUHJvbXB0cyB8fCAhZmluYWxQcm9tcHRzLmZyb250Q292ZXIgfHwgIWZpbmFsUHJvbXB0cy5iYWNrQ292ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNvbXBsZXRlIHByb21wdHMgZm9yIGZpbmFsIGNhcmRcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByZXBhcmUgaW5wdXQgaW1hZ2VzIGZvciBmaW5hbCBnZW5lcmF0aW9uXG4gICAgICBjb25zdCBpbnB1dEltYWdlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRoZSBzZWxlY3RlZCBkcmFmdCdzIGZyb250IGNvdmVyIGFzIGEgcmVmZXJlbmNlIGltYWdlIGZvciB0aGUgZmluYWwgZnJvbnQgY292ZXJcbiAgICAgIGlmIChzZWxlY3RlZERyYWZ0LmZyb250Q292ZXIpIHtcbiAgICAgICAgaW5wdXRJbWFnZXMucHVzaChzZWxlY3RlZERyYWZ0LmZyb250Q292ZXIpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+WvO+4jyBBZGRpbmcgZHJhZnQgZnJvbnQgY292ZXIgYXMgcmVmZXJlbmNlIGZvciBmaW5hbCBmcm9udCBjb3ZlciBnZW5lcmF0aW9uJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFsc28gaW5jbHVkZSBhbnkgdXNlci11cGxvYWRlZCByZWZlcmVuY2UgaW1hZ2VzXG4gICAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJbWFnZU1vZGVsID09PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgICAgaW5wdXRJbWFnZXMucHVzaCguLi5yZWZlcmVuY2VJbWFnZVVybHMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2dlbmVyYXRlLWNhcmQtYXN5bmMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGpvYklkLFxuICAgICAgICAgIHByb21wdHM6IGZpbmFsUHJvbXB0cyxcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIHVzZXJOdW1iZXI6IFwiKzE3MTQ1OTg2MTA1XCIsXG4gICAgICAgICAgICBtb2RlbFZlcnNpb246IHNlbGVjdGVkSW1hZ2VNb2RlbCxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSk/LmFzcGVjdFJhdGlvIHx8IFwiOToxNlwiLFxuICAgICAgICAgICAgcXVhbGl0eTogXCJoaWdoXCIsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IFwianBlZ1wiLFxuICAgICAgICAgICAgb3V0cHV0Q29tcHJlc3Npb246IDEwMCxcbiAgICAgICAgICAgIG1vZGVyYXRpb246IFwibG93XCIsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBwYXBlclNpemVzLmZpbmQoc2l6ZSA9PiBzaXplLmlkID09PSBzZWxlY3RlZFBhcGVyU2l6ZSk/LmRpbWVuc2lvbnMgfHwgXCIxMDI0eDE1MzZcIixcbiAgICAgICAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgICAgIGNhcmRUeXBlOiBzZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBjdXN0b21DYXJkVHlwZSA6IHNlbGVjdGVkVHlwZSxcbiAgICAgICAgICAgIHRvRmllbGQsXG4gICAgICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgICAgICBpc0RyYWZ0TW9kZTogZmFsc2UsXG4gICAgICAgICAgICAuLi4oaW5wdXRJbWFnZXMubGVuZ3RoID4gMCAmJiB7IFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXM6IGlucHV0SW1hZ2VzLFxuICAgICAgICAgICAgICBpbnB1dF9pbWFnZXNfbW9kZTogXCJmcm9udF9jb3Zlcl9vbmx5XCIgIC8vIFVzZSBpbWFnZXMgYXMgcmVmZXJlbmNlIGZvciBmcm9udCBjb3ZlciBvbmx5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gJ3Byb2Nlc3NpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHN0YXJ0IGZpbmFsIGNhcmQgZ2VuZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBzZXRDdXJyZW50Sm9iSWQoam9iSWQpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIGpvYiBkYXRhIGZvciByZWNvdmVyeVxuICAgICAgY29uc3Qgam9iRGF0YSA9IHtcbiAgICAgICAgam9iSWQsXG4gICAgICAgIHNlbGVjdGVkRHJhZnRJbmRleDogZGlzcGxheUluZGV4LFxuICAgICAgICBjYXJkVHlwZTogc2VsZWN0ZWRUeXBlLFxuICAgICAgICBjdXN0b21DYXJkVHlwZSxcbiAgICAgICAgdG9uZTogc2VsZWN0ZWRUb25lLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIHBlcnNvbmFsVHJhaXRzLFxuICAgICAgICB0b0ZpZWxkLFxuICAgICAgICBmcm9tRmllbGQsXG4gICAgICAgIGZpbmFsQ2FyZE1lc3NhZ2UsXG4gICAgICAgIGlzSGFuZHdyaXR0ZW5NZXNzYWdlLFxuICAgICAgICBzZWxlY3RlZEFydGlzdGljU3R5bGUsXG4gICAgICAgIGlzRnJvbnRCYWNrT25seSxcbiAgICAgICAgc2VsZWN0ZWRQYXBlclNpemUsXG4gICAgICAgIHVzZXJFbWFpbCxcbiAgICAgICAgcmVmZXJlbmNlSW1hZ2VVcmxzXG4gICAgICB9O1xuICAgICAgcHJvcHMuc2F2ZUpvYlRvU3RvcmFnZShqb2JJZCwgam9iRGF0YSk7XG4gICAgICBcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoXCLwn46oIEdlbmVyYXRpbmcgaGlnaC1xdWFsaXR5IHZlcnNpb24gb2YgeW91ciBzZWxlY3RlZCBkZXNpZ24hXCIpO1xuICAgICAgXG4gICAgICAvLyBTdWJzY3JpYmUgdG8gV2ViU29ja2V0IHVwZGF0ZXNcbiAgICAgIHN1YnNjcmliZVRvSm9iKGpvYklkKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGaW5hbCBjYXJkIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgZmluYWwgY2FyZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQoZmFsc2UpO1xuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiXCIpO1xuICAgICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTsgLy8gQ2xlYXIgdGltZS1iYXNlZCBwcm9ncmVzcyBvbiBlcnJvclxuICAgIH1cbiAgfSwgW2RyYWZ0Q2FyZHMsIGlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCwgcHJvcHNdKTtcblxuICByZXR1cm4ge1xuICAgIGlzRHJhZnRNb2RlLFxuICAgIHNldElzRHJhZnRNb2RlLFxuICAgIGRyYWZ0Q2FyZHMsXG4gICAgc2V0RHJhZnRDYXJkcyxcbiAgICBzZWxlY3RlZERyYWZ0SW5kZXgsXG4gICAgc2V0U2VsZWN0ZWREcmFmdEluZGV4LFxuICAgIGlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCxcbiAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQsXG4gICAgcHJldmlld2luZ0RyYWZ0SW5kZXgsXG4gICAgc2V0UHJldmlld2luZ0RyYWZ0SW5kZXgsXG4gICAgZHJhZnRDb21wbGV0aW9uU2hvd24sXG4gICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24sXG4gICAgZHJhZnRDb21wbGV0aW9uQ291bnQsXG4gICAgc2V0RHJhZnRDb21wbGV0aW9uQ291bnQsXG4gICAgaGFuZGxlR2VuZXJhdGVEcmFmdENhcmRzLFxuICAgIGhhbmRsZUdlbmVyYXRlRmluYWxGcm9tRHJhZnQsXG4gICAgaXNHZW5lcmF0aW5nLFxuICAgIHNldElzR2VuZXJhdGluZyxcbiAgICBnZW5lcmF0aW9uUHJvZ3Jlc3MsXG4gICAgc2V0R2VuZXJhdGlvblByb2dyZXNzLFxuICAgIGdlbmVyYXRlZENhcmQsXG4gICAgc2V0R2VuZXJhdGVkQ2FyZCxcbiAgICBnZW5lcmF0ZWRDYXJkcyxcbiAgICBzZXRHZW5lcmF0ZWRDYXJkcyxcbiAgICBpc0NhcmRDb21wbGV0ZWQsXG4gICAgc2V0SXNDYXJkQ29tcGxldGVkLFxuICAgIGN1cnJlbnRKb2JJZCxcbiAgICBzZXRDdXJyZW50Sm9iSWRcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInRvYXN0IiwidjQiLCJ1dWlkdjQiLCJQcm9tcHRHZW5lcmF0b3IiLCJhcnRpc3RpY1N0eWxlcyIsInBhcGVyU2l6ZXMiLCJjYXJkVG9uZXMiLCJ1c2VEcmFmdEdlbmVyYXRpb24iLCJwcm9wcyIsImlzRHJhZnRNb2RlIiwic2V0SXNEcmFmdE1vZGUiLCJkcmFmdENhcmRzIiwic2V0RHJhZnRDYXJkcyIsInNlbGVjdGVkRHJhZnRJbmRleCIsInNldFNlbGVjdGVkRHJhZnRJbmRleCIsImlzR2VuZXJhdGluZ0ZpbmFsQ2FyZCIsInNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZCIsInByZXZpZXdpbmdEcmFmdEluZGV4Iiwic2V0UHJldmlld2luZ0RyYWZ0SW5kZXgiLCJkcmFmdENvbXBsZXRpb25TaG93biIsInNldERyYWZ0Q29tcGxldGlvblNob3duIiwiZHJhZnRDb21wbGV0aW9uQ291bnQiLCJzZXREcmFmdENvbXBsZXRpb25Db3VudCIsImlzR2VuZXJhdGluZyIsInNldElzR2VuZXJhdGluZyIsImdlbmVyYXRpb25Qcm9ncmVzcyIsInNldEdlbmVyYXRpb25Qcm9ncmVzcyIsImdlbmVyYXRlZENhcmQiLCJzZXRHZW5lcmF0ZWRDYXJkIiwiZ2VuZXJhdGVkQ2FyZHMiLCJzZXRHZW5lcmF0ZWRDYXJkcyIsImlzQ2FyZENvbXBsZXRlZCIsInNldElzQ2FyZENvbXBsZXRlZCIsImN1cnJlbnRKb2JJZCIsInNldEN1cnJlbnRKb2JJZCIsImhhbmRsZUdlbmVyYXRlRHJhZnRDYXJkcyIsInVzZXJFbWFpbCIsInNlbGVjdGVkQXJ0aXN0aWNTdHlsZSIsImN1c3RvbVN0eWxlRGVzY3JpcHRpb24iLCJyZWZlcmVuY2VJbWFnZVVybHMiLCJzZWxlY3RlZERyYWZ0TW9kZWwiLCJzZWxlY3RlZFR5cGUiLCJjdXN0b21DYXJkVHlwZSIsInNlbGVjdGVkVG9uZSIsInByb21wdCIsInBlcnNvbmFsVHJhaXRzIiwidG9GaWVsZCIsImZyb21GaWVsZCIsInNlbGVjdGVkUGFwZXJTaXplIiwiZmluYWxDYXJkTWVzc2FnZSIsImlzSGFuZHdyaXR0ZW5NZXNzYWdlIiwiaXNGcm9udEJhY2tPbmx5Iiwic2F2ZUpvYlRvU3RvcmFnZSIsInN1YnNjcmliZVRvSm9iIiwic3RhcnRFbGFwc2VkVGltZVRyYWNraW5nIiwidHJpbSIsImVycm9yIiwiZW1haWxSZWdleCIsInRlc3QiLCJsZW5ndGgiLCJzdG9wRWxhcHNlZFRpbWVUcmFja2luZyIsInVuc3Vic2NyaWJlRnJvbUFsbEpvYnMiLCJjb25zb2xlIiwibG9nIiwiY2FyZFR5cGVGb3JQcm9tcHQiLCJzZWxlY3RlZFRvbmVPYmoiLCJmaW5kIiwidG9uZSIsImlkIiwidG9uZURlc2NyaXB0aW9uIiwiZGVzY3JpcHRpb24iLCJ0b0xvd2VyQ2FzZSIsImVmZmVjdGl2ZVByb21wdCIsImRyYWZ0UHJvbWlzZXMiLCJBcnJheSIsImZyb20iLCJfIiwiaW5kZXgiLCJFcnJvciIsInN0eWxlT3ZlcnJpZGUiLCJ1bmRlZmluZWQiLCJzdHlsZUxhYmVsIiwicHJlZGVmaW5lZFN0eWxlcyIsInN0eWxlTGFiZWxzIiwic2VsZWN0ZWRTdHlsZSIsInN0eWxlIiwiZHJhZnRDb25maWciLCJjYXJkVHlwZSIsInRvbmVMYWJlbCIsImxhYmVsIiwidGhlbWUiLCJyZWxhdGlvbnNoaXBGaWVsZCIsImFydGlzdGljU3R5bGUiLCJwaG90b1JlZmVyZW5jZXMiLCJpc0RyYWZ0VmFyaWF0aW9uIiwidmFyaWF0aW9uSW5kZXgiLCJmcm9udENvdmVyUHJvbXB0IiwiZ2VuZXJhdGVDcmVhdGl2ZURyYWZ0UHJvbXB0Iiwiam9iSWQiLCJpbnB1dEltYWdlcyIsInB1c2giLCJyZXF1ZXN0UGF5bG9hZCIsInByb21wdHMiLCJmcm9udENvdmVyIiwiY29uZmlnIiwidXNlck51bWJlciIsIm1vZGVsVmVyc2lvbiIsImFzcGVjdFJhdGlvIiwic2l6ZSIsInF1YWxpdHkiLCJvdXRwdXRGb3JtYXQiLCJvdXRwdXRDb21wcmVzc2lvbiIsIm1vZGVyYXRpb24iLCJkaW1lbnNpb25zIiwiaW5wdXRfaW1hZ2VzIiwiaW5wdXRfaW1hZ2VzX21vZGUiLCJwcm9tcHRzRXhpc3QiLCJwcm9tcHRLZXlzIiwicGFwZXJTaXplIiwiZW1haWwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsIm1lc3NhZ2UiLCJpc0RyYWZ0IiwiZHJhZnRJbmRleCIsInN0eWxlSW5mbyIsInN0eWxlTmFtZSIsImdlbmVyYXRlZFByb21wdHMiLCJzdGFjayIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwiaGFuZGxlR2VuZXJhdGVGaW5hbEZyb21EcmFmdCIsImRpc3BsYXlJbmRleCIsInNlbGVjdGVkRHJhZnQiLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJzdG9yZWRGcm9udENvdmVyUHJvbXB0IiwibWVzc2FnZUNvbnRlbnQiLCJkcmFmdFN0eWxlSW5mbyIsImZpbmFsRnJvbURyYWZ0Q29uZmlnIiwiZmluYWxQcm9tcHRzIiwiZ2VuZXJhdGVGaW5hbEZyb21EcmFmdFByb21wdHNDb21iaW5lZCIsImJhY2tDb3ZlciIsImpvYkRhdGEiLCJzdWNjZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useDraftGeneration.ts\n"));

/***/ })

});
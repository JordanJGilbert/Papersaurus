"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardCache.ts":
/*!*******************************!*\
  !*** ./hooks/useCardCache.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardCache: function() { return /* binding */ useCardCache; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CACHE_KEY = \"vibecarding_template_cache\";\nconst IMAGE_CACHE_KEY = \"vibecarding_image_cache\";\nconst CACHE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst IMAGE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nconst BACKEND_API_BASE_URL = \"https://vibecarding.com\" || 0;\nconst MAX_CONCURRENT_IMAGES = 3; // Netflix-style: Very conservative concurrent loads\n// Use the regular list endpoint - it's fast enough and always current\nconst CARDS_LIST_URL = \"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list\");\n// Global cache state\nlet globalCache = null;\nlet isPreloading = false;\nconst cacheListeners = new Set();\nconst notifyListeners = ()=>{\n    cacheListeners.forEach((listener)=>listener());\n};\nconst useCardCache = ()=>{\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalCache);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Subscribe to cache updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updateCache = ()=>setCache(globalCache);\n        cacheListeners.add(updateCache);\n        return ()=>cacheListeners.delete(updateCache);\n    }, []);\n    // Load from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!globalCache) {\n            try {\n                const stored = localStorage.getItem(CACHE_KEY);\n                if (stored) {\n                    const parsed = JSON.parse(stored);\n                    const isExpired = Date.now() - parsed.lastFetched > CACHE_DURATION;\n                    if (!isExpired) {\n                        globalCache = parsed;\n                        setCache(parsed);\n                        console.log(\"\\uD83D\\uDCE6 Loaded cached template cards:\", parsed.cards.length);\n                    } else {\n                        localStorage.removeItem(CACHE_KEY);\n                        console.log(\"\\uD83D\\uDDD1️ Expired cache removed\");\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to load cache:\", error);\n                localStorage.removeItem(CACHE_KEY);\n            }\n        }\n    }, []);\n    const loadCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, search = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        // If we have complete cache and no search, return cached data immediately\n        if (!search && (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) && !reset) {\n            const startIndex = (page - 1) * 40;\n            const endIndex = startIndex + 40;\n            return globalCache.cards.slice(startIndex, endIndex);\n        }\n        // For searches or when no cache, fetch from list endpoint\n        if (!search && (reset || !globalCache)) {\n            try {\n                // Fetch all cards with a large per_page to get everything at once\n                const response = await fetch(\"\".concat(CARDS_LIST_URL, \"?per_page=1000&template_mode=true\"));\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data.status === \"success\" && data.cards && Array.isArray(data.cards)) {\n                        var _data_pagination;\n                        // Update global cache\n                        globalCache = {\n                            cards: data.cards,\n                            totalCount: ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.total) || data.cards.length,\n                            lastFetched: Date.now(),\n                            isComplete: true\n                        };\n                        // Save to localStorage\n                        try {\n                            localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                        } catch (error) {\n                            console.warn(\"Failed to save cache to localStorage:\", error);\n                        }\n                        notifyListeners();\n                        // Return requested page\n                        const startIndex = (page - 1) * 40;\n                        const endIndex = startIndex + 40;\n                        return data.cards.slice(startIndex, endIndex);\n                    }\n                }\n            } catch (error) {\n                console.warn(\"List endpoint failed, falling back to paginated API:\", error);\n            }\n        }\n        // Fallback to original paginated API\n        setIsLoading(true);\n        setError(null);\n        try {\n            const params = new URLSearchParams({\n                page: page.toString(),\n                per_page: \"40\",\n                ...search && {\n                    search\n                },\n                template_mode: \"true\"\n            });\n            const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?\").concat(params));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\") {\n                const newCards = data.cards;\n                // Update global cache for non-search queries\n                if (!search) {\n                    if (reset || !globalCache) {\n                        globalCache = {\n                            cards: newCards,\n                            totalCount: data.pagination.total,\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    } else {\n                        // Append to existing cache\n                        const existingIds = new Set(globalCache.cards.map((card)=>card.id));\n                        const uniqueNewCards = newCards.filter((card)=>!existingIds.has(card.id));\n                        globalCache = {\n                            ...globalCache,\n                            cards: [\n                                ...globalCache.cards,\n                                ...uniqueNewCards\n                            ],\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    }\n                    // Save to localStorage\n                    try {\n                        localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                    } catch (error) {\n                        console.warn(\"Failed to save cache to localStorage:\", error);\n                    }\n                    notifyListeners();\n                }\n                return newCards;\n            } else {\n                throw new Error(data.message || \"Failed to load cards\");\n            }\n        } catch (error) {\n            console.error(\"Error loading cards:\", error);\n            setError(error instanceof Error ? error.message : \"Failed to load cards\");\n            return [];\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    const preloadAllCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isPreloading) {\n            return;\n        }\n        // Check if we already have a complete cache that's fresh\n        if (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) {\n            const cacheAge = Date.now() - globalCache.lastFetched;\n            if (cacheAge < CACHE_DURATION) {\n                console.log(\"⚡ Using fresh cached template data:\", globalCache.cards.length, \"cards\");\n                // No image preloading - instant response like reference site\n                console.log(\"⚡ Using fresh cached data, no preloading needed\");\n                return;\n            }\n        }\n        isPreloading = true;\n        console.log(\"\\uD83D\\uDE80 Starting immediate template preload on page load...\");\n        try {\n            // Load all cards from static JSON endpoint (much faster!)\n            const response = await fetch(STATIC_CARDS_URL);\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.cards && Array.isArray(data.cards)) {\n                // Update global cache with all cards at once\n                globalCache = {\n                    cards: data.cards,\n                    totalCount: data.totalCount || data.cards.length,\n                    lastFetched: Date.now(),\n                    isComplete: true // We have all cards!\n                };\n                // Save to localStorage\n                try {\n                    localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                } catch (error) {\n                    console.warn(\"Failed to save cache to localStorage:\", error);\n                }\n                notifyListeners();\n                console.log(\"✅ Page load template preload complete:\", data.cards.length, \"cards\");\n                // Ultra-simple: No image preloading, let browser lazy loading handle it\n                console.log(\"✅ Cards loaded, letting browser handle image loading\");\n            }\n        } catch (error) {\n            console.error(\"❌ Static preload failed, falling back to paginated:\", error);\n            // Fallback to old method if static fails\n            await preloadAllCardsLegacy();\n        } finally{\n            isPreloading = false;\n        }\n    }, []);\n    // Legacy preload method as fallback\n    const preloadAllCardsLegacy = async ()=>{\n        try {\n            let page = 1;\n            let hasMore = true;\n            let allCards = [];\n            while(hasMore && page <= 5){\n                var _data_pagination;\n                const cards = await loadCards(page, \"\", page === 1);\n                allCards = page === 1 ? cards : [\n                    ...allCards,\n                    ...cards\n                ];\n                // Check if we have more pages\n                const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?page=\").concat(page, \"&per_page=40&template_mode=true\"));\n                const data = await response.json();\n                hasMore = ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.has_next) || false;\n                page++;\n            }\n            console.log(\"✅ Legacy preload complete:\", allCards.length, \"cards\");\n            await preloadImages(allCards.slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Legacy preload failed:\", error);\n        }\n    };\n    const preloadImages = async (cards)=>{\n        // Disabled for instant loading like reference site\n        console.log(\"\\uD83D\\uDE80 Skipping image preloading for instant response\");\n        return;\n    };\n    const getCachedCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, itemsPerPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n        if (!globalCache) return [];\n        const startIndex = (page - 1) * itemsPerPage;\n        const endIndex = startIndex + itemsPerPage;\n        return globalCache.cards.slice(startIndex, endIndex);\n    }, []);\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalCache = null;\n        localStorage.removeItem(CACHE_KEY);\n        setCache(null);\n        notifyListeners();\n    }, []);\n    return {\n        cache,\n        isLoading,\n        error,\n        loadCards,\n        preloadAllCards,\n        getCachedCards,\n        clearCache,\n        hasCache: !!globalCache,\n        isComplete: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) || false,\n        totalCards: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.totalCount) || 0\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRDYWNoZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFzQnpELE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGlCQUFpQixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQ3BELE1BQU1DLHVCQUF1QixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQzFELE1BQU1DLHVCQUF1QkMseUJBQXVDLElBQUk7QUFDeEUsTUFBTUcsd0JBQXdCLEdBQUcsb0RBQW9EO0FBRXJGLHNFQUFzRTtBQUN0RSxNQUFNQyxpQkFBaUIsR0FBd0IsT0FBckJMLHNCQUFxQjtBQUUvQyxxQkFBcUI7QUFDckIsSUFBSU0sY0FBZ0M7QUFDcEMsSUFBSUMsZUFBZTtBQUNuQixNQUFNQyxpQkFBa0MsSUFBSUM7QUFFNUMsTUFBTUMsa0JBQWtCO0lBQ3RCRixlQUFlRyxPQUFPLENBQUNDLENBQUFBLFdBQVlBO0FBQ3JDO0FBRU8sTUFBTUMsZUFBZTtJQUMxQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFtQmE7SUFDckQsTUFBTSxDQUFDVSxXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixPQUFPQyxTQUFTLEdBQUcxQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsNkJBQTZCO0lBQzdCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU0wQixjQUFjLElBQU1MLFNBQVNUO1FBQ25DRSxlQUFlYSxHQUFHLENBQUNEO1FBQ25CLE9BQU8sSUFBTVosZUFBZWMsTUFBTSxDQUFDRjtJQUNyQyxHQUFHLEVBQUU7SUFFTCxrQ0FBa0M7SUFDbEMxQixnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ1ksYUFBYTtZQUNoQixJQUFJO2dCQUNGLE1BQU1pQixTQUFTQyxhQUFhQyxPQUFPLENBQUM3QjtnQkFDcEMsSUFBSTJCLFFBQVE7b0JBQ1YsTUFBTUcsU0FBb0JDLEtBQUtDLEtBQUssQ0FBQ0w7b0JBQ3JDLE1BQU1NLFlBQVlDLEtBQUtDLEdBQUcsS0FBS0wsT0FBT00sV0FBVyxHQUFHbEM7b0JBRXBELElBQUksQ0FBQytCLFdBQVc7d0JBQ2R2QixjQUFjb0I7d0JBQ2RYLFNBQVNXO3dCQUNUTyxRQUFRQyxHQUFHLENBQUMsOENBQW9DUixPQUFPUyxLQUFLLENBQUNDLE1BQU07b0JBQ3JFLE9BQU87d0JBQ0xaLGFBQWFhLFVBQVUsQ0FBQ3pDO3dCQUN4QnFDLFFBQVFDLEdBQUcsQ0FBQztvQkFDZDtnQkFDRjtZQUNGLEVBQUUsT0FBT2hCLE9BQU87Z0JBQ2RlLFFBQVFmLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUN2Q00sYUFBYWEsVUFBVSxDQUFDekM7WUFDMUI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU0wQyxZQUFZM0Msa0RBQVdBLENBQUM7WUFBTzRDLHdFQUFlLEdBQUdDLDBFQUFpQixJQUFJQyx5RUFBaUI7UUFDM0YsMEVBQTBFO1FBQzFFLElBQUksQ0FBQ0QsV0FBVWxDLHdCQUFBQSxrQ0FBQUEsWUFBYW9DLFVBQVUsS0FBSSxDQUFDRCxPQUFPO1lBQ2hELE1BQU1FLGFBQWEsQ0FBQ0osT0FBTyxLQUFLO1lBQ2hDLE1BQU1LLFdBQVdELGFBQWE7WUFDOUIsT0FBT3JDLFlBQVk2QixLQUFLLENBQUNVLEtBQUssQ0FBQ0YsWUFBWUM7UUFDN0M7UUFFQSwwREFBMEQ7UUFDMUQsSUFBSSxDQUFDSixVQUFXQyxDQUFBQSxTQUFTLENBQUNuQyxXQUFVLEdBQUk7WUFDdEMsSUFBSTtnQkFDRixrRUFBa0U7Z0JBQ2xFLE1BQU13QyxXQUFXLE1BQU1DLE1BQU0sR0FBa0IsT0FBZjFDLGdCQUFlO2dCQUMvQyxJQUFJeUMsU0FBU0UsRUFBRSxFQUFFO29CQUNmLE1BQU1DLE9BQU8sTUFBTUgsU0FBU0ksSUFBSTtvQkFDaEMsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLGFBQWFGLEtBQUtkLEtBQUssSUFBSWlCLE1BQU1DLE9BQU8sQ0FBQ0osS0FBS2QsS0FBSyxHQUFHOzRCQUkxRGM7d0JBSGQsc0JBQXNCO3dCQUN0QjNDLGNBQWM7NEJBQ1o2QixPQUFPYyxLQUFLZCxLQUFLOzRCQUNqQm1CLFlBQVlMLEVBQUFBLG1CQUFBQSxLQUFLTSxVQUFVLGNBQWZOLHVDQUFBQSxpQkFBaUJPLEtBQUssS0FBSVAsS0FBS2QsS0FBSyxDQUFDQyxNQUFNOzRCQUN2REosYUFBYUYsS0FBS0MsR0FBRzs0QkFDckJXLFlBQVk7d0JBQ2Q7d0JBRUEsdUJBQXVCO3dCQUN2QixJQUFJOzRCQUNGbEIsYUFBYWlDLE9BQU8sQ0FBQzdELFdBQVcrQixLQUFLK0IsU0FBUyxDQUFDcEQ7d0JBQ2pELEVBQUUsT0FBT1ksT0FBTzs0QkFDZGUsUUFBUTBCLElBQUksQ0FBQyx5Q0FBeUN6Qzt3QkFDeEQ7d0JBRUFSO3dCQUVBLHdCQUF3Qjt3QkFDeEIsTUFBTWlDLGFBQWEsQ0FBQ0osT0FBTyxLQUFLO3dCQUNoQyxNQUFNSyxXQUFXRCxhQUFhO3dCQUM5QixPQUFPTSxLQUFLZCxLQUFLLENBQUNVLEtBQUssQ0FBQ0YsWUFBWUM7b0JBQ3RDO2dCQUNGO1lBQ0YsRUFBRSxPQUFPMUIsT0FBTztnQkFDZGUsUUFBUTBCLElBQUksQ0FBQyx3REFBd0R6QztZQUN2RTtRQUNGO1FBRUEscUNBQXFDO1FBQ3JDRCxhQUFhO1FBQ2JFLFNBQVM7UUFFVCxJQUFJO1lBQ0YsTUFBTXlDLFNBQVMsSUFBSUMsZ0JBQWdCO2dCQUNqQ3RCLE1BQU1BLEtBQUt1QixRQUFRO2dCQUNuQkMsVUFBVTtnQkFDVixHQUFJdkIsVUFBVTtvQkFBRUE7Z0JBQU8sQ0FBQztnQkFDeEJ3QixlQUFlO1lBQ2pCO1lBRUEsTUFBTWxCLFdBQVcsTUFBTUMsTUFBTSxHQUEwQ2EsT0FBdkM1RCxzQkFBcUIsb0JBQXlCLE9BQVA0RDtZQUN2RSxJQUFJLENBQUNkLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJaUIsTUFBTSxRQUE0Qm5CLE9BQXBCQSxTQUFTSyxNQUFNLEVBQUMsTUFBd0IsT0FBcEJMLFNBQVNvQixVQUFVO1lBQ2pFO1lBRUEsTUFBTWpCLE9BQU8sTUFBTUgsU0FBU0ksSUFBSTtZQUVoQyxJQUFJRCxLQUFLRSxNQUFNLEtBQUssV0FBVztnQkFDN0IsTUFBTWdCLFdBQVdsQixLQUFLZCxLQUFLO2dCQUUzQiw2Q0FBNkM7Z0JBQzdDLElBQUksQ0FBQ0ssUUFBUTtvQkFDWCxJQUFJQyxTQUFTLENBQUNuQyxhQUFhO3dCQUN6QkEsY0FBYzs0QkFDWjZCLE9BQU9nQzs0QkFDUGIsWUFBWUwsS0FBS00sVUFBVSxDQUFDQyxLQUFLOzRCQUNqQ3hCLGFBQWFGLEtBQUtDLEdBQUc7NEJBQ3JCVyxZQUFZLENBQUNPLEtBQUtNLFVBQVUsQ0FBQ2EsUUFBUTt3QkFDdkM7b0JBQ0YsT0FBTzt3QkFDTCwyQkFBMkI7d0JBQzNCLE1BQU1DLGNBQWMsSUFBSTVELElBQUlILFlBQVk2QixLQUFLLENBQUNtQyxHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLEVBQUU7d0JBQ2pFLE1BQU1DLGlCQUFpQk4sU0FBU08sTUFBTSxDQUFDSCxDQUFBQSxPQUFRLENBQUNGLFlBQVlNLEdBQUcsQ0FBQ0osS0FBS0MsRUFBRTt3QkFFdkVsRSxjQUFjOzRCQUNaLEdBQUdBLFdBQVc7NEJBQ2Q2QixPQUFPO21DQUFJN0IsWUFBWTZCLEtBQUs7bUNBQUtzQzs2QkFBZTs0QkFDaER6QyxhQUFhRixLQUFLQyxHQUFHOzRCQUNyQlcsWUFBWSxDQUFDTyxLQUFLTSxVQUFVLENBQUNhLFFBQVE7d0JBQ3ZDO29CQUNGO29CQUVBLHVCQUF1QjtvQkFDdkIsSUFBSTt3QkFDRjVDLGFBQWFpQyxPQUFPLENBQUM3RCxXQUFXK0IsS0FBSytCLFNBQVMsQ0FBQ3BEO29CQUNqRCxFQUFFLE9BQU9ZLE9BQU87d0JBQ2RlLFFBQVEwQixJQUFJLENBQUMseUNBQXlDekM7b0JBQ3hEO29CQUVBUjtnQkFDRjtnQkFFQSxPQUFPeUQ7WUFDVCxPQUFPO2dCQUNMLE1BQU0sSUFBSUYsTUFBTWhCLEtBQUsyQixPQUFPLElBQUk7WUFDbEM7UUFDRixFQUFFLE9BQU8xRCxPQUFPO1lBQ2RlLFFBQVFmLEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDQyxTQUFTRCxpQkFBaUIrQyxRQUFRL0MsTUFBTTBELE9BQU8sR0FBRztZQUNsRCxPQUFPLEVBQUU7UUFDWCxTQUFVO1lBQ1IzRCxhQUFhO1FBQ2Y7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNNEQsa0JBQWtCbEYsa0RBQVdBLENBQUM7UUFDbEMsSUFBSVksY0FBYztZQUNoQjtRQUNGO1FBRUEseURBQXlEO1FBQ3pELElBQUlELHdCQUFBQSxrQ0FBQUEsWUFBYW9DLFVBQVUsRUFBRTtZQUMzQixNQUFNb0MsV0FBV2hELEtBQUtDLEdBQUcsS0FBS3pCLFlBQVkwQixXQUFXO1lBQ3JELElBQUk4QyxXQUFXaEYsZ0JBQWdCO2dCQUM3Qm1DLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUM1QixZQUFZNkIsS0FBSyxDQUFDQyxNQUFNLEVBQUU7Z0JBQzdFLDZEQUE2RDtnQkFDN0RILFFBQVFDLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1FBQ0Y7UUFFQTNCLGVBQWU7UUFDZjBCLFFBQVFDLEdBQUcsQ0FBQztRQUVaLElBQUk7WUFDRiwwREFBMEQ7WUFDMUQsTUFBTVksV0FBVyxNQUFNQyxNQUFNZ0M7WUFDN0IsSUFBSSxDQUFDakMsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlpQixNQUFNLFFBQTRCbkIsT0FBcEJBLFNBQVNLLE1BQU0sRUFBQyxNQUF3QixPQUFwQkwsU0FBU29CLFVBQVU7WUFDakU7WUFFQSxNQUFNakIsT0FBTyxNQUFNSCxTQUFTSSxJQUFJO1lBQ2hDLElBQUlELEtBQUtkLEtBQUssSUFBSWlCLE1BQU1DLE9BQU8sQ0FBQ0osS0FBS2QsS0FBSyxHQUFHO2dCQUMzQyw2Q0FBNkM7Z0JBQzdDN0IsY0FBYztvQkFDWjZCLE9BQU9jLEtBQUtkLEtBQUs7b0JBQ2pCbUIsWUFBWUwsS0FBS0ssVUFBVSxJQUFJTCxLQUFLZCxLQUFLLENBQUNDLE1BQU07b0JBQ2hESixhQUFhRixLQUFLQyxHQUFHO29CQUNyQlcsWUFBWSxLQUFLLHFCQUFxQjtnQkFDeEM7Z0JBRUEsdUJBQXVCO2dCQUN2QixJQUFJO29CQUNGbEIsYUFBYWlDLE9BQU8sQ0FBQzdELFdBQVcrQixLQUFLK0IsU0FBUyxDQUFDcEQ7Z0JBQ2pELEVBQUUsT0FBT1ksT0FBTztvQkFDZGUsUUFBUTBCLElBQUksQ0FBQyx5Q0FBeUN6QztnQkFDeEQ7Z0JBRUFSO2dCQUVBdUIsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ2UsS0FBS2QsS0FBSyxDQUFDQyxNQUFNLEVBQUU7Z0JBRXpFLHdFQUF3RTtnQkFDeEVILFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBRUYsRUFBRSxPQUFPaEIsT0FBTztZQUNkZSxRQUFRZixLQUFLLENBQUMsdURBQXVEQTtZQUNyRSx5Q0FBeUM7WUFDekMsTUFBTThEO1FBQ1IsU0FBVTtZQUNSekUsZUFBZTtRQUNqQjtJQUNGLEdBQUcsRUFBRTtJQUVMLG9DQUFvQztJQUNwQyxNQUFNeUUsd0JBQXdCO1FBQzVCLElBQUk7WUFDRixJQUFJekMsT0FBTztZQUNYLElBQUkwQyxVQUFVO1lBQ2QsSUFBSUMsV0FBMEIsRUFBRTtZQUVoQyxNQUFPRCxXQUFXMUMsUUFBUSxFQUFHO29CQU9qQlU7Z0JBTlYsTUFBTWQsUUFBUSxNQUFNRyxVQUFVQyxNQUFNLElBQUlBLFNBQVM7Z0JBQ2pEMkMsV0FBVzNDLFNBQVMsSUFBSUosUUFBUTt1QkFBSStDO3VCQUFhL0M7aUJBQU07Z0JBRXZELDhCQUE4QjtnQkFDOUIsTUFBTVcsV0FBVyxNQUFNQyxNQUFNLEdBQStDUixPQUE1Q3ZDLHNCQUFxQix5QkFBNEIsT0FBTHVDLE1BQUs7Z0JBQ2pGLE1BQU1VLE9BQU8sTUFBTUgsU0FBU0ksSUFBSTtnQkFDaEMrQixVQUFVaEMsRUFBQUEsbUJBQUFBLEtBQUtNLFVBQVUsY0FBZk4sdUNBQUFBLGlCQUFpQm1CLFFBQVEsS0FBSTtnQkFDdkM3QjtZQUNGO1lBRUFOLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEJnRCxTQUFTOUMsTUFBTSxFQUFFO1lBQzNELE1BQU0rQyxjQUFjRCxTQUFTckMsS0FBSyxDQUFDLEdBQUc7UUFFeEMsRUFBRSxPQUFPM0IsT0FBTztZQUNkZSxRQUFRZixLQUFLLENBQUMsNEJBQTRCQTtRQUM1QztJQUNGO0lBRUEsTUFBTWlFLGdCQUFnQixPQUFPaEQ7UUFDM0IsbURBQW1EO1FBQ25ERixRQUFRQyxHQUFHLENBQUM7UUFDWjtJQUNGO0lBRUEsTUFBTWtELGlCQUFpQnpGLGtEQUFXQSxDQUFDO1lBQUM0Qyx3RUFBZSxHQUFHOEMsZ0ZBQXVCO1FBQzNFLElBQUksQ0FBQy9FLGFBQWEsT0FBTyxFQUFFO1FBRTNCLE1BQU1xQyxhQUFhLENBQUNKLE9BQU8sS0FBSzhDO1FBQ2hDLE1BQU16QyxXQUFXRCxhQUFhMEM7UUFDOUIsT0FBTy9FLFlBQVk2QixLQUFLLENBQUNVLEtBQUssQ0FBQ0YsWUFBWUM7SUFDN0MsR0FBRyxFQUFFO0lBRUwsTUFBTTBDLGFBQWEzRixrREFBV0EsQ0FBQztRQUM3QlcsY0FBYztRQUNka0IsYUFBYWEsVUFBVSxDQUFDekM7UUFDeEJtQixTQUFTO1FBQ1RMO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMSTtRQUNBRTtRQUNBRTtRQUNBb0I7UUFDQXVDO1FBQ0FPO1FBQ0FFO1FBQ0FDLFVBQVUsQ0FBQyxDQUFDakY7UUFDWm9DLFlBQVlwQyxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFvQyxVQUFVLEtBQUk7UUFDdkM4QyxZQUFZbEYsQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhZ0QsVUFBVSxLQUFJO0lBQ3pDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VDYXJkQ2FjaGUudHM/ZGM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIEdhbGxlcnlDYXJkIHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGZyb250Q292ZXI6IHN0cmluZztcbiAgYmFja0NvdmVyPzogc3RyaW5nO1xuICBsZWZ0UGFnZT86IHN0cmluZztcbiAgcmlnaHRQYWdlPzogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IG51bWJlcjtcbiAgY3JlYXRlZEF0Rm9ybWF0dGVkOiBzdHJpbmc7XG4gIHNoYXJlVXJsPzogc3RyaW5nO1xuICBoYXNJbWFnZXM6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDYXJkQ2FjaGUge1xuICBjYXJkczogR2FsbGVyeUNhcmRbXTtcbiAgdG90YWxDb3VudDogbnVtYmVyO1xuICBsYXN0RmV0Y2hlZDogbnVtYmVyO1xuICBpc0NvbXBsZXRlOiBib29sZWFuO1xufVxuXG5jb25zdCBDQUNIRV9LRVkgPSAndmliZWNhcmRpbmdfdGVtcGxhdGVfY2FjaGUnO1xuY29uc3QgSU1BR0VfQ0FDSEVfS0VZID0gJ3ZpYmVjYXJkaW5nX2ltYWdlX2NhY2hlJztcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcbmNvbnN0IElNQUdFX0NBQ0hFX0RVUkFUSU9OID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcbmNvbnN0IEJBQ0tFTkRfQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9BUElfVVJMIHx8ICdodHRwczovL3ZpYmVjYXJkaW5nLmNvbSc7XG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9JTUFHRVMgPSAzOyAvLyBOZXRmbGl4LXN0eWxlOiBWZXJ5IGNvbnNlcnZhdGl2ZSBjb25jdXJyZW50IGxvYWRzXG5cbi8vIFVzZSB0aGUgcmVndWxhciBsaXN0IGVuZHBvaW50IC0gaXQncyBmYXN0IGVub3VnaCBhbmQgYWx3YXlzIGN1cnJlbnRcbmNvbnN0IENBUkRTX0xJU1RfVVJMID0gYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L2FwaS9jYXJkcy9saXN0YDtcblxuLy8gR2xvYmFsIGNhY2hlIHN0YXRlXG5sZXQgZ2xvYmFsQ2FjaGU6IENhcmRDYWNoZSB8IG51bGwgPSBudWxsO1xubGV0IGlzUHJlbG9hZGluZyA9IGZhbHNlO1xuY29uc3QgY2FjaGVMaXN0ZW5lcnM6IFNldDwoKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcblxuY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICBjYWNoZUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNhcmRDYWNoZSA9ICgpID0+IHtcbiAgY29uc3QgW2NhY2hlLCBzZXRDYWNoZV0gPSB1c2VTdGF0ZTxDYXJkQ2FjaGUgfCBudWxsPihnbG9iYWxDYWNoZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gU3Vic2NyaWJlIHRvIGNhY2hlIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVDYWNoZSA9ICgpID0+IHNldENhY2hlKGdsb2JhbENhY2hlKTtcbiAgICBjYWNoZUxpc3RlbmVycy5hZGQodXBkYXRlQ2FjaGUpO1xuICAgIHJldHVybiAoKSA9PiBjYWNoZUxpc3RlbmVycy5kZWxldGUodXBkYXRlQ2FjaGUpO1xuICB9LCBbXSk7XG5cbiAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZ2xvYmFsQ2FjaGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKENBQ0hFX0tFWSk7XG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQ6IENhcmRDYWNoZSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBjb25zdCBpc0V4cGlyZWQgPSBEYXRlLm5vdygpIC0gcGFyc2VkLmxhc3RGZXRjaGVkID4gQ0FDSEVfRFVSQVRJT047XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0gcGFyc2VkO1xuICAgICAgICAgICAgc2V0Q2FjaGUocGFyc2VkKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIExvYWRlZCBjYWNoZWQgdGVtcGxhdGUgY2FyZHM6JywgcGFyc2VkLmNhcmRzLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKENBQ0hFX0tFWSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBFeHBpcmVkIGNhY2hlIHJlbW92ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNhY2hlOicsIGVycm9yKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBsb2FkQ2FyZHMgPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyID0gMSwgc2VhcmNoOiBzdHJpbmcgPSAnJywgcmVzZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8R2FsbGVyeUNhcmRbXT4gPT4ge1xuICAgIC8vIElmIHdlIGhhdmUgY29tcGxldGUgY2FjaGUgYW5kIG5vIHNlYXJjaCwgcmV0dXJuIGNhY2hlZCBkYXRhIGltbWVkaWF0ZWx5XG4gICAgaWYgKCFzZWFyY2ggJiYgZ2xvYmFsQ2FjaGU/LmlzQ29tcGxldGUgJiYgIXJlc2V0KSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIDQwO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgNDA7XG4gICAgICByZXR1cm4gZ2xvYmFsQ2FjaGUuY2FyZHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIEZvciBzZWFyY2hlcyBvciB3aGVuIG5vIGNhY2hlLCBmZXRjaCBmcm9tIGxpc3QgZW5kcG9pbnRcbiAgICBpZiAoIXNlYXJjaCAmJiAocmVzZXQgfHwgIWdsb2JhbENhY2hlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIGNhcmRzIHdpdGggYSBsYXJnZSBwZXJfcGFnZSB0byBnZXQgZXZlcnl0aGluZyBhdCBvbmNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7Q0FSRFNfTElTVF9VUkx9P3Blcl9wYWdlPTEwMDAmdGVtcGxhdGVfbW9kZT10cnVlYCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgZGF0YS5jYXJkcyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY2FyZHMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIGNhY2hlXG4gICAgICAgICAgICBnbG9iYWxDYWNoZSA9IHtcbiAgICAgICAgICAgICAgY2FyZHM6IGRhdGEuY2FyZHMsXG4gICAgICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEucGFnaW5hdGlvbj8udG90YWwgfHwgZGF0YS5jYXJkcy5sZW5ndGgsXG4gICAgICAgICAgICAgIGxhc3RGZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHJlcXVlc3RlZCBwYWdlXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIDQwO1xuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgNDA7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5jYXJkcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xpc3QgZW5kcG9pbnQgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gcGFnaW5hdGVkIEFQSTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgcGFnaW5hdGVkIEFQSVxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgcGFnZTogcGFnZS50b1N0cmluZygpLFxuICAgICAgICBwZXJfcGFnZTogJzQwJyxcbiAgICAgICAgLi4uKHNlYXJjaCAmJiB7IHNlYXJjaCB9KSxcbiAgICAgICAgdGVtcGxhdGVfbW9kZTogJ3RydWUnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQUNLRU5EX0FQSV9CQVNFX1VSTH0vYXBpL2NhcmRzL2xpc3Q/JHtwYXJhbXN9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgY29uc3QgbmV3Q2FyZHMgPSBkYXRhLmNhcmRzIGFzIEdhbGxlcnlDYXJkW107XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIGNhY2hlIGZvciBub24tc2VhcmNoIHF1ZXJpZXNcbiAgICAgICAgaWYgKCFzZWFyY2gpIHtcbiAgICAgICAgICBpZiAocmVzZXQgfHwgIWdsb2JhbENhY2hlKSB7XG4gICAgICAgICAgICBnbG9iYWxDYWNoZSA9IHtcbiAgICAgICAgICAgICAgY2FyZHM6IG5ld0NhcmRzLFxuICAgICAgICAgICAgICB0b3RhbENvdW50OiBkYXRhLnBhZ2luYXRpb24udG90YWwsXG4gICAgICAgICAgICAgIGxhc3RGZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBpc0NvbXBsZXRlOiAhZGF0YS5wYWdpbmF0aW9uLmhhc19uZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcgY2FjaGVcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChnbG9iYWxDYWNoZS5jYXJkcy5tYXAoY2FyZCA9PiBjYXJkLmlkKSk7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOZXdDYXJkcyA9IG5ld0NhcmRzLmZpbHRlcihjYXJkID0+ICFleGlzdGluZ0lkcy5oYXMoY2FyZC5pZCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnbG9iYWxDYWNoZSA9IHtcbiAgICAgICAgICAgICAgLi4uZ2xvYmFsQ2FjaGUsXG4gICAgICAgICAgICAgIGNhcmRzOiBbLi4uZ2xvYmFsQ2FjaGUuY2FyZHMsIC4uLnVuaXF1ZU5ld0NhcmRzXSxcbiAgICAgICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIGlzQ29tcGxldGU6ICFkYXRhLnBhZ2luYXRpb24uaGFzX25leHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIGNhY2hlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3Q2FyZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gbG9hZCBjYXJkcycpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNhcmRzOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBsb2FkIGNhcmRzJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgcHJlbG9hZEFsbENhcmRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc1ByZWxvYWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgY29tcGxldGUgY2FjaGUgdGhhdCdzIGZyZXNoXG4gICAgaWYgKGdsb2JhbENhY2hlPy5pc0NvbXBsZXRlKSB7XG4gICAgICBjb25zdCBjYWNoZUFnZSA9IERhdGUubm93KCkgLSBnbG9iYWxDYWNoZS5sYXN0RmV0Y2hlZDtcbiAgICAgIGlmIChjYWNoZUFnZSA8IENBQ0hFX0RVUkFUSU9OKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgVXNpbmcgZnJlc2ggY2FjaGVkIHRlbXBsYXRlIGRhdGE6JywgZ2xvYmFsQ2FjaGUuY2FyZHMubGVuZ3RoLCAnY2FyZHMnKTtcbiAgICAgICAgLy8gTm8gaW1hZ2UgcHJlbG9hZGluZyAtIGluc3RhbnQgcmVzcG9uc2UgbGlrZSByZWZlcmVuY2Ugc2l0ZVxuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFVzaW5nIGZyZXNoIGNhY2hlZCBkYXRhLCBubyBwcmVsb2FkaW5nIG5lZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNQcmVsb2FkaW5nID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBpbW1lZGlhdGUgdGVtcGxhdGUgcHJlbG9hZCBvbiBwYWdlIGxvYWQuLi4nKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIGFsbCBjYXJkcyBmcm9tIHN0YXRpYyBKU09OIGVuZHBvaW50IChtdWNoIGZhc3RlciEpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFNUQVRJQ19DQVJEU19VUkwpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoZGF0YS5jYXJkcyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY2FyZHMpKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgY2FjaGUgd2l0aCBhbGwgY2FyZHMgYXQgb25jZVxuICAgICAgICBnbG9iYWxDYWNoZSA9IHtcbiAgICAgICAgICBjYXJkczogZGF0YS5jYXJkcyxcbiAgICAgICAgICB0b3RhbENvdW50OiBkYXRhLnRvdGFsQ291bnQgfHwgZGF0YS5jYXJkcy5sZW5ndGgsXG4gICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZSAvLyBXZSBoYXZlIGFsbCBjYXJkcyFcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZ2xvYmFsQ2FjaGUpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIGNhY2hlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUGFnZSBsb2FkIHRlbXBsYXRlIHByZWxvYWQgY29tcGxldGU6JywgZGF0YS5jYXJkcy5sZW5ndGgsICdjYXJkcycpO1xuICAgICAgICBcbiAgICAgICAgLy8gVWx0cmEtc2ltcGxlOiBObyBpbWFnZSBwcmVsb2FkaW5nLCBsZXQgYnJvd3NlciBsYXp5IGxvYWRpbmcgaGFuZGxlIGl0XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ2FyZHMgbG9hZGVkLCBsZXR0aW5nIGJyb3dzZXIgaGFuZGxlIGltYWdlIGxvYWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgU3RhdGljIHByZWxvYWQgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gcGFnaW5hdGVkOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG9sZCBtZXRob2QgaWYgc3RhdGljIGZhaWxzXG4gICAgICBhd2FpdCBwcmVsb2FkQWxsQ2FyZHNMZWdhY3koKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNQcmVsb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gTGVnYWN5IHByZWxvYWQgbWV0aG9kIGFzIGZhbGxiYWNrXG4gIGNvbnN0IHByZWxvYWRBbGxDYXJkc0xlZ2FjeSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHBhZ2UgPSAxO1xuICAgICAgbGV0IGhhc01vcmUgPSB0cnVlO1xuICAgICAgbGV0IGFsbENhcmRzOiBHYWxsZXJ5Q2FyZFtdID0gW107XG5cbiAgICAgIHdoaWxlIChoYXNNb3JlICYmIHBhZ2UgPD0gNSkgeyAvLyBMaW1pdCB0byA1IHBhZ2VzIG1heFxuICAgICAgICBjb25zdCBjYXJkcyA9IGF3YWl0IGxvYWRDYXJkcyhwYWdlLCAnJywgcGFnZSA9PT0gMSk7XG4gICAgICAgIGFsbENhcmRzID0gcGFnZSA9PT0gMSA/IGNhcmRzIDogWy4uLmFsbENhcmRzLCAuLi5jYXJkc107XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG1vcmUgcGFnZXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQUNLRU5EX0FQSV9CQVNFX1VSTH0vYXBpL2NhcmRzL2xpc3Q/cGFnZT0ke3BhZ2V9JnBlcl9wYWdlPTQwJnRlbXBsYXRlX21vZGU9dHJ1ZWApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBoYXNNb3JlID0gZGF0YS5wYWdpbmF0aW9uPy5oYXNfbmV4dCB8fCBmYWxzZTtcbiAgICAgICAgcGFnZSsrO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIExlZ2FjeSBwcmVsb2FkIGNvbXBsZXRlOicsIGFsbENhcmRzLmxlbmd0aCwgJ2NhcmRzJyk7XG4gICAgICBhd2FpdCBwcmVsb2FkSW1hZ2VzKGFsbENhcmRzLnNsaWNlKDAsIDIwKSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIExlZ2FjeSBwcmVsb2FkIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHByZWxvYWRJbWFnZXMgPSBhc3luYyAoY2FyZHM6IEdhbGxlcnlDYXJkW10pID0+IHtcbiAgICAvLyBEaXNhYmxlZCBmb3IgaW5zdGFudCBsb2FkaW5nIGxpa2UgcmVmZXJlbmNlIHNpdGVcbiAgICBjb25zb2xlLmxvZygn8J+agCBTa2lwcGluZyBpbWFnZSBwcmVsb2FkaW5nIGZvciBpbnN0YW50IHJlc3BvbnNlJyk7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIGNvbnN0IGdldENhY2hlZENhcmRzID0gdXNlQ2FsbGJhY2soKHBhZ2U6IG51bWJlciA9IDEsIGl0ZW1zUGVyUGFnZTogbnVtYmVyID0gNDApOiBHYWxsZXJ5Q2FyZFtdID0+IHtcbiAgICBpZiAoIWdsb2JhbENhY2hlKSByZXR1cm4gW107XG4gICAgXG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IChwYWdlIC0gMSkgKiBpdGVtc1BlclBhZ2U7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgaXRlbXNQZXJQYWdlO1xuICAgIHJldHVybiBnbG9iYWxDYWNoZS5jYXJkcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhckNhY2hlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGdsb2JhbENhY2hlID0gbnVsbDtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShDQUNIRV9LRVkpO1xuICAgIHNldENhY2hlKG51bGwpO1xuICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYWNoZSxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgbG9hZENhcmRzLFxuICAgIHByZWxvYWRBbGxDYXJkcyxcbiAgICBnZXRDYWNoZWRDYXJkcyxcbiAgICBjbGVhckNhY2hlLFxuICAgIGhhc0NhY2hlOiAhIWdsb2JhbENhY2hlLFxuICAgIGlzQ29tcGxldGU6IGdsb2JhbENhY2hlPy5pc0NvbXBsZXRlIHx8IGZhbHNlLFxuICAgIHRvdGFsQ2FyZHM6IGdsb2JhbENhY2hlPy50b3RhbENvdW50IHx8IDBcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJDQUNIRV9LRVkiLCJJTUFHRV9DQUNIRV9LRVkiLCJDQUNIRV9EVVJBVElPTiIsIklNQUdFX0NBQ0hFX0RVUkFUSU9OIiwiQkFDS0VORF9BUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9BUElfVVJMIiwiTUFYX0NPTkNVUlJFTlRfSU1BR0VTIiwiQ0FSRFNfTElTVF9VUkwiLCJnbG9iYWxDYWNoZSIsImlzUHJlbG9hZGluZyIsImNhY2hlTGlzdGVuZXJzIiwiU2V0Iiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwidXNlQ2FyZENhY2hlIiwiY2FjaGUiLCJzZXRDYWNoZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ1cGRhdGVDYWNoZSIsImFkZCIsImRlbGV0ZSIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJpc0V4cGlyZWQiLCJEYXRlIiwibm93IiwibGFzdEZldGNoZWQiLCJjb25zb2xlIiwibG9nIiwiY2FyZHMiLCJsZW5ndGgiLCJyZW1vdmVJdGVtIiwibG9hZENhcmRzIiwicGFnZSIsInNlYXJjaCIsInJlc2V0IiwiaXNDb21wbGV0ZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInNsaWNlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiZGF0YSIsImpzb24iLCJzdGF0dXMiLCJBcnJheSIsImlzQXJyYXkiLCJ0b3RhbENvdW50IiwicGFnaW5hdGlvbiIsInRvdGFsIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIndhcm4iLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwidGVtcGxhdGVfbW9kZSIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm5ld0NhcmRzIiwiaGFzX25leHQiLCJleGlzdGluZ0lkcyIsIm1hcCIsImNhcmQiLCJpZCIsInVuaXF1ZU5ld0NhcmRzIiwiZmlsdGVyIiwiaGFzIiwibWVzc2FnZSIsInByZWxvYWRBbGxDYXJkcyIsImNhY2hlQWdlIiwiU1RBVElDX0NBUkRTX1VSTCIsInByZWxvYWRBbGxDYXJkc0xlZ2FjeSIsImhhc01vcmUiLCJhbGxDYXJkcyIsInByZWxvYWRJbWFnZXMiLCJnZXRDYWNoZWRDYXJkcyIsIml0ZW1zUGVyUGFnZSIsImNsZWFyQ2FjaGUiLCJoYXNDYWNoZSIsInRvdGFsQ2FyZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardCache.ts\n"));

/***/ })

});
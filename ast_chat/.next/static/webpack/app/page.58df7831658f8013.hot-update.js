"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts":
/*!*********************************************!*\
  !*** ./hooks/cardStudio/useFileHandling.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFileHandling: function() { return /* binding */ useFileHandling; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useFileHandling auto */ \n\n\nfunction useFileHandling() {\n    const [handwritingSample, setHandwritingSample] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [handwritingSampleUrl, setHandwritingSampleUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [referenceImages, setReferenceImages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [referenceImageUrls, setReferenceImageUrls] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [imageTransformation, setImageTransformation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Photo analysis state\n    const [photoAnalyses, setPhotoAnalyses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isAnalyzing, setIsAnalyzing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [showAnalysisModal, setShowAnalysisModal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [pendingAnalysisIndex, setPendingAnalysisIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // File upload handler\n    const handleFileUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (file, type)=>{\n        if (!file.type.startsWith(\"image/\")) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please upload an image file\");\n            return;\n        }\n        setIsUploading(true);\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_2__.BACKEND_API_BASE_URL, \"/upload\"), {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Upload failed: \".concat(response.status));\n            const result = await response.json();\n            if (type === \"handwriting\") {\n                setHandwritingSample(file);\n                setHandwritingSampleUrl(result.url);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Handwriting sample uploaded!\");\n            } else {\n                const newImageIndex = referenceImages.length;\n                setReferenceImages((prev)=>[\n                        ...prev,\n                        file\n                    ]);\n                setReferenceImageUrls((prev)=>[\n                        ...prev,\n                        result.url\n                    ]);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image uploaded! \".concat(referenceImages.length + 1, \" photo\").concat(referenceImages.length + 1 > 1 ? \"s\" : \"\", \" ready for character creation.\"));\n                // Auto-analyze the photo in the background\n                console.log(\"\\uD83E\\uDD16 Auto-analyzing uploaded photo...\");\n                analyzePhoto(result.url, newImageIndex).then((analysisResult)=>{\n                    if (analysisResult && analysisResult.peopleCount > 0) {\n                        console.log(\"✅ Photo analysis complete: \".concat(analysisResult.peopleCount, \" people detected\"));\n                        // Create default photo analysis with all people included\n                        const defaultAnalysis = {\n                            imageUrl: result.url,\n                            imageIndex: newImageIndex,\n                            analysisResult: analysisResult,\n                            selectedPeople: analysisResult.people.map((person)=>({\n                                    ...person,\n                                    includeInCard: true,\n                                    name: \"\",\n                                    relationshipToRecipient: \"\"\n                                })),\n                            includeEveryone: true,\n                            excludedCount: 0,\n                            analyzed: true,\n                            analysisFailed: false\n                        };\n                        // Save the analysis silently\n                        setPhotoAnalyses((prev)=>{\n                            const newAnalyses = [\n                                ...prev\n                            ];\n                            newAnalyses[newImageIndex] = defaultAnalysis;\n                            return newAnalyses;\n                        });\n                        // Subtle notification that analysis is complete\n                        if (analysisResult.peopleCount === 1) {\n                            console.log(\"\\uD83D\\uDCF8 1 person detected and ready for card creation\");\n                        } else {\n                            console.log(\"\\uD83D\\uDCF8 \".concat(analysisResult.peopleCount, \" people detected and ready for card creation\"));\n                        }\n                    } else if (analysisResult && analysisResult.peopleCount === 0) {\n                        console.log(\"\\uD83D\\uDCF8 No people detected in photo, but it can still be used for reference\");\n                    } else {\n                        console.log(\"⚠️ Photo analysis failed, but photo can still be used\");\n                    }\n                }).catch((error)=>{\n                    console.error(\"Failed to auto-analyze photo:\", error);\n                // Don't show error toast - silent failure is OK since analysis is optional\n                });\n            }\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Upload failed. Please try again.\");\n        } finally{\n            setIsUploading(false);\n        }\n    }, [\n        referenceImages.length,\n        analyzePhoto,\n        setPhotoAnalyses\n    ]);\n    const handleRemoveReferenceImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index)=>{\n        const removedImage = referenceImages[index];\n        const removedUrl = referenceImageUrls[index];\n        setReferenceImages((prev)=>prev.filter((_, i)=>i !== index));\n        setReferenceImageUrls((prev)=>prev.filter((_, i)=>i !== index));\n        // Also remove associated photo analysis\n        setPhotoAnalyses((prev)=>prev.filter((_, i)=>i !== index));\n        console.log(\"\\uD83D\\uDD0D DEBUG: Reference image removed:\", {\n            fileName: removedImage === null || removedImage === void 0 ? void 0 : removedImage.name,\n            url: removedUrl,\n            remainingImages: referenceImages.length - 1\n        });\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image removed! \".concat(referenceImages.length - 1, \" photo\").concat(referenceImages.length - 1 !== 1 ? \"s\" : \"\", \" remaining.\"));\n    }, [\n        referenceImages,\n        referenceImageUrls\n    ]);\n    // Analyze a photo using AI vision\n    const analyzePhoto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (imageUrl, imageIndex)=>{\n        console.log(\"\\uD83D\\uDCF8 Starting photo analysis for:\", imageUrl);\n        setIsAnalyzing(true);\n        try {\n            // Ensure the image URL is absolute\n            let fullImageUrl = imageUrl;\n            if (imageUrl.startsWith(\"/\")) {\n                fullImageUrl = \"\".concat(window.location.origin).concat(imageUrl);\n            }\n            console.log(\"\\uD83D\\uDCF8 Using full image URL:\", fullImageUrl);\n            const analysisPrompt = 'Analyze this photo and provide a detailed JSON response with the following structure:\\n{\\n  \"peopleCount\": <number of people in photo>,\\n  \"people\": [\\n    {\\n      \"id\": \"person-1\",\\n      \"position\": <one of: \"far-left\", \"left\", \"center-left\", \"center\", \"center-right\", \"right\", \"far-right\">,\\n      \"positionDescription\": <natural description like \"person on the far left wearing blue\">,\\n      \"description\": <overall appearance description>,\\n      \"apparentAge\": <age range like \"20-25\" or \"40s\">,\\n      \"gender\": <apparent gender if identifiable>,\\n      \"hairColor\": <hair color>,\\n      \"hairStyle\": <hair style/length>,\\n      \"distinguishingFeatures\": <notable features like glasses, beard, etc.>,\\n      \"clothing\": <what they\\'re wearing>,\\n      \"expression\": <facial expression/mood>\\n    }\\n  ],\\n  \"hasPets\": <boolean>,\\n  \"petDescription\": <description of pets if present>,\\n  \"backgroundDescription\": <description of the background/environment>,\\n  \"setting\": <type of setting like \"outdoor park\", \"beach\", \"indoor\", etc.>,\\n  \"overallMood\": <overall mood/atmosphere of the photo>,\\n  \"lighting\": <lighting conditions>\\n}\\n\\nFor each person:\\n1. Describe their position in the image using the enum values\\n2. Provide a brief description of their appearance  \\n3. Estimate their apparent age range\\n4. Note their hair color and style\\n5. Describe their clothing\\n6. Note any distinguishing features\\n7. Describe their expression/mood\\n\\nReturn ONLY the JSON response, no additional text.';\n            // Use the analyze_images tool through the MCP service\n            const response = await fetch(\"/internal/call_mcp_tool\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    tool_name: \"analyze_images\",\n                    arguments: {\n                        urls: [\n                            fullImageUrl\n                        ],\n                        analysis_prompt: analysisPrompt\n                    }\n                })\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"analyze_images error response:\", errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log(\"\\uD83E\\uDD16 analyze_images response data:\", data);\n            if (data.error && data.error !== \"None\" && data.error !== null) {\n                throw new Error(data.error);\n            }\n            let result;\n            if (typeof data.result === \"string\") {\n                try {\n                    result = JSON.parse(data.result);\n                } catch (e) {\n                    result = {\n                        status: \"error\",\n                        message: \"Invalid JSON response from MCP\"\n                    };\n                }\n            } else {\n                result = data.result;\n            }\n            if (result.status === \"error\") {\n                throw new Error(result.message);\n            }\n            // Extract the analysis from the results array\n            if (result.results && result.results.length > 0) {\n                const imageResult = result.results[0];\n                if (imageResult.status === \"success\" && imageResult.analysis) {\n                    console.log(\"\\uD83D\\uDCF8 Raw analysis text:\", imageResult.analysis);\n                    // Try to parse the analysis as JSON\n                    try {\n                        // Extract JSON from the analysis text\n                        let jsonText = imageResult.analysis;\n                        // If the response contains markdown code blocks, extract the JSON\n                        const jsonMatch = jsonText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n                        if (jsonMatch) {\n                            jsonText = jsonMatch[1];\n                        }\n                        // Parse the JSON\n                        const analysisData = JSON.parse(jsonText);\n                        console.log(\"\\uD83D\\uDCF8 Parsed analysis data:\", analysisData);\n                        // Ensure the data matches our expected structure\n                        if (typeof analysisData.peopleCount === \"number\" && Array.isArray(analysisData.people)) {\n                            setIsAnalyzing(false);\n                            return analysisData;\n                        } else {\n                            console.error(\"Analysis data doesn't match expected structure\");\n                            setIsAnalyzing(false);\n                            return null;\n                        }\n                    } catch (parseError) {\n                        console.error(\"Failed to parse analysis as JSON:\", parseError);\n                        console.error(\"Raw analysis:\", imageResult.analysis);\n                        setIsAnalyzing(false);\n                        return null;\n                    }\n                } else {\n                    console.error(\"Image analysis failed:\", imageResult.message);\n                    setIsAnalyzing(false);\n                    return null;\n                }\n            } else {\n                console.error(\"No results returned from analyze_images\");\n                setIsAnalyzing(false);\n                return null;\n            }\n        } catch (error) {\n            console.error(\"Failed to analyze photo:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to analyze photo. You can still use it without analysis.\");\n            setIsAnalyzing(false);\n            return null;\n        }\n    }, []);\n    // Save photo analysis results\n    const savePhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((analysis)=>{\n        setPhotoAnalyses((prev)=>{\n            const newAnalyses = [\n                ...prev\n            ];\n            newAnalyses[analysis.imageIndex] = analysis;\n            return newAnalyses;\n        });\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, []);\n    // Skip photo analysis\n    const skipPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pendingAnalysisIndex !== null) {\n            const skippedAnalysis = {\n                imageUrl: referenceImageUrls[pendingAnalysisIndex],\n                imageIndex: pendingAnalysisIndex,\n                analysisResult: {\n                    peopleCount: 0,\n                    people: [],\n                    hasPets: false,\n                    backgroundDescription: \"\",\n                    setting: \"\",\n                    overallMood: \"\",\n                    lighting: \"\"\n                },\n                selectedPeople: [],\n                includeEveryone: true,\n                excludedCount: 0,\n                analyzed: false,\n                analysisFailed: false\n            };\n            savePhotoAnalysis(skippedAnalysis);\n        }\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, [\n        pendingAnalysisIndex,\n        referenceImageUrls,\n        savePhotoAnalysis\n    ]);\n    // Get combined analysis for all photos\n    const getCombinedPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const analyzedPhotos = photoAnalyses.filter((a)=>a.analyzed && !a.analysisFailed);\n        if (analyzedPhotos.length === 0) return null;\n        const allSelectedPeople = analyzedPhotos.flatMap((a)=>a.selectedPeople);\n        const totalPeopleCount = analyzedPhotos.reduce((sum, a)=>sum + a.analysisResult.peopleCount, 0);\n        const totalSelectedCount = allSelectedPeople.length;\n        const totalExcludedCount = totalPeopleCount - totalSelectedCount;\n        return {\n            analyzedPhotos,\n            allSelectedPeople,\n            totalPeopleCount,\n            totalSelectedCount,\n            totalExcludedCount,\n            hasMultiplePhotos: analyzedPhotos.length > 1\n        };\n    }, [\n        photoAnalyses\n    ]);\n    // Manually trigger photo analysis for a specific image\n    const triggerPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageIndex)=>{\n        if (imageIndex >= 0 && imageIndex < referenceImageUrls.length) {\n            setPendingAnalysisIndex(imageIndex);\n            setShowAnalysisModal(true);\n        }\n    }, [\n        referenceImageUrls.length\n    ]);\n    return {\n        handwritingSample,\n        setHandwritingSample,\n        handwritingSampleUrl,\n        setHandwritingSampleUrl,\n        referenceImages,\n        setReferenceImages,\n        referenceImageUrls,\n        setReferenceImageUrls,\n        imageTransformation,\n        setImageTransformation,\n        isUploading,\n        setIsUploading,\n        handleFileUpload,\n        handleRemoveReferenceImage,\n        // Photo analysis\n        photoAnalyses,\n        setPhotoAnalyses,\n        isAnalyzing,\n        showAnalysisModal,\n        setShowAnalysisModal,\n        pendingAnalysisIndex,\n        setPendingAnalysisIndex,\n        analyzePhoto,\n        savePhotoAnalysis,\n        skipPhotoAnalysis,\n        getCombinedPhotoAnalysis,\n        triggerPhotoAnalysis\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRmlsZUhhbmRsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FFQUU4QztBQUNmO0FBQ3dFO0FBR2hHLFNBQVNJO0lBQ2QsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHTiwrQ0FBUUEsQ0FBYztJQUN4RSxNQUFNLENBQUNPLHNCQUFzQkMsd0JBQXdCLEdBQUdSLCtDQUFRQSxDQUFnQjtJQUNoRixNQUFNLENBQUNTLGlCQUFpQkMsbUJBQW1CLEdBQUdWLCtDQUFRQSxDQUFTLEVBQUU7SUFDakUsTUFBTSxDQUFDVyxvQkFBb0JDLHNCQUFzQixHQUFHWiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3pFLE1BQU0sQ0FBQ2EscUJBQXFCQyx1QkFBdUIsR0FBR2QsK0NBQVFBLENBQVM7SUFDdkUsTUFBTSxDQUFDZSxhQUFhQyxlQUFlLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUUvQyx1QkFBdUI7SUFDdkIsTUFBTSxDQUFDaUIsZUFBZUMsaUJBQWlCLEdBQUdsQiwrQ0FBUUEsQ0FBa0IsRUFBRTtJQUN0RSxNQUFNLENBQUNtQixhQUFhQyxlQUFlLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNxQixtQkFBbUJDLHFCQUFxQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDdUIsc0JBQXNCQyx3QkFBd0IsR0FBR3hCLCtDQUFRQSxDQUFnQjtJQUVoRixzQkFBc0I7SUFDdEIsTUFBTXlCLG1CQUFtQnhCLGtEQUFXQSxDQUFDLE9BQU95QixNQUFZQztRQUN0RCxJQUFJLENBQUNELEtBQUtDLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFdBQVc7WUFDbkMxQix5Q0FBS0EsQ0FBQzJCLEtBQUssQ0FBQztZQUNaO1FBQ0Y7UUFFQWIsZUFBZTtRQUVmLElBQUk7WUFDRixNQUFNYyxXQUFXLElBQUlDO1lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsUUFBUU47WUFFeEIsTUFBTU8sV0FBVyxN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QUFFaEUsY0FBYyxDQUFDQyxXQUFXLEVBQUU7UUFDL0YsTUFBTXFFLHFCQUFxQkwsa0JBQWtCdkUsTUFBTTtRQUNuRCxNQUFNNkUscUJBQXFCSixtQkFBbUJHO1FBRTlDLE9BQU87WUFDTFA7WUFDQUU7WUFDQUU7WUFDQUc7WUFDQUM7WUFDQUMsbUJBQW1CVCxlQUFlckUsTUFBTSxHQUFHO1FBQzdDO0lBQ0YsR0FBRztRQUFDNUI7S0FBYztJQUVsQix1REFBdUQ7SUFDdkQsTUFBTTJHLHVCQUF1QjNILGtEQUFXQSxDQUFDLENBQUNzRDtRQUN4QyxJQUFJQSxjQUFjLEtBQUtBLGFBQWE1QyxtQkFBbUJrQyxNQUFNLEVBQUU7WUFDN0RyQix3QkFBd0IrQjtZQUN4QmpDLHFCQUFxQjtRQUN2QjtJQUNGLEdBQUc7UUFBQ1gsbUJBQW1Ca0MsTUFBTTtLQUFDO0lBRTlCLE9BQU87UUFDTHhDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FTO1FBQ0E0QztRQUNBLGlCQUFpQjtRQUNqQnBEO1FBQ0FDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0F5QjtRQUNBd0Q7UUFDQUM7UUFDQU87UUFDQVc7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRmlsZUhhbmRsaW5nLnRzP2M0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tIFwic29ubmVyXCI7XG5pbXBvcnQgeyBCQUNLRU5EX0FQSV9CQVNFX1VSTCwgUGhvdG9BbmFseXNpcywgUGhvdG9BbmFseXNpc1Jlc3VsdCwgU2VsZWN0ZWRQZXJzb24gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjaGF0V2l0aEFJIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGaWxlSGFuZGxpbmcoKSB7XG4gIGNvbnN0IFtoYW5kd3JpdGluZ1NhbXBsZSwgc2V0SGFuZHdyaXRpbmdTYW1wbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaGFuZHdyaXRpbmdTYW1wbGVVcmwsIHNldEhhbmR3cml0aW5nU2FtcGxlVXJsXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcmVmZXJlbmNlSW1hZ2VzLCBzZXRSZWZlcmVuY2VJbWFnZXNdID0gdXNlU3RhdGU8RmlsZVtdPihbXSk7XG4gIGNvbnN0IFtyZWZlcmVuY2VJbWFnZVVybHMsIHNldFJlZmVyZW5jZUltYWdlVXJsc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbaW1hZ2VUcmFuc2Zvcm1hdGlvbiwgc2V0SW1hZ2VUcmFuc2Zvcm1hdGlvbl0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBjb25zdCBbaXNVcGxvYWRpbmcsIHNldElzVXBsb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFBob3RvIGFuYWx5c2lzIHN0YXRlXG4gIGNvbnN0IFtwaG90b0FuYWx5c2VzLCBzZXRQaG90b0FuYWx5c2VzXSA9IHVzZVN0YXRlPFBob3RvQW5hbHlzaXNbXT4oW10pO1xuICBjb25zdCBbaXNBbmFseXppbmcsIHNldElzQW5hbHl6aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dBbmFseXNpc01vZGFsLCBzZXRTaG93QW5hbHlzaXNNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtwZW5kaW5nQW5hbHlzaXNJbmRleCwgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gRmlsZSB1cGxvYWQgaGFuZGxlclxuICBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZpbGU6IEZpbGUsIHR5cGU6ICdoYW5kd3JpdGluZycgfCAncmVmZXJlbmNlJykgPT4ge1xuICAgIGlmICghZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSB1cGxvYWQgYW4gaW1hZ2UgZmlsZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS91cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmICh0eXBlID09PSAnaGFuZHdyaXRpbmcnKSB7XG4gICAgICAgIHNldEhhbmR3cml0aW5nU2FtcGxlKGZpbGUpO1xuICAgICAgICBzZXRIYW5kd3JpdGluZ1NhbXBsZVVybChyZXN1bHQudXJsKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhcIkhhbmR3cml0aW5nIHNhbXBsZSB1cGxvYWRlZCFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdJbWFnZUluZGV4ID0gcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aDtcbiAgICAgICAgc2V0UmVmZXJlbmNlSW1hZ2VzKHByZXYgPT4gWy4uLnByZXYsIGZpbGVdKTtcbiAgICAgICAgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzKHByZXYgPT4gWy4uLnByZXYsIHJlc3VsdC51cmxdKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhgUmVmZXJlbmNlIGltYWdlIHVwbG9hZGVkISAke3JlZmVyZW5jZUltYWdlcy5sZW5ndGggKyAxfSBwaG90byR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCArIDEgPiAxID8gJ3MnIDogJyd9IHJlYWR5IGZvciBjaGFyYWN0ZXIgY3JlYXRpb24uYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdXRvLWFuYWx5emUgdGhlIHBob3RvIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+kliBBdXRvLWFuYWx5emluZyB1cGxvYWRlZCBwaG90by4uLlwiKTtcbiAgICAgICAgYW5hbHl6ZVBob3RvKHJlc3VsdC51cmwsIG5ld0ltYWdlSW5kZXgpLnRoZW4oYW5hbHlzaXNSZXN1bHQgPT4ge1xuICAgICAgICAgIGlmIChhbmFseXNpc1Jlc3VsdCAmJiBhbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGhvdG8gYW5hbHlzaXMgY29tcGxldGU6ICR7YW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnR9IHBlb3BsZSBkZXRlY3RlZGApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBwaG90byBhbmFseXNpcyB3aXRoIGFsbCBwZW9wbGUgaW5jbHVkZWRcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBbmFseXNpczogUGhvdG9BbmFseXNpcyA9IHtcbiAgICAgICAgICAgICAgaW1hZ2VVcmw6IHJlc3VsdC51cmwsXG4gICAgICAgICAgICAgIGltYWdlSW5kZXg6IG5ld0ltYWdlSW5kZXgsXG4gICAgICAgICAgICAgIGFuYWx5c2lzUmVzdWx0OiBhbmFseXNpc1Jlc3VsdCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRQZW9wbGU6IGFuYWx5c2lzUmVzdWx0LnBlb3BsZS5tYXAocGVyc29uID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucGVyc29uLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVJbkNhcmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsIC8vIE5vIG5hbWUgYnkgZGVmYXVsdCwgdXNlciBjYW4gYWRkIHZpYSBcIkN1c3RvbWl6ZSBwZW9wbGVcIlxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcFRvUmVjaXBpZW50OiAnJ1xuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIGluY2x1ZGVFdmVyeW9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhjbHVkZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgYW5hbHl6ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGFuYWx5c2lzRmFpbGVkOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgYW5hbHlzaXMgc2lsZW50bHlcbiAgICAgICAgICAgIHNldFBob3RvQW5hbHlzZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0FuYWx5c2VzID0gWy4uLnByZXZdO1xuICAgICAgICAgICAgICBuZXdBbmFseXNlc1tuZXdJbWFnZUluZGV4XSA9IGRlZmF1bHRBbmFseXNpcztcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0FuYWx5c2VzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN1YnRsZSBub3RpZmljYXRpb24gdGhhdCBhbmFseXNpcyBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKGFuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCAxIHBlcnNvbiBkZXRlY3RlZCBhbmQgcmVhZHkgZm9yIGNhcmQgY3JlYXRpb25cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TuCAke2FuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50fSBwZW9wbGUgZGV0ZWN0ZWQgYW5kIHJlYWR5IGZvciBjYXJkIGNyZWF0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmFseXNpc1Jlc3VsdCAmJiBhbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5O4IE5vIHBlb3BsZSBkZXRlY3RlZCBpbiBwaG90bywgYnV0IGl0IGNhbiBzdGlsbCBiZSB1c2VkIGZvciByZWZlcmVuY2VcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIFBob3RvIGFuYWx5c2lzIGZhaWxlZCwgYnV0IHBob3RvIGNhbiBzdGlsbCBiZSB1c2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gYXV0by1hbmFseXplIHBob3RvOlwiLCBlcnJvcik7XG4gICAgICAgICAgLy8gRG9uJ3Qgc2hvdyBlcnJvciB0b2FzdCAtIHNpbGVudCBmYWlsdXJlIGlzIE9LIHNpbmNlIGFuYWx5c2lzIGlzIG9wdGlvbmFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlVwbG9hZCBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1VwbG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCwgYW5hbHl6ZVBob3RvLCBzZXRQaG90b0FuYWx5c2VzXSk7XG5cbiAgY29uc3QgaGFuZGxlUmVtb3ZlUmVmZXJlbmNlSW1hZ2UgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlbW92ZWRJbWFnZSA9IHJlZmVyZW5jZUltYWdlc1tpbmRleF07XG4gICAgY29uc3QgcmVtb3ZlZFVybCA9IHJlZmVyZW5jZUltYWdlVXJsc1tpbmRleF07XG4gICAgXG4gICAgc2V0UmVmZXJlbmNlSW1hZ2VzKHByZXYgPT4gcHJldi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KSk7XG4gICAgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzKHByZXYgPT4gcHJldi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KSk7XG4gICAgXG4gICAgLy8gQWxzbyByZW1vdmUgYXNzb2NpYXRlZCBwaG90byBhbmFseXNpc1xuICAgIHNldFBob3RvQW5hbHlzZXMocHJldiA9PiBwcmV2LmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIvCflI0gREVCVUc6IFJlZmVyZW5jZSBpbWFnZSByZW1vdmVkOlwiLCB7XG4gICAgICBmaWxlTmFtZTogcmVtb3ZlZEltYWdlPy5uYW1lLFxuICAgICAgdXJsOiByZW1vdmVkVXJsLFxuICAgICAgcmVtYWluaW5nSW1hZ2VzOiByZWZlcmVuY2VJbWFnZXMubGVuZ3RoIC0gMVxuICAgIH0pO1xuICAgIFxuICAgIHRvYXN0LnN1Y2Nlc3MoYFJlZmVyZW5jZSBpbWFnZSByZW1vdmVkISAke3JlZmVyZW5jZUltYWdlcy5sZW5ndGggLSAxfSBwaG90byR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCAtIDEgIT09IDEgPyAncycgOiAnJ30gcmVtYWluaW5nLmApO1xuICB9LCBbcmVmZXJlbmNlSW1hZ2VzLCByZWZlcmVuY2VJbWFnZVVybHNdKTtcblxuICAvLyBBbmFseXplIGEgcGhvdG8gdXNpbmcgQUkgdmlzaW9uXG4gIGNvbnN0IGFuYWx5emVQaG90byA9IHVzZUNhbGxiYWNrKGFzeW5jIChpbWFnZVVybDogc3RyaW5nLCBpbWFnZUluZGV4OiBudW1iZXIpOiBQcm9taXNlPFBob3RvQW5hbHlzaXNSZXN1bHQgfCBudWxsPiA9PiB7XG4gICAgY29uc29sZS5sb2coXCLwn5O4IFN0YXJ0aW5nIHBob3RvIGFuYWx5c2lzIGZvcjpcIiwgaW1hZ2VVcmwpO1xuICAgIHNldElzQW5hbHl6aW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGltYWdlIFVSTCBpcyBhYnNvbHV0ZVxuICAgICAgbGV0IGZ1bGxJbWFnZVVybCA9IGltYWdlVXJsO1xuICAgICAgaWYgKGltYWdlVXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBmdWxsSW1hZ2VVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufSR7aW1hZ2VVcmx9YDtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCBVc2luZyBmdWxsIGltYWdlIFVSTDpcIiwgZnVsbEltYWdlVXJsKTtcbiAgICAgIFxuICAgICAgY29uc3QgYW5hbHlzaXNQcm9tcHQgPSBgQW5hbHl6ZSB0aGlzIHBob3RvIGFuZCBwcm92aWRlIGEgZGV0YWlsZWQgSlNPTiByZXNwb25zZSB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxue1xuICBcInBlb3BsZUNvdW50XCI6IDxudW1iZXIgb2YgcGVvcGxlIGluIHBob3RvPixcbiAgXCJwZW9wbGVcIjogW1xuICAgIHtcbiAgICAgIFwiaWRcIjogXCJwZXJzb24tMVwiLFxuICAgICAgXCJwb3NpdGlvblwiOiA8b25lIG9mOiBcImZhci1sZWZ0XCIsIFwibGVmdFwiLCBcImNlbnRlci1sZWZ0XCIsIFwiY2VudGVyXCIsIFwiY2VudGVyLXJpZ2h0XCIsIFwicmlnaHRcIiwgXCJmYXItcmlnaHRcIj4sXG4gICAgICBcInBvc2l0aW9uRGVzY3JpcHRpb25cIjogPG5hdHVyYWwgZGVzY3JpcHRpb24gbGlrZSBcInBlcnNvbiBvbiB0aGUgZmFyIGxlZnQgd2VhcmluZyBibHVlXCI+LFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiA8b3ZlcmFsbCBhcHBlYXJhbmNlIGRlc2NyaXB0aW9uPixcbiAgICAgIFwiYXBwYXJlbnRBZ2VcIjogPGFnZSByYW5nZSBsaWtlIFwiMjAtMjVcIiBvciBcIjQwc1wiPixcbiAgICAgIFwiZ2VuZGVyXCI6IDxhcHBhcmVudCBnZW5kZXIgaWYgaWRlbnRpZmlhYmxlPixcbiAgICAgIFwiaGFpckNvbG9yXCI6IDxoYWlyIGNvbG9yPixcbiAgICAgIFwiaGFpclN0eWxlXCI6IDxoYWlyIHN0eWxlL2xlbmd0aD4sXG4gICAgICBcImRpc3Rpbmd1aXNoaW5nRmVhdHVyZXNcIjogPG5vdGFibGUgZmVhdHVyZXMgbGlrZSBnbGFzc2VzLCBiZWFyZCwgZXRjLj4sXG4gICAgICBcImNsb3RoaW5nXCI6IDx3aGF0IHRoZXkncmUgd2VhcmluZz4sXG4gICAgICBcImV4cHJlc3Npb25cIjogPGZhY2lhbCBleHByZXNzaW9uL21vb2Q+XG4gICAgfVxuICBdLFxuICBcImhhc1BldHNcIjogPGJvb2xlYW4+LFxuICBcInBldERlc2NyaXB0aW9uXCI6IDxkZXNjcmlwdGlvbiBvZiBwZXRzIGlmIHByZXNlbnQ+LFxuICBcImJhY2tncm91bmREZXNjcmlwdGlvblwiOiA8ZGVzY3JpcHRpb24gb2YgdGhlIGJhY2tncm91bmQvZW52aXJvbm1lbnQ+LFxuICBcInNldHRpbmdcIjogPHR5cGUgb2Ygc2V0dGluZyBsaWtlIFwib3V0ZG9vciBwYXJrXCIsIFwiYmVhY2hcIiwgXCJpbmRvb3JcIiwgZXRjLj4sXG4gIFwib3ZlcmFsbE1vb2RcIjogPG92ZXJhbGwgbW9vZC9hdG1vc3BoZXJlIG9mIHRoZSBwaG90bz4sXG4gIFwibGlnaHRpbmdcIjogPGxpZ2h0aW5nIGNvbmRpdGlvbnM+XG59XG5cbkZvciBlYWNoIHBlcnNvbjpcbjEuIERlc2NyaWJlIHRoZWlyIHBvc2l0aW9uIGluIHRoZSBpbWFnZSB1c2luZyB0aGUgZW51bSB2YWx1ZXNcbjIuIFByb3ZpZGUgYSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGVpciBhcHBlYXJhbmNlICBcbjMuIEVzdGltYXRlIHRoZWlyIGFwcGFyZW50IGFnZSByYW5nZVxuNC4gTm90ZSB0aGVpciBoYWlyIGNvbG9yIGFuZCBzdHlsZVxuNS4gRGVzY3JpYmUgdGhlaXIgY2xvdGhpbmdcbjYuIE5vdGUgYW55IGRpc3Rpbmd1aXNoaW5nIGZlYXR1cmVzXG43LiBEZXNjcmliZSB0aGVpciBleHByZXNzaW9uL21vb2RcblxuUmV0dXJuIE9OTFkgdGhlIEpTT04gcmVzcG9uc2UsIG5vIGFkZGl0aW9uYWwgdGV4dC5gO1xuXG4gICAgICAvLyBVc2UgdGhlIGFuYWx5emVfaW1hZ2VzIHRvb2wgdGhyb3VnaCB0aGUgTUNQIHNlcnZpY2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9pbnRlcm5hbC9jYWxsX21jcF90b29sJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0b29sX25hbWU6ICdhbmFseXplX2ltYWdlcycsXG4gICAgICAgICAgYXJndW1lbnRzOiB7XG4gICAgICAgICAgICB1cmxzOiBbZnVsbEltYWdlVXJsXSxcbiAgICAgICAgICAgIGFuYWx5c2lzX3Byb21wdDogYW5hbHlzaXNQcm9tcHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJhbmFseXplX2ltYWdlcyBlcnJvciByZXNwb25zZTpcIiwgZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfpJYgYW5hbHl6ZV9pbWFnZXMgcmVzcG9uc2UgZGF0YTpcIiwgZGF0YSk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLmVycm9yICYmIGRhdGEuZXJyb3IgIT09IFwiTm9uZVwiICYmIGRhdGEuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBkYXRhLnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEucmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmVzdWx0ID0geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gcmVzcG9uc2UgZnJvbSBNQ1AnIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGRhdGEucmVzdWx0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IHRoZSBhbmFseXNpcyBmcm9tIHRoZSByZXN1bHRzIGFycmF5XG4gICAgICBpZiAocmVzdWx0LnJlc3VsdHMgJiYgcmVzdWx0LnJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBpbWFnZVJlc3VsdCA9IHJlc3VsdC5yZXN1bHRzWzBdO1xuICAgICAgICBpZiAoaW1hZ2VSZXN1bHQuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgaW1hZ2VSZXN1bHQuYW5hbHlzaXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk7ggUmF3IGFuYWx5c2lzIHRleHQ6XCIsIGltYWdlUmVzdWx0LmFuYWx5c2lzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGFuYWx5c2lzIGFzIEpTT05cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBKU09OIGZyb20gdGhlIGFuYWx5c2lzIHRleHRcbiAgICAgICAgICAgIGxldCBqc29uVGV4dCA9IGltYWdlUmVzdWx0LmFuYWx5c2lzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgY29udGFpbnMgbWFya2Rvd24gY29kZSBibG9ja3MsIGV4dHJhY3QgdGhlIEpTT05cbiAgICAgICAgICAgIGNvbnN0IGpzb25NYXRjaCA9IGpzb25UZXh0Lm1hdGNoKC9gYGBqc29uXFxzKihbXFxzXFxTXSo/KVxccypgYGAvKTtcbiAgICAgICAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgICAgICAganNvblRleHQgPSBqc29uTWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBKU09OXG4gICAgICAgICAgICBjb25zdCBhbmFseXNpc0RhdGEgPSBKU09OLnBhcnNlKGpzb25UZXh0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TuCBQYXJzZWQgYW5hbHlzaXMgZGF0YTpcIiwgYW5hbHlzaXNEYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBkYXRhIG1hdGNoZXMgb3VyIGV4cGVjdGVkIHN0cnVjdHVyZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmFseXNpc0RhdGEucGVvcGxlQ291bnQgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYW5hbHlzaXNEYXRhLnBlb3BsZSkpIHtcbiAgICAgICAgICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gYW5hbHlzaXNEYXRhIGFzIFBob3RvQW5hbHlzaXNSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQW5hbHlzaXMgZGF0YSBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGFuYWx5c2lzIGFzIEpTT046XCIsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJhdyBhbmFseXNpczpcIiwgaW1hZ2VSZXN1bHQuYW5hbHlzaXMpO1xuICAgICAgICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbWFnZSBhbmFseXNpcyBmYWlsZWQ6XCIsIGltYWdlUmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHJlc3VsdHMgcmV0dXJuZWQgZnJvbSBhbmFseXplX2ltYWdlc1wiKTtcbiAgICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFuYWx5emUgcGhvdG86XCIsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKFwiRmFpbGVkIHRvIGFuYWx5emUgcGhvdG8uIFlvdSBjYW4gc3RpbGwgdXNlIGl0IHdpdGhvdXQgYW5hbHlzaXMuXCIpO1xuICAgICAgc2V0SXNBbmFseXppbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBwaG90byBhbmFseXNpcyByZXN1bHRzXG4gIGNvbnN0IHNhdmVQaG90b0FuYWx5c2lzID0gdXNlQ2FsbGJhY2soKGFuYWx5c2lzOiBQaG90b0FuYWx5c2lzKSA9PiB7XG4gICAgc2V0UGhvdG9BbmFseXNlcyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5ld0FuYWx5c2VzID0gWy4uLnByZXZdO1xuICAgICAgbmV3QW5hbHlzZXNbYW5hbHlzaXMuaW1hZ2VJbmRleF0gPSBhbmFseXNpcztcbiAgICAgIHJldHVybiBuZXdBbmFseXNlcztcbiAgICB9KTtcbiAgICBzZXRTaG93QW5hbHlzaXNNb2RhbChmYWxzZSk7XG4gICAgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXgobnVsbCk7XG4gIH0sIFtdKTtcblxuICAvLyBTa2lwIHBob3RvIGFuYWx5c2lzXG4gIGNvbnN0IHNraXBQaG90b0FuYWx5c2lzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChwZW5kaW5nQW5hbHlzaXNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2tpcHBlZEFuYWx5c2lzOiBQaG90b0FuYWx5c2lzID0ge1xuICAgICAgICBpbWFnZVVybDogcmVmZXJlbmNlSW1hZ2VVcmxzW3BlbmRpbmdBbmFseXNpc0luZGV4XSxcbiAgICAgICAgaW1hZ2VJbmRleDogcGVuZGluZ0FuYWx5c2lzSW5kZXgsXG4gICAgICAgIGFuYWx5c2lzUmVzdWx0OiB7XG4gICAgICAgICAgcGVvcGxlQ291bnQ6IDAsXG4gICAgICAgICAgcGVvcGxlOiBbXSxcbiAgICAgICAgICBoYXNQZXRzOiBmYWxzZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kRGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJcIixcbiAgICAgICAgICBvdmVyYWxsTW9vZDogXCJcIixcbiAgICAgICAgICBsaWdodGluZzogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZFBlb3BsZTogW10sXG4gICAgICAgIGluY2x1ZGVFdmVyeW9uZTogdHJ1ZSxcbiAgICAgICAgZXhjbHVkZWRDb3VudDogMCxcbiAgICAgICAgYW5hbHl6ZWQ6IGZhbHNlLFxuICAgICAgICBhbmFseXNpc0ZhaWxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBzYXZlUGhvdG9BbmFseXNpcyhza2lwcGVkQW5hbHlzaXMpO1xuICAgIH1cbiAgICBzZXRTaG93QW5hbHlzaXNNb2RhbChmYWxzZSk7XG4gICAgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXgobnVsbCk7XG4gIH0sIFtwZW5kaW5nQW5hbHlzaXNJbmRleCwgcmVmZXJlbmNlSW1hZ2VVcmxzLCBzYXZlUGhvdG9BbmFseXNpc10pO1xuXG4gIC8vIEdldCBjb21iaW5lZCBhbmFseXNpcyBmb3IgYWxsIHBob3Rvc1xuICBjb25zdCBnZXRDb21iaW5lZFBob3RvQW5hbHlzaXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgYW5hbHl6ZWRQaG90b3MgPSBwaG90b0FuYWx5c2VzLmZpbHRlcihhID0+IGEuYW5hbHl6ZWQgJiYgIWEuYW5hbHlzaXNGYWlsZWQpO1xuICAgIGlmIChhbmFseXplZFBob3Rvcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgYWxsU2VsZWN0ZWRQZW9wbGUgPSBhbmFseXplZFBob3Rvcy5mbGF0TWFwKGEgPT4gYS5zZWxlY3RlZFBlb3BsZSk7XG4gICAgY29uc3QgdG90YWxQZW9wbGVDb3VudCA9IGFuYWx5emVkUGhvdG9zLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmFuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50LCAwKTtcbiAgICBjb25zdCB0b3RhbFNlbGVjdGVkQ291bnQgPSBhbGxTZWxlY3RlZFBlb3BsZS5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxFeGNsdWRlZENvdW50ID0gdG90YWxQZW9wbGVDb3VudCAtIHRvdGFsU2VsZWN0ZWRDb3VudDtcblxuICAgIHJldHVybiB7XG4gICAgICBhbmFseXplZFBob3RvcyxcbiAgICAgIGFsbFNlbGVjdGVkUGVvcGxlLFxuICAgICAgdG90YWxQZW9wbGVDb3VudCxcbiAgICAgIHRvdGFsU2VsZWN0ZWRDb3VudCxcbiAgICAgIHRvdGFsRXhjbHVkZWRDb3VudCxcbiAgICAgIGhhc011bHRpcGxlUGhvdG9zOiBhbmFseXplZFBob3Rvcy5sZW5ndGggPiAxXG4gICAgfTtcbiAgfSwgW3Bob3RvQW5hbHlzZXNdKTtcblxuICAvLyBNYW51YWxseSB0cmlnZ2VyIHBob3RvIGFuYWx5c2lzIGZvciBhIHNwZWNpZmljIGltYWdlXG4gIGNvbnN0IHRyaWdnZXJQaG90b0FuYWx5c2lzID0gdXNlQ2FsbGJhY2soKGltYWdlSW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGlmIChpbWFnZUluZGV4ID49IDAgJiYgaW1hZ2VJbmRleCA8IHJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGgpIHtcbiAgICAgIHNldFBlbmRpbmdBbmFseXNpc0luZGV4KGltYWdlSW5kZXgpO1xuICAgICAgc2V0U2hvd0FuYWx5c2lzTW9kYWwodHJ1ZSk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aF0pO1xuXG4gIHJldHVybiB7XG4gICAgaGFuZHdyaXRpbmdTYW1wbGUsXG4gICAgc2V0SGFuZHdyaXRpbmdTYW1wbGUsXG4gICAgaGFuZHdyaXRpbmdTYW1wbGVVcmwsXG4gICAgc2V0SGFuZHdyaXRpbmdTYW1wbGVVcmwsXG4gICAgcmVmZXJlbmNlSW1hZ2VzLFxuICAgIHNldFJlZmVyZW5jZUltYWdlcyxcbiAgICByZWZlcmVuY2VJbWFnZVVybHMsXG4gICAgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgIGltYWdlVHJhbnNmb3JtYXRpb24sXG4gICAgc2V0SW1hZ2VUcmFuc2Zvcm1hdGlvbixcbiAgICBpc1VwbG9hZGluZyxcbiAgICBzZXRJc1VwbG9hZGluZyxcbiAgICBoYW5kbGVGaWxlVXBsb2FkLFxuICAgIGhhbmRsZVJlbW92ZVJlZmVyZW5jZUltYWdlLFxuICAgIC8vIFBob3RvIGFuYWx5c2lzXG4gICAgcGhvdG9BbmFseXNlcyxcbiAgICBzZXRQaG90b0FuYWx5c2VzLFxuICAgIGlzQW5hbHl6aW5nLFxuICAgIHNob3dBbmFseXNpc01vZGFsLFxuICAgIHNldFNob3dBbmFseXNpc01vZGFsLFxuICAgIHBlbmRpbmdBbmFseXNpc0luZGV4LFxuICAgIHNldFBlbmRpbmdBbmFseXNpc0luZGV4LFxuICAgIGFuYWx5emVQaG90byxcbiAgICBzYXZlUGhvdG9BbmFseXNpcyxcbiAgICBza2lwUGhvdG9BbmFseXNpcyxcbiAgICBnZXRDb21iaW5lZFBob3RvQW5hbHlzaXMsXG4gICAgdHJpZ2dlclBob3RvQW5hbHlzaXNcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInRvYXN0IiwiQkFDS0VORF9BUElfQkFTRV9VUkwiLCJ1c2VGaWxlSGFuZGxpbmciLCJoYW5kd3JpdGluZ1NhbXBsZSIsInNldEhhbmR3cml0aW5nU2FtcGxlIiwiaGFuZHdyaXRpbmdTYW1wbGVVcmwiLCJzZXRIYW5kd3JpdGluZ1NhbXBsZVVybCIsInJlZmVyZW5jZUltYWdlcyIsInNldFJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlVXJscyIsInNldFJlZmVyZW5jZUltYWdlVXJscyIsImltYWdlVHJhbnNmb3JtYXRpb24iLCJzZXRJbWFnZVRyYW5zZm9ybWF0aW9uIiwiaXNVcGxvYWRpbmciLCJzZXRJc1VwbG9hZGluZyIsInBob3RvQW5hbHlzZXMiLCJzZXRQaG90b0FuYWx5c2VzIiwiaXNBbmFseXppbmciLCJzZXRJc0FuYWx5emluZyIsInNob3dBbmFseXNpc01vZGFsIiwic2V0U2hvd0FuYWx5c2lzTW9kYWwiLCJwZW5kaW5nQW5hbHlzaXNJbmRleCIsInNldFBlbmRpbmdBbmFseXNpc0luZGV4IiwiaGFuZGxlRmlsZVVwbG9hZCIsImZpbGUiLCJ0eXBlIiwic3RhcnRzV2l0aCIsImVycm9yIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5Iiwib2siLCJFcnJvciIsInN0YXR1cyIsInJlc3VsdCIsImpzb24iLCJ1cmwiLCJzdWNjZXNzIiwibmV3SW1hZ2VJbmRleCIsImxlbmd0aCIsInByZXYiLCJjb25zb2xlIiwibG9nIiwiYW5hbHl6ZVBob3RvIiwidGhlbiIsImFuYWx5c2lzUmVzdWx0IiwicGVvcGxlQ291bnQiLCJkZWZhdWx0QW5hbHlzaXMiLCJpbWFnZVVybCIsImltYWdlSW5kZXgiLCJzZWxlY3RlZFBlb3BsZSIsInBlb3BsZSIsIm1hcCIsInBlcnNvbiIsImluY2x1ZGVJbkNhcmQiLCJuYW1lIiwicmVsYXRpb25zaGlwVG9SZWNpcGllbnQiLCJpbmNsdWRlRXZlcnlvbmUiLCJleGNsdWRlZENvdW50IiwiYW5hbHl6ZWQiLCJhbmFseXNpc0ZhaWxlZCIsIm5ld0FuYWx5c2VzIiwiY2F0Y2giLCJoYW5kbGVSZW1vdmVSZWZlcmVuY2VJbWFnZSIsImluZGV4IiwicmVtb3ZlZEltYWdlIiwicmVtb3ZlZFVybCIsImZpbHRlciIsIl8iLCJpIiwiZmlsZU5hbWUiLCJyZW1haW5pbmdJbWFnZXMiLCJmdWxsSW1hZ2VVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFuYWx5c2lzUHJvbXB0IiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b29sX25hbWUiLCJhcmd1bWVudHMiLCJ1cmxzIiwiYW5hbHlzaXNfcHJvbXB0IiwiZXJyb3JUZXh0IiwidGV4dCIsImRhdGEiLCJwYXJzZSIsIm1lc3NhZ2UiLCJyZXN1bHRzIiwiaW1hZ2VSZXN1bHQiLCJhbmFseXNpcyIsImpzb25UZXh0IiwianNvbk1hdGNoIiwibWF0Y2giLCJhbmFseXNpc0RhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUVycm9yIiwic2F2ZVBob3RvQW5hbHlzaXMiLCJza2lwUGhvdG9BbmFseXNpcyIsInNraXBwZWRBbmFseXNpcyIsImhhc1BldHMiLCJiYWNrZ3JvdW5kRGVzY3JpcHRpb24iLCJzZXR0aW5nIiwib3ZlcmFsbE1vb2QiLCJsaWdodGluZyIsImdldENvbWJpbmVkUGhvdG9BbmFseXNpcyIsImFuYWx5emVkUGhvdG9zIiwiYSIsImFsbFNlbGVjdGVkUGVvcGxlIiwiZmxhdE1hcCIsInRvdGFsUGVvcGxlQ291bnQiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbFNlbGVjdGVkQ291bnQiLCJ0b3RhbEV4Y2x1ZGVkQ291bnQiLCJoYXNNdWx0aXBsZVBob3RvcyIsInRyaWdnZXJQaG90b0FuYWx5c2lzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gallery/page",{

/***/ "(app-pages-browser)/./hooks/useCardCache.ts":
/*!*******************************!*\
  !*** ./hooks/useCardCache.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardCache: function() { return /* binding */ useCardCache; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CACHE_KEY = \"vibecarding_template_cache\";\nconst IMAGE_CACHE_KEY = \"vibecarding_image_cache\";\nconst CACHE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst IMAGE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nconst BACKEND_API_BASE_URL = \"https://vibecarding.com\" || 0;\nconst MAX_CONCURRENT_IMAGES = 3; // Netflix-style: Very conservative concurrent loads\n// Use the regular list endpoint - it's fast enough and always current\nconst CARDS_LIST_URL = \"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list\");\n// Global cache state\nlet globalCache = null;\nlet isPreloading = false;\nconst cacheListeners = new Set();\nconst notifyListeners = ()=>{\n    cacheListeners.forEach((listener)=>listener());\n};\nconst useCardCache = ()=>{\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalCache);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Subscribe to cache updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updateCache = ()=>setCache(globalCache);\n        cacheListeners.add(updateCache);\n        return ()=>{\n            cacheListeners.delete(updateCache);\n        };\n    }, []);\n    // Load from localStorage on mount (after hydration)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ( false || globalCache) return;\n        try {\n            const stored = localStorage.getItem(CACHE_KEY);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                const isExpired = Date.now() - parsed.lastFetched > CACHE_DURATION;\n                if (!isExpired) {\n                    globalCache = parsed;\n                    setCache(parsed);\n                    console.log(\"\\uD83D\\uDCE6 Loaded cached template cards:\", parsed.cards.length);\n                } else {\n                    localStorage.removeItem(CACHE_KEY);\n                    console.log(\"\\uD83D\\uDDD1️ Expired cache removed\");\n                }\n            }\n        } catch (error) {\n            console.error(\"Failed to load cache:\", error);\n            if (true) {\n                localStorage.removeItem(CACHE_KEY);\n            }\n        }\n    }, []);\n    const loadCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, search = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        // If we have complete cache and no search, return cached data immediately\n        if (!search && (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) && !reset) {\n            const startIndex = (page - 1) * 40;\n            const endIndex = startIndex + 40;\n            return globalCache.cards.slice(startIndex, endIndex);\n        }\n        // For searches or when no cache, fetch from list endpoint\n        if (!search && (reset || !globalCache)) {\n            try {\n                // Fetch all cards with a large per_page to get everything at once\n                const response = await fetch(\"\".concat(CARDS_LIST_URL, \"?per_page=1000&template_mode=true\"));\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data.status === \"success\" && data.cards && Array.isArray(data.cards)) {\n                        var _data_pagination;\n                        // Deduplicate cards by ID\n                        const uniqueCards = data.cards.filter((card, index, self)=>index === self.findIndex((c)=>c.id === card.id));\n                        // Update global cache\n                        globalCache = {\n                            cards: uniqueCards,\n                            totalCount: ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.total) || uniqueCards.length,\n                            lastFetched: Date.now(),\n                            isComplete: true\n                        };\n                        // Save to localStorage\n                        if (true) {\n                            try {\n                                localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                            } catch (error) {\n                                console.warn(\"Failed to save cache to localStorage:\", error);\n                            }\n                        }\n                        notifyListeners();\n                        // Return requested page\n                        const startIndex = (page - 1) * 40;\n                        const endIndex = startIndex + 40;\n                        return data.cards.slice(startIndex, endIndex);\n                    }\n                }\n            } catch (error) {\n                console.warn(\"List endpoint failed, falling back to paginated API:\", error);\n            }\n        }\n        // Fallback to original paginated API\n        setIsLoading(true);\n        setError(null);\n        try {\n            const params = new URLSearchParams({\n                page: page.toString(),\n                per_page: \"40\",\n                ...search && {\n                    search\n                },\n                template_mode: \"true\"\n            });\n            const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?\").concat(params));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\") {\n                const newCards = data.cards;\n                // Update global cache for non-search queries\n                if (!search) {\n                    if (reset || !globalCache) {\n                        globalCache = {\n                            cards: newCards,\n                            totalCount: data.pagination.total,\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    } else {\n                        // Append to existing cache\n                        const existingIds = new Set(globalCache.cards.map((card)=>card.id));\n                        const uniqueNewCards = newCards.filter((card)=>!existingIds.has(card.id));\n                        globalCache = {\n                            ...globalCache,\n                            cards: [\n                                ...globalCache.cards,\n                                ...uniqueNewCards\n                            ],\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    }\n                    // Save to localStorage\n                    if (true) {\n                        try {\n                            localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                        } catch (error) {\n                            console.warn(\"Failed to save cache to localStorage:\", error);\n                        }\n                    }\n                    notifyListeners();\n                }\n                return newCards;\n            } else {\n                throw new Error(data.message || \"Failed to load cards\");\n            }\n        } catch (error) {\n            console.error(\"Error loading cards:\", error);\n            setError(error instanceof Error ? error.message : \"Failed to load cards\");\n            return [];\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    const preloadAllCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isPreloading) {\n            return;\n        }\n        // Check if we already have a complete cache that's fresh\n        if (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) {\n            const cacheAge = Date.now() - globalCache.lastFetched;\n            if (cacheAge < CACHE_DURATION) {\n                console.log(\"⚡ Using fresh cached template data:\", globalCache.cards.length, \"cards\");\n                // No image preloading - instant response like reference site\n                console.log(\"⚡ Using fresh cached data, no preloading needed\");\n                return;\n            }\n        }\n        isPreloading = true;\n        console.log(\"\\uD83D\\uDE80 Starting immediate template preload on page load...\");\n        try {\n            // Load all cards from list endpoint (always current!)\n            const response = await fetch(\"\".concat(CARDS_LIST_URL, \"?per_page=1000&template_mode=true\"));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\" && data.cards && Array.isArray(data.cards)) {\n                var _data_pagination;\n                // Update global cache with all cards at once\n                globalCache = {\n                    cards: data.cards,\n                    totalCount: ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.total) || data.cards.length,\n                    lastFetched: Date.now(),\n                    isComplete: true // We have all cards!\n                };\n                // Save to localStorage\n                if (true) {\n                    try {\n                        localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                    } catch (error) {\n                        console.warn(\"Failed to save cache to localStorage:\", error);\n                    }\n                }\n                notifyListeners();\n                console.log(\"✅ Page load template preload complete:\", data.cards.length, \"cards\");\n                // Ultra-simple: No image preloading, let browser lazy loading handle it\n                console.log(\"✅ Cards loaded, letting browser handle image loading\");\n            }\n        } catch (error) {\n            console.error(\"❌ Static preload failed, falling back to paginated:\", error);\n            // Fallback to old method if static fails\n            await preloadAllCardsLegacy();\n        } finally{\n            isPreloading = false;\n        }\n    }, []);\n    // Legacy preload method as fallback\n    const preloadAllCardsLegacy = async ()=>{\n        try {\n            let page = 1;\n            let hasMore = true;\n            let allCards = [];\n            while(hasMore && page <= 5){\n                var _data_pagination;\n                const cards = await loadCards(page, \"\", page === 1);\n                allCards = page === 1 ? cards : [\n                    ...allCards,\n                    ...cards\n                ];\n                // Check if we have more pages\n                const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?page=\").concat(page, \"&per_page=40&template_mode=true\"));\n                const data = await response.json();\n                hasMore = ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.has_next) || false;\n                page++;\n            }\n            console.log(\"✅ Legacy preload complete:\", allCards.length, \"cards\");\n            await preloadImages(allCards.slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Legacy preload failed:\", error);\n        }\n    };\n    const preloadImages = async (cards)=>{\n        // Disabled for instant loading like reference site\n        console.log(\"\\uD83D\\uDE80 Skipping image preloading for instant response\");\n        return;\n    };\n    const getCachedCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, itemsPerPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n        if (!globalCache) return [];\n        const startIndex = (page - 1) * itemsPerPage;\n        const endIndex = startIndex + itemsPerPage;\n        return globalCache.cards.slice(startIndex, endIndex);\n    }, []);\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalCache = null;\n        if (true) {\n            localStorage.removeItem(CACHE_KEY);\n        }\n        setCache(null);\n        notifyListeners();\n    }, []);\n    return {\n        cache,\n        isLoading,\n        error,\n        loadCards,\n        preloadAllCards,\n        getCachedCards,\n        clearCache,\n        hasCache: !!globalCache,\n        isComplete: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) || false,\n        totalCards: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.totalCount) || 0\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRDYWNoZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUE0QnpELE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGlCQUFpQixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQ3BELE1BQU1DLHVCQUF1QixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQzFELE1BQU1DLHVCQUF1QkMseUJBQXVDLElBQUk7QUFDeEUsTUFBTUcsd0JBQXdCLEdBQUcsb0RBQW9EO0FBRXJGLHNFQUFzRTtBQUN0RSxNQUFNQyxpQkFBaUIsR0FBd0IsT0FBckJMLHNCQUFxQjtBQUUvQyxxQkFBcUI7QUFDckIsSUFBSU0sY0FBZ0M7QUFDcEMsSUFBSUMsZUFBZTtBQUNuQixNQUFNQyxpQkFBa0MsSUFBSUM7QUFFNUMsTUFBTUMsa0JBQWtCO0lBQ3RCRixlQUFlRyxPQUFPLENBQUNDLENBQUFBLFdBQVlBO0FBQ3JDO0FBRU8sTUFBTUMsZUFBZTtJQUMxQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFtQmE7SUFDckQsTUFBTSxDQUFDVSxXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixPQUFPQyxTQUFTLEdBQUcxQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsNkJBQTZCO0lBQzdCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU0wQixjQUFjLElBQU1MLFNBQVNUO1FBQ25DRSxlQUFlYSxHQUFHLENBQUNEO1FBQ25CLE9BQU87WUFDTFosZUFBZWMsTUFBTSxDQUFDRjtRQUN4QjtJQUNGLEdBQUcsRUFBRTtJQUVMLG9EQUFvRDtJQUNwRDFCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxNQUFrQixJQUFlWSxhQUFhO1FBRWxELElBQUk7WUFDRixNQUFNaUIsU0FBU0MsYUFBYUMsT0FBTyxDQUFDN0I7WUFDcEMsSUFBSTJCLFFBQVE7Z0JBQ1YsTUFBTUcsU0FBb0JDLEtB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cEMsQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhb0MsVUFBVSxLQUFJO1FBQ3ZDa0QsWUFBWXRGLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYXdELFVBQVUsS0FBSTtJQUN6QztBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlQ2FyZENhY2hlLnRzP2RjOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBHYWxsZXJ5Q2FyZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBmcm9udENvdmVyOiBzdHJpbmc7XG4gIGJhY2tDb3Zlcj86IHN0cmluZztcbiAgbGVmdFBhZ2U/OiBzdHJpbmc7XG4gIHJpZ2h0UGFnZT86IHN0cmluZztcbiAgY3JlYXRlZEF0OiBudW1iZXI7XG4gIGNyZWF0ZWRBdEZvcm1hdHRlZDogc3RyaW5nO1xuICBzaGFyZVVybD86IHN0cmluZztcbiAgaGFzSW1hZ2VzOiBib29sZWFuO1xuICBnZW5lcmF0ZWRQcm9tcHRzPzoge1xuICAgIGZyb250Q292ZXI/OiBzdHJpbmc7XG4gICAgYmFja0NvdmVyPzogc3RyaW5nO1xuICAgIGxlZnRJbnRlcmlvcj86IHN0cmluZztcbiAgICByaWdodEludGVyaW9yPzogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgQ2FyZENhY2hlIHtcbiAgY2FyZHM6IEdhbGxlcnlDYXJkW107XG4gIHRvdGFsQ291bnQ6IG51bWJlcjtcbiAgbGFzdEZldGNoZWQ6IG51bWJlcjtcbiAgaXNDb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ3ZpYmVjYXJkaW5nX3RlbXBsYXRlX2NhY2hlJztcbmNvbnN0IElNQUdFX0NBQ0hFX0tFWSA9ICd2aWJlY2FyZGluZ19pbWFnZV9jYWNoZSc7XG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IDEwICogNjAgKiAxMDAwOyAvLyAxMCBtaW51dGVzXG5jb25zdCBJTUFHRV9DQUNIRV9EVVJBVElPTiA9IDMwICogNjAgKiAxMDAwOyAvLyAzMCBtaW51dGVzXG5jb25zdCBCQUNLRU5EX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfQVBJX1VSTCB8fCAnaHR0cHM6Ly92aWJlY2FyZGluZy5jb20nO1xuY29uc3QgTUFYX0NPTkNVUlJFTlRfSU1BR0VTID0gMzsgLy8gTmV0ZmxpeC1zdHlsZTogVmVyeSBjb25zZXJ2YXRpdmUgY29uY3VycmVudCBsb2Fkc1xuXG4vLyBVc2UgdGhlIHJlZ3VsYXIgbGlzdCBlbmRwb2ludCAtIGl0J3MgZmFzdCBlbm91Z2ggYW5kIGFsd2F5cyBjdXJyZW50XG5jb25zdCBDQVJEU19MSVNUX1VSTCA9IGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9hcGkvY2FyZHMvbGlzdGA7XG5cbi8vIEdsb2JhbCBjYWNoZSBzdGF0ZVxubGV0IGdsb2JhbENhY2hlOiBDYXJkQ2FjaGUgfCBudWxsID0gbnVsbDtcbmxldCBpc1ByZWxvYWRpbmcgPSBmYWxzZTtcbmNvbnN0IGNhY2hlTGlzdGVuZXJzOiBTZXQ8KCkgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG5cbmNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgY2FjaGVMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VDYXJkQ2FjaGUgPSAoKSA9PiB7XG4gIGNvbnN0IFtjYWNoZSwgc2V0Q2FjaGVdID0gdXNlU3RhdGU8Q2FyZENhY2hlIHwgbnVsbD4oZ2xvYmFsQ2FjaGUpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjYWNoZSB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlQ2FjaGUgPSAoKSA9PiBzZXRDYWNoZShnbG9iYWxDYWNoZSk7XG4gICAgY2FjaGVMaXN0ZW5lcnMuYWRkKHVwZGF0ZUNhY2hlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FjaGVMaXN0ZW5lcnMuZGVsZXRlKHVwZGF0ZUNhY2hlKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudCAoYWZ0ZXIgaHlkcmF0aW9uKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCBnbG9iYWxDYWNoZSkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShDQUNIRV9LRVkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICBjb25zdCBwYXJzZWQ6IENhcmRDYWNoZSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgY29uc3QgaXNFeHBpcmVkID0gRGF0ZS5ub3coKSAtIHBhcnNlZC5sYXN0RmV0Y2hlZCA+IENBQ0hFX0RVUkFUSU9OO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFpc0V4cGlyZWQpIHtcbiAgICAgICAgICBnbG9iYWxDYWNoZSA9IHBhcnNlZDtcbiAgICAgICAgICBzZXRDYWNoZShwYXJzZWQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIExvYWRlZCBjYWNoZWQgdGVtcGxhdGUgY2FyZHM6JywgcGFyc2VkLmNhcmRzLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBFeHBpcmVkIGNhY2hlIHJlbW92ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBjYWNoZTonLCBlcnJvcik7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBsb2FkQ2FyZHMgPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyID0gMSwgc2VhcmNoOiBzdHJpbmcgPSAnJywgcmVzZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8R2FsbGVyeUNhcmRbXT4gPT4ge1xuICAgIC8vIElmIHdlIGhhdmUgY29tcGxldGUgY2FjaGUgYW5kIG5vIHNlYXJjaCwgcmV0dXJuIGNhY2hlZCBkYXRhIGltbWVkaWF0ZWx5XG4gICAgaWYgKCFzZWFyY2ggJiYgZ2xvYmFsQ2FjaGU/LmlzQ29tcGxldGUgJiYgIXJlc2V0KSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIDQwO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgNDA7XG4gICAgICByZXR1cm4gZ2xvYmFsQ2FjaGUuY2FyZHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIEZvciBzZWFyY2hlcyBvciB3aGVuIG5vIGNhY2hlLCBmZXRjaCBmcm9tIGxpc3QgZW5kcG9pbnRcbiAgICBpZiAoIXNlYXJjaCAmJiAocmVzZXQgfHwgIWdsb2JhbENhY2hlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIGNhcmRzIHdpdGggYSBsYXJnZSBwZXJfcGFnZSB0byBnZXQgZXZlcnl0aGluZyBhdCBvbmNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7Q0FSRFNfTElTVF9VUkx9P3Blcl9wYWdlPTEwMDAmdGVtcGxhdGVfbW9kZT10cnVlYCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgZGF0YS5jYXJkcyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY2FyZHMpKSB7XG4gICAgICAgICAgICAvLyBEZWR1cGxpY2F0ZSBjYXJkcyBieSBJRFxuICAgICAgICAgICAgY29uc3QgdW5pcXVlQ2FyZHMgPSBkYXRhLmNhcmRzLmZpbHRlcigoY2FyZCwgaW5kZXgsIHNlbGYpID0+IFxuICAgICAgICAgICAgICBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoKGMpID0+IGMuaWQgPT09IGNhcmQuaWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIGNhY2hlXG4gICAgICAgICAgICBnbG9iYWxDYWNoZSA9IHtcbiAgICAgICAgICAgICAgY2FyZHM6IHVuaXF1ZUNhcmRzLFxuICAgICAgICAgICAgICB0b3RhbENvdW50OiBkYXRhLnBhZ2luYXRpb24/LnRvdGFsIHx8IHVuaXF1ZUNhcmRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIGlzQ29tcGxldGU6IHRydWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShDQUNIRV9LRVksIEpTT04uc3RyaW5naWZ5KGdsb2JhbENhY2hlKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gcmVxdWVzdGVkIHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAocGFnZSAtIDEpICogNDA7XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyA0MDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmNhcmRzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTGlzdCBlbmRwb2ludCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBwYWdpbmF0ZWQgQVBJOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBvcmlnaW5hbCBwYWdpbmF0ZWQgQVBJXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBwYWdlOiBwYWdlLnRvU3RyaW5nKCksXG4gICAgICAgIHBlcl9wYWdlOiAnNDAnLFxuICAgICAgICAuLi4oc2VhcmNoICYmIHsgc2VhcmNoIH0pLFxuICAgICAgICB0ZW1wbGF0ZV9tb2RlOiAndHJ1ZSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9hcGkvY2FyZHMvbGlzdD8ke3BhcmFtc31gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICBjb25zdCBuZXdDYXJkcyA9IGRhdGEuY2FyZHMgYXMgR2FsbGVyeUNhcmRbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgY2FjaGUgZm9yIG5vbi1zZWFyY2ggcXVlcmllc1xuICAgICAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICAgIGlmIChyZXNldCB8fCAhZ2xvYmFsQ2FjaGUpIHtcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgICAgICBjYXJkczogbmV3Q2FyZHMsXG4gICAgICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEucGFnaW5hdGlvbi50b3RhbCxcbiAgICAgICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIGlzQ29tcGxldGU6ICFkYXRhLnBhZ2luYXRpb24uaGFzX25leHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBleGlzdGluZyBjYWNoZVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGdsb2JhbENhY2hlLmNhcmRzLm1hcChjYXJkID0+IGNhcmQuaWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5ld0NhcmRzID0gbmV3Q2FyZHMuZmlsdGVyKGNhcmQgPT4gIWV4aXN0aW5nSWRzLmhhcyhjYXJkLmlkKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgICAgICAuLi5nbG9iYWxDYWNoZSxcbiAgICAgICAgICAgICAgY2FyZHM6IFsuLi5nbG9iYWxDYWNoZS5jYXJkcywgLi4udW5pcXVlTmV3Q2FyZHNdLFxuICAgICAgICAgICAgICBsYXN0RmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZTogIWRhdGEucGFnaW5hdGlvbi5oYXNfbmV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0NhcmRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGxvYWQgY2FyZHMnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBjYXJkczonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9hZCBjYXJkcycpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHByZWxvYWRBbGxDYXJkcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNQcmVsb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGNvbXBsZXRlIGNhY2hlIHRoYXQncyBmcmVzaFxuICAgIGlmIChnbG9iYWxDYWNoZT8uaXNDb21wbGV0ZSkge1xuICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gZ2xvYmFsQ2FjaGUubGFzdEZldGNoZWQ7XG4gICAgICBpZiAoY2FjaGVBZ2UgPCBDQUNIRV9EVVJBVElPTikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFVzaW5nIGZyZXNoIGNhY2hlZCB0ZW1wbGF0ZSBkYXRhOicsIGdsb2JhbENhY2hlLmNhcmRzLmxlbmd0aCwgJ2NhcmRzJyk7XG4gICAgICAgIC8vIE5vIGltYWdlIHByZWxvYWRpbmcgLSBpbnN0YW50IHJlc3BvbnNlIGxpa2UgcmVmZXJlbmNlIHNpdGVcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBVc2luZyBmcmVzaCBjYWNoZWQgZGF0YSwgbm8gcHJlbG9hZGluZyBuZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzUHJlbG9hZGluZyA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgaW1tZWRpYXRlIHRlbXBsYXRlIHByZWxvYWQgb24gcGFnZSBsb2FkLi4uJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCBhbGwgY2FyZHMgZnJvbSBsaXN0IGVuZHBvaW50IChhbHdheXMgY3VycmVudCEpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0NBUkRTX0xJU1RfVVJMfT9wZXJfcGFnZT0xMDAwJnRlbXBsYXRlX21vZGU9dHJ1ZWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJyAmJiBkYXRhLmNhcmRzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jYXJkcykpIHtcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZSB3aXRoIGFsbCBjYXJkcyBhdCBvbmNlXG4gICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgIGNhcmRzOiBkYXRhLmNhcmRzLFxuICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEucGFnaW5hdGlvbj8udG90YWwgfHwgZGF0YS5jYXJkcy5sZW5ndGgsXG4gICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZSAvLyBXZSBoYXZlIGFsbCBjYXJkcyFcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIGNhY2hlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFBhZ2UgbG9hZCB0ZW1wbGF0ZSBwcmVsb2FkIGNvbXBsZXRlOicsIGRhdGEuY2FyZHMubGVuZ3RoLCAnY2FyZHMnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVsdHJhLXNpbXBsZTogTm8gaW1hZ2UgcHJlbG9hZGluZywgbGV0IGJyb3dzZXIgbGF6eSBsb2FkaW5nIGhhbmRsZSBpdFxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIENhcmRzIGxvYWRlZCwgbGV0dGluZyBicm93c2VyIGhhbmRsZSBpbWFnZSBsb2FkaW5nJyk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFN0YXRpYyBwcmVsb2FkIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIHBhZ2luYXRlZDonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBvbGQgbWV0aG9kIGlmIHN0YXRpYyBmYWlsc1xuICAgICAgYXdhaXQgcHJlbG9hZEFsbENhcmRzTGVnYWN5KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzUHJlbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIExlZ2FjeSBwcmVsb2FkIG1ldGhvZCBhcyBmYWxsYmFja1xuICBjb25zdCBwcmVsb2FkQWxsQ2FyZHNMZWdhY3kgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBwYWdlID0gMTtcbiAgICAgIGxldCBoYXNNb3JlID0gdHJ1ZTtcbiAgICAgIGxldCBhbGxDYXJkczogR2FsbGVyeUNhcmRbXSA9IFtdO1xuXG4gICAgICB3aGlsZSAoaGFzTW9yZSAmJiBwYWdlIDw9IDUpIHsgLy8gTGltaXQgdG8gNSBwYWdlcyBtYXhcbiAgICAgICAgY29uc3QgY2FyZHMgPSBhd2FpdCBsb2FkQ2FyZHMocGFnZSwgJycsIHBhZ2UgPT09IDEpO1xuICAgICAgICBhbGxDYXJkcyA9IHBhZ2UgPT09IDEgPyBjYXJkcyA6IFsuLi5hbGxDYXJkcywgLi4uY2FyZHNdO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBtb3JlIHBhZ2VzXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L2FwaS9jYXJkcy9saXN0P3BhZ2U9JHtwYWdlfSZwZXJfcGFnZT00MCZ0ZW1wbGF0ZV9tb2RlPXRydWVgKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaGFzTW9yZSA9IGRhdGEucGFnaW5hdGlvbj8uaGFzX25leHQgfHwgZmFsc2U7XG4gICAgICAgIHBhZ2UrKztcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBMZWdhY3kgcHJlbG9hZCBjb21wbGV0ZTonLCBhbGxDYXJkcy5sZW5ndGgsICdjYXJkcycpO1xuICAgICAgYXdhaXQgcHJlbG9hZEltYWdlcyhhbGxDYXJkcy5zbGljZSgwLCAyMCkpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBMZWdhY3kgcHJlbG9hZCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcmVsb2FkSW1hZ2VzID0gYXN5bmMgKGNhcmRzOiBHYWxsZXJ5Q2FyZFtdKSA9PiB7XG4gICAgLy8gRGlzYWJsZWQgZm9yIGluc3RhbnQgbG9hZGluZyBsaWtlIHJlZmVyZW5jZSBzaXRlXG4gICAgY29uc29sZS5sb2coJ/CfmoAgU2tpcHBpbmcgaW1hZ2UgcHJlbG9hZGluZyBmb3IgaW5zdGFudCByZXNwb25zZScpO1xuICAgIHJldHVybjtcbiAgfTtcblxuICBjb25zdCBnZXRDYWNoZWRDYXJkcyA9IHVzZUNhbGxiYWNrKChwYWdlOiBudW1iZXIgPSAxLCBpdGVtc1BlclBhZ2U6IG51bWJlciA9IDQwKTogR2FsbGVyeUNhcmRbXSA9PiB7XG4gICAgaWYgKCFnbG9iYWxDYWNoZSkgcmV0dXJuIFtdO1xuICAgIFxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAocGFnZSAtIDEpICogaXRlbXNQZXJQYWdlO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGl0ZW1zUGVyUGFnZTtcbiAgICByZXR1cm4gZ2xvYmFsQ2FjaGUuY2FyZHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2xlYXJDYWNoZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBnbG9iYWxDYWNoZSA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShDQUNIRV9LRVkpO1xuICAgIH1cbiAgICBzZXRDYWNoZShudWxsKTtcbiAgICBub3RpZnlMaXN0ZW5lcnMoKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgY2FjaGUsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGxvYWRDYXJkcyxcbiAgICBwcmVsb2FkQWxsQ2FyZHMsXG4gICAgZ2V0Q2FjaGVkQ2FyZHMsXG4gICAgY2xlYXJDYWNoZSxcbiAgICBoYXNDYWNoZTogISFnbG9iYWxDYWNoZSxcbiAgICBpc0NvbXBsZXRlOiBnbG9iYWxDYWNoZT8uaXNDb21wbGV0ZSB8fCBmYWxzZSxcbiAgICB0b3RhbENhcmRzOiBnbG9iYWxDYWNoZT8udG90YWxDb3VudCB8fCAwXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiQ0FDSEVfS0VZIiwiSU1BR0VfQ0FDSEVfS0VZIiwiQ0FDSEVfRFVSQVRJT04iLCJJTUFHRV9DQUNIRV9EVVJBVElPTiIsIkJBQ0tFTkRfQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JBQ0tFTkRfQVBJX1VSTCIsIk1BWF9DT05DVVJSRU5UX0lNQUdFUyIsIkNBUkRTX0xJU1RfVVJMIiwiZ2xvYmFsQ2FjaGUiLCJpc1ByZWxvYWRpbmciLCJjYWNoZUxpc3RlbmVycyIsIlNldCIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsaXN0ZW5lciIsInVzZUNhcmRDYWNoZSIsImNhY2hlIiwic2V0Q2FjaGUiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwidXBkYXRlQ2FjaGUiLCJhZGQiLCJkZWxldGUiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwiaXNFeHBpcmVkIiwiRGF0ZSIsIm5vdyIsImxhc3RGZXRjaGVkIiwiY29uc29sZSIsImxvZyIsImNhcmRzIiwibGVuZ3RoIiwicmVtb3ZlSXRlbSIsImxvYWRDYXJkcyIsInBhZ2UiLCJzZWFyY2giLCJyZXNldCIsImlzQ29tcGxldGUiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzbGljZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImRhdGEiLCJqc29uIiwic3RhdHVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlQ2FyZHMiLCJmaWx0ZXIiLCJjYXJkIiwiaW5kZXgiLCJzZWxmIiwiZmluZEluZGV4IiwiYyIsImlkIiwidG90YWxDb3VudCIsInBhZ2luYXRpb24iLCJ0b3RhbCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ3YXJuIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJwZXJfcGFnZSIsInRlbXBsYXRlX21vZGUiLCJFcnJvciIsInN0YXR1c1RleHQiLCJuZXdDYXJkcyIsImhhc19uZXh0IiwiZXhpc3RpbmdJZHMiLCJtYXAiLCJ1bmlxdWVOZXdDYXJkcyIsImhhcyIsIm1lc3NhZ2UiLCJwcmVsb2FkQWxsQ2FyZHMiLCJjYWNoZUFnZSIsInByZWxvYWRBbGxDYXJkc0xlZ2FjeSIsImhhc01vcmUiLCJhbGxDYXJkcyIsInByZWxvYWRJbWFnZXMiLCJnZXRDYWNoZWRDYXJkcyIsIml0ZW1zUGVyUGFnZSIsImNsZWFyQ2FjaGUiLCJoYXNDYWNoZSIsInRvdGFsQ2FyZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardCache.ts\n"));

/***/ })

});
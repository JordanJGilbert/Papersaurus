"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardForm.tsx":
/*!*******************************!*\
  !*** ./hooks/useCardForm.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardForm: function() { return /* binding */ useCardForm; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/storageManager */ \"(app-pages-browser)/./lib/storageManager.ts\");\n/* __next_internal_client_entry_do_not_use__ useCardForm auto */ var _s = $RefreshSig$();\n\n\nconst defaultFormData = {\n    // Step 1: Card Basics\n    selectedType: \"birthday\",\n    customCardType: \"\",\n    selectedTone: \"funny\",\n    toField: \"\",\n    fromField: \"\",\n    relationshipField: \"\",\n    // Step 2: Content Creation\n    prompt: \"\",\n    finalCardMessage: \"\",\n    isHandwrittenMessage: false,\n    // Step 3: Personalization\n    selectedArtisticStyle: \"ai-smart-style\",\n    customStyleDescription: \"\",\n    referenceImages: [],\n    referenceImageUrls: [],\n    // Step 4: Details\n    userEmail: \"\",\n    selectedImageModel: \"gpt-image-1\",\n    selectedDraftModel: \"gpt-image-1\",\n    selectedPaperSize: \"standard\",\n    numberOfCards: 1,\n    isFrontBackOnly: false\n};\n// Helper function to create serializable form data (excludes File objects)\nconst createSerializableFormData = (formData)=>{\n    const { referenceImages, ...serializableData } = formData;\n    return serializableData;\n};\nfunction useCardForm() {\n    _s();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultFormData);\n    const [wizardState, setWizardState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        currentStep: 1,\n        completedSteps: []\n    });\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Initialize form data from storage on component mount (after hydration)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ( true && !isInitialLoadComplete) {\n            const session = _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.getSession();\n            if (session) {\n                setFormData({\n                    ...defaultFormData,\n                    ...session.formData,\n                    referenceImages: []\n                });\n                setWizardState(session.wizardState);\n            }\n            setIsInitialLoadComplete(true);\n        }\n    }, [\n        isInitialLoadComplete\n    ]);\n    // Save form data to storage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialLoadComplete) return;\n        const serializableData = createSerializableFormData(formData);\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.saveSession(serializableData, wizardState);\n    }, [\n        formData,\n        wizardState,\n        isInitialLoadComplete\n    ]);\n    const updateFormData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setFormData((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const resetForm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFormData(defaultFormData);\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearSession();\n    }, []);\n    const clearStoredData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearAll();\n    }, []);\n    const updateWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const markStepCompleted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                completedSteps: prev.completedSteps.includes(step) ? prev.completedSteps : [\n                    ...prev.completedSteps,\n                    step\n                ]\n            }));\n    }, []);\n    const resetWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n    }, []);\n    const validateStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        switch(step){\n            case 1:\n                // Card type is required\n                if (!formData.selectedType) return false;\n                // If custom type is selected, custom description is required\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) return false;\n                // Tone is required\n                if (!formData.selectedTone) return false;\n                // If photos are uploaded, they must have descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    // Check if we have photoReferences data\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) return false;\n                    // Check if all photos have descriptions\n                    const allHaveDescriptions = formData.photoReferences.every((ref)=>ref.description && ref.description.trim());\n                    if (!allHaveDescriptions) return false;\n                }\n                return true;\n            case 2:\n                // All fields are optional - let AI generate defaults\n                return true;\n            case 3:\n                // All fields are optional\n                // If custom style is selected, description is required\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) return false;\n                // If reference images with incompatible model\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") return false;\n                return true;\n            case 4:\n                // Email is required\n                if (!formData.userEmail.trim()) return false;\n                // Basic email validation\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                if (!emailRegex.test(formData.userEmail)) return false;\n                return true;\n            case 5:\n                // All previous steps must be valid\n                return validateStep(1) && validateStep(2) && validateStep(3) && validateStep(4);\n            default:\n                return false;\n        }\n    }, [\n        formData\n    ]);\n    const getStepSummary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const summary = [];\n        switch(step){\n            case 1:\n                const cardType = formData.selectedType === \"custom\" ? formData.customCardType : formData.selectedType;\n                summary.push(\"Card Type: \".concat(cardType || \"Not selected\"));\n                summary.push(\"Tone: \".concat(formData.selectedTone || \"Not selected\"));\n                if (formData.toField) summary.push(\"To: \".concat(formData.toField));\n                if (formData.fromField) summary.push(\"From: \".concat(formData.fromField));\n                break;\n            case 2:\n                if (formData.prompt) summary.push(\"Description: \".concat(formData.prompt.substring(0, 50), \"...\"));\n                if (formData.finalCardMessage) summary.push(\"Message: \".concat(formData.finalCardMessage.substring(0, 50), \"...\"));\n                if (formData.isHandwrittenMessage) summary.push(\"Handwritten message space included\");\n                break;\n            case 3:\n                summary.push(\"Style: \".concat(formData.selectedArtisticStyle));\n                if (formData.referenceImageUrls.length > 0) {\n                    summary.push(\"Reference photos: \".concat(formData.referenceImageUrls.length, \" uploaded\"));\n                }\n                break;\n            case 4:\n                summary.push(\"Email: \".concat(formData.userEmail));\n                summary.push(\"Model: \".concat(formData.selectedImageModel));\n                summary.push(\"Paper: \".concat(formData.selectedPaperSize));\n                if (formData.isFrontBackOnly) summary.push(\"Front/back only\");\n                break;\n        }\n        return summary;\n    }, [\n        formData\n    ]);\n    const getValidationErrors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const errors = [];\n        switch(step){\n            case 1:\n                if (!formData.selectedType) errors.push(\"Please select a card type\");\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) {\n                    errors.push(\"Please describe your custom card type\");\n                }\n                if (!formData.selectedTone) errors.push(\"Please select a tone\");\n                // Check photo descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) {\n                        errors.push(\"Please describe who's in your photos\");\n                    } else {\n                        const missingDescriptions = formData.photoReferences.filter((ref)=>!ref.description || !ref.description.trim()).length;\n                        if (missingDescriptions > 0) {\n                            errors.push(\"Please describe who's in \".concat(missingDescriptions, \" photo\").concat(missingDescriptions > 1 ? \"s\" : \"\"));\n                        }\n                    }\n                }\n                break;\n            case 3:\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) {\n                    errors.push(\"Please describe your custom artistic style\");\n                }\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") {\n                    errors.push(\"Reference photos are only supported with GPT Image 1 model\");\n                }\n                break;\n            case 4:\n                if (!formData.userEmail.trim()) {\n                    errors.push(\"Email address is required\");\n                } else {\n                    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                    if (!emailRegex.test(formData.userEmail)) {\n                        errors.push(\"Please enter a valid email address\");\n                    }\n                }\n                break;\n        }\n        return errors;\n    }, [\n        formData\n    ]);\n    return {\n        formData,\n        updateFormData,\n        resetForm,\n        clearStoredData,\n        validateStep,\n        getStepSummary,\n        getValidationErrors,\n        isInitialLoadComplete,\n        wizardState: {\n            ...wizardState,\n            updateCurrentStep: (step)=>updateWizardState({\n                    currentStep: step\n                }),\n            markStepCompleted,\n            resetWizardState\n        },\n        updateWizardState\n    };\n}\n_s(useCardForm, \"YXsICAdHNvhScUcXpS7y9ubE7jc=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUV5RDtBQUNWO0FBZ0MvQyxNQUFNSSxrQkFBZ0M7SUFDcEMsc0JBQXNCO0lBQ3RCQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsbUJBQW1CO0lBRW5CLDJCQUEyQjtJQUMzQkMsUUFBUTtJQUNSQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUV0QiwwQkFBMEI7SUFDMUJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxpQkFBaUIsRUFBRTtJQUNuQkMsb0JBQW9CLEVBQUU7SUFFdEIsa0JBQWtCO0lBQ2xCQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsb0JBQW9CO0lBQ3BCQyxtQkFBbUI7SUFDbkJDLGVBQWU7SUFDZkMsaUJBQWlCO0FBQ25CO0FBRUEsMkVBQTJFO0FBQzNFLE1BQU1DLDZCQUE2QixDQUFDQztJQUNsQyxNQUFNLEVBQUVULGVBQWUsRUFBRSxHQUFHVSxrQkFBa0IsR0FBR0Q7SUFDakQsT0FBT0M7QUFDVDtBQUVPLFNBQVNDOztJQUNkLE1BQU0sQ0FBQ0YsVUFBVUcsWUFBWSxHQUFHNUIsK0NBQVFBLENBQWVJO0lBQ3ZELE1BQU0sQ0FBQ3lCLGFBQWFDLGVBQWUsR0FBRzlCLCtDQUFRQSxDQUFDO1FBQUUrQixhQUFhO1FBQUdDLGdCQUFnQixFQUFFO0lBQWE7SUFDaEcsTUFBTSxDQUFDQyx1QkFBdUJDLHlCQUF5QixHQUFHbEMsK0NBQVFBLENBQUM7SUFFbkUseUVBQXlFO0lBQ3pFRSxnREFBU0EsQ0FBQztRQUNSLElBQUksS0FBa0IsSUFBZSxDQUFDK0IsdUJBQXVCO1lBQzNELE1BQU1FLFVBQVVoQyx3REFBT0EsQ0FBQ2lDLFVBQVU7WUFDbEMsSUFBSUQsU0FBUztnQkFDWFAsWUFBWTtvQkFDVixHQUFHeEIsZUFBZTtvQkFDbEIsR0FBRytCLFFBQVFWLFFBQVE7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O1lBQ1gsR0FBR0EsV0FBVztZQUNkd0MsbUJBQW1CLENBQUN0QixPQUFpQkYsa0JBQWtCO29CQUFFZCxhQUFhZ0I7Z0JBQUs7WUFDM0VEO1lBQ0FHO1FBQ0Y7UUFDQUo7SUFDRjtBQUNGO0dBaE5nQmxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeD80YzM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gXCJAL2xpYi9zdG9yYWdlTWFuYWdlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRGb3JtRGF0YSB7XG4gIC8vIFN0ZXAgMTogQ2FyZCBCYXNpY3NcbiAgc2VsZWN0ZWRUeXBlOiBzdHJpbmc7XG4gIGN1c3RvbUNhcmRUeXBlOiBzdHJpbmc7XG4gIHNlbGVjdGVkVG9uZTogc3RyaW5nO1xuICB0b0ZpZWxkOiBzdHJpbmc7XG4gIGZyb21GaWVsZDogc3RyaW5nO1xuICByZWxhdGlvbnNoaXBGaWVsZDogc3RyaW5nO1xuXG4gIC8vIFN0ZXAgMjogQ29udGVudCBDcmVhdGlvblxuICBwcm9tcHQ6IHN0cmluZztcbiAgZmluYWxDYXJkTWVzc2FnZTogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogYm9vbGVhbjtcblxuICAvLyBTdGVwIDM6IFBlcnNvbmFsaXphdGlvblxuICBzZWxlY3RlZEFydGlzdGljU3R5bGU6IHN0cmluZztcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogc3RyaW5nO1xuICByZWZlcmVuY2VJbWFnZXM6IEZpbGVbXTtcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBzdHJpbmdbXTtcbiAgcGhvdG9SZWZlcmVuY2VzPzogQXJyYXk8eyBpbWFnZVVybDogc3RyaW5nOyBpbWFnZUluZGV4OiBudW1iZXI7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyB9PjtcblxuICAvLyBTdGVwIDQ6IERldGFpbHNcbiAgdXNlckVtYWlsOiBzdHJpbmc7XG4gIHNlbGVjdGVkSW1hZ2VNb2RlbDogc3RyaW5nO1xuICBzZWxlY3RlZERyYWZ0TW9kZWw6IHN0cmluZztcbiAgc2VsZWN0ZWRQYXBlclNpemU6IHN0cmluZztcbiAgbnVtYmVyT2ZDYXJkczogbnVtYmVyO1xuICBpc0Zyb250QmFja09ubHk6IGJvb2xlYW47XG59XG5cbmNvbnN0IGRlZmF1bHRGb3JtRGF0YTogQ2FyZEZvcm1EYXRhID0ge1xuICAvLyBTdGVwIDE6IENhcmQgQmFzaWNzXG4gIHNlbGVjdGVkVHlwZTogXCJiaXJ0aGRheVwiLFxuICBjdXN0b21DYXJkVHlwZTogXCJcIixcbiAgc2VsZWN0ZWRUb25lOiBcImZ1bm55XCIsXG4gIHRvRmllbGQ6IFwiXCIsXG4gIGZyb21GaWVsZDogXCJcIixcbiAgcmVsYXRpb25zaGlwRmllbGQ6IFwiXCIsXG5cbiAgLy8gU3RlcCAyOiBDb250ZW50IENyZWF0aW9uXG4gIHByb21wdDogXCJcIixcbiAgZmluYWxDYXJkTWVzc2FnZTogXCJcIixcbiAgaXNIYW5kd3JpdHRlbk1lc3NhZ2U6IGZhbHNlLFxuXG4gIC8vIFN0ZXAgMzogUGVyc29uYWxpemF0aW9uXG4gIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZTogXCJhaS1zbWFydC1zdHlsZVwiLFxuICBjdXN0b21TdHlsZURlc2NyaXB0aW9uOiBcIlwiLFxuICByZWZlcmVuY2VJbWFnZXM6IFtdLFxuICByZWZlcmVuY2VJbWFnZVVybHM6IFtdLFxuXG4gIC8vIFN0ZXAgNDogRGV0YWlsc1xuICB1c2VyRW1haWw6IFwiXCIsXG4gIHNlbGVjdGVkSW1hZ2VNb2RlbDogXCJncHQtaW1hZ2UtMVwiLFxuICBzZWxlY3RlZERyYWZ0TW9kZWw6IFwiZ3B0LWltYWdlLTFcIixcbiAgc2VsZWN0ZWRQYXBlclNpemU6IFwic3RhbmRhcmRcIixcbiAgbnVtYmVyT2ZDYXJkczogMSxcbiAgaXNGcm9udEJhY2tPbmx5OiBmYWxzZSxcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc2VyaWFsaXphYmxlIGZvcm0gZGF0YSAoZXhjbHVkZXMgRmlsZSBvYmplY3RzKVxuY29uc3QgY3JlYXRlU2VyaWFsaXphYmxlRm9ybURhdGEgPSAoZm9ybURhdGE6IENhcmRGb3JtRGF0YSk6IE9taXQ8Q2FyZEZvcm1EYXRhLCAncmVmZXJlbmNlSW1hZ2VzJz4gPT4ge1xuICBjb25zdCB7IHJlZmVyZW5jZUltYWdlcywgLi4uc2VyaWFsaXphYmxlRGF0YSB9ID0gZm9ybURhdGE7XG4gIHJldHVybiBzZXJpYWxpemFibGVEYXRhO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhcmRGb3JtKCkge1xuICBjb25zdCBbZm9ybURhdGEsIHNldEZvcm1EYXRhXSA9IHVzZVN0YXRlPENhcmRGb3JtRGF0YT4oZGVmYXVsdEZvcm1EYXRhKTtcbiAgY29uc3QgW3dpemFyZFN0YXRlLCBzZXRXaXphcmRTdGF0ZV0gPSB1c2VTdGF0ZSh7IGN1cnJlbnRTdGVwOiAxLCBjb21wbGV0ZWRTdGVwczogW10gYXMgbnVtYmVyW10gfSk7XG4gIGNvbnN0IFtpc0luaXRpYWxMb2FkQ29tcGxldGUsIHNldElzSW5pdGlhbExvYWRDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBmb3JtIGRhdGEgZnJvbSBzdG9yYWdlIG9uIGNvbXBvbmVudCBtb3VudCAoYWZ0ZXIgaHlkcmF0aW9uKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhaXNJbml0aWFsTG9hZENvbXBsZXRlKSB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBzZXRGb3JtRGF0YSh7XG4gICAgICAgICAgLi4uZGVmYXVsdEZvcm1EYXRhLFxuICAgICAgICAgIC4uLnNlc3Npb24uZm9ybURhdGEsXG4gICAgICAgICAgcmVmZXJlbmNlSW1hZ2VzOiBbXSwgLy8gQWx3YXlzIHJlc2V0IEZpbGUgb2JqZWN0c1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0V2l6YXJkU3RhdGUoc2Vzc2lvbi53aXphcmRTdGF0ZSk7XG4gICAgICB9XG4gICAgICBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGUodHJ1ZSk7XG4gICAgfVxuICB9LCBbaXNJbml0aWFsTG9hZENvbXBsZXRlXSk7XG5cbiAgLy8gU2F2ZSBmb3JtIGRhdGEgdG8gc3RvcmFnZSB3aGVuZXZlciBpdCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0luaXRpYWxMb2FkQ29tcGxldGUpIHJldHVybjtcblxuICAgIGNvbnN0IHNlcmlhbGl6YWJsZURhdGEgPSBjcmVhdGVTZXJpYWxpemFibGVGb3JtRGF0YShmb3JtRGF0YSk7XG4gICAgc3RvcmFnZS5zYXZlU2Vzc2lvbihzZXJpYWxpemFibGVEYXRhLCB3aXphcmRTdGF0ZSk7XG4gIH0sIFtmb3JtRGF0YSwgd2l6YXJkU3RhdGUsIGlzSW5pdGlhbExvYWRDb21wbGV0ZV0pO1xuXG4gIGNvbnN0IHVwZGF0ZUZvcm1EYXRhID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXM6IFBhcnRpYWw8Q2FyZEZvcm1EYXRhPikgPT4ge1xuICAgIHNldEZvcm1EYXRhKHByZXYgPT4gKHsgLi4ucHJldiwgLi4udXBkYXRlcyB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCByZXNldEZvcm0gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0Rm9ybURhdGEoZGVmYXVsdEZvcm1EYXRhKTtcbiAgICBzZXRXaXphcmRTdGF0ZSh7IGN1cnJlbnRTdGVwOiAxLCBjb21wbGV0ZWRTdGVwczogW10gfSk7XG4gICAgc3RvcmFnZS5jbGVhclNlc3Npb24oKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNsZWFyU3RvcmVkRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzdG9yYWdlLmNsZWFyQWxsKCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCB1cGRhdGVXaXphcmRTdGF0ZSA9IHVzZUNhbGxiYWNrKCh1cGRhdGVzOiBQYXJ0aWFsPHR5cGVvZiB3aXphcmRTdGF0ZT4pID0+IHtcbiAgICBzZXRXaXphcmRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIC4uLnVwZGF0ZXMgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbWFya1N0ZXBDb21wbGV0ZWQgPSB1c2VDYWxsYmFjaygoc3RlcDogbnVtYmVyKSA9PiB7XG4gICAgc2V0V2l6YXJkU3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGNvbXBsZXRlZFN0ZXBzOiBwcmV2LmNvbXBsZXRlZFN0ZXBzLmluY2x1ZGVzKHN0ZXApIFxuICAgICAgICA/IHByZXYuY29tcGxldGVkU3RlcHMgXG4gICAgICAgIDogWy4uLnByZXYuY29tcGxldGVkU3RlcHMsIHN0ZXBdXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVzZXRXaXphcmRTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRXaXphcmRTdGF0ZSh7IGN1cnJlbnRTdGVwOiAxLCBjb21wbGV0ZWRTdGVwczogW10gfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCB2YWxpZGF0ZVN0ZXAgPSB1c2VDYWxsYmFjaygoc3RlcDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE6IC8vIENhcmQgQmFzaWNzXG4gICAgICAgIC8vIENhcmQgdHlwZSBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoIWZvcm1EYXRhLnNlbGVjdGVkVHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBjdXN0b20gdHlwZSBpcyBzZWxlY3RlZCwgY3VzdG9tIGRlc2NyaXB0aW9uIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbUNhcmRUeXBlLnRyaW0oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUb25lIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmICghZm9ybURhdGEuc2VsZWN0ZWRUb25lKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHBob3RvcyBhcmUgdXBsb2FkZWQsIHRoZXkgbXVzdCBoYXZlIGRlc2NyaXB0aW9uc1xuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHBob3RvUmVmZXJlbmNlcyBkYXRhXG4gICAgICAgICAgaWYgKCFmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMgfHwgZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIC8vIENoZWNrIGlmIGFsbCBwaG90b3MgaGF2ZSBkZXNjcmlwdGlvbnNcbiAgICAgICAgICBjb25zdCBhbGxIYXZlRGVzY3JpcHRpb25zID0gZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzLmV2ZXJ5KHJlZiA9PiByZWYuZGVzY3JpcHRpb24gJiYgcmVmLmRlc2NyaXB0aW9uLnRyaW0oKSk7XG4gICAgICAgICAgaWYgKCFhbGxIYXZlRGVzY3JpcHRpb25zKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgMjogLy8gQ29udGVudCBDcmVhdGlvblxuICAgICAgICAvLyBBbGwgZmllbGRzIGFyZSBvcHRpb25hbCAtIGxldCBBSSBnZW5lcmF0ZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSAzOiAvLyBQZXJzb25hbGl6YXRpb25cbiAgICAgICAgLy8gQWxsIGZpZWxkcyBhcmUgb3B0aW9uYWxcbiAgICAgICAgLy8gSWYgY3VzdG9tIHN0eWxlIGlzIHNlbGVjdGVkLCBkZXNjcmlwdGlvbiBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoZm9ybURhdGEuc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFmb3JtRGF0YS5jdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiByZWZlcmVuY2UgaW1hZ2VzIHdpdGggaW5jb21wYXRpYmxlIG1vZGVsXG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBmb3JtRGF0YS5zZWxlY3RlZEltYWdlTW9kZWwgIT09IFwiZ3B0LWltYWdlLTFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSA0OiAvLyBEZXRhaWxzXG4gICAgICAgIC8vIEVtYWlsIGlzIHJlcXVpcmVkXG4gICAgICAgIGlmICghZm9ybURhdGEudXNlckVtYWlsLnRyaW0oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBCYXNpYyBlbWFpbCB2YWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoZm9ybURhdGEudXNlckVtYWlsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSA1OiAvLyBHZW5lcmF0ZVxuICAgICAgICAvLyBBbGwgcHJldmlvdXMgc3RlcHMgbXVzdCBiZSB2YWxpZFxuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdGVwKDEpICYmIHZhbGlkYXRlU3RlcCgyKSAmJiB2YWxpZGF0ZVN0ZXAoMykgJiYgdmFsaWRhdGVTdGVwKDQpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBbZm9ybURhdGFdKTtcblxuICBjb25zdCBnZXRTdGVwU3VtbWFyeSA9IHVzZUNhbGxiYWNrKChzdGVwOiBudW1iZXIpOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3Qgc3VtbWFyeTogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY29uc3QgY2FyZFR5cGUgPSBmb3JtRGF0YS5zZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgPyBmb3JtRGF0YS5jdXN0b21DYXJkVHlwZSA6IGZvcm1EYXRhLnNlbGVjdGVkVHlwZTtcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBDYXJkIFR5cGU6ICR7Y2FyZFR5cGUgfHwgXCJOb3Qgc2VsZWN0ZWRcIn1gKTtcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBUb25lOiAke2Zvcm1EYXRhLnNlbGVjdGVkVG9uZSB8fCBcIk5vdCBzZWxlY3RlZFwifWApO1xuICAgICAgICBpZiAoZm9ybURhdGEudG9GaWVsZCkgc3VtbWFyeS5wdXNoKGBUbzogJHtmb3JtRGF0YS50b0ZpZWxkfWApO1xuICAgICAgICBpZiAoZm9ybURhdGEuZnJvbUZpZWxkKSBzdW1tYXJ5LnB1c2goYEZyb206ICR7Zm9ybURhdGEuZnJvbUZpZWxkfWApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAoZm9ybURhdGEucHJvbXB0KSBzdW1tYXJ5LnB1c2goYERlc2NyaXB0aW9uOiAke2Zvcm1EYXRhLnByb21wdC5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xuICAgICAgICBpZiAoZm9ybURhdGEuZmluYWxDYXJkTWVzc2FnZSkgc3VtbWFyeS5wdXNoKGBNZXNzYWdlOiAke2Zvcm1EYXRhLmZpbmFsQ2FyZE1lc3NhZ2Uuc3Vic3RyaW5nKDAsIDUwKX0uLi5gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLmlzSGFuZHdyaXR0ZW5NZXNzYWdlKSBzdW1tYXJ5LnB1c2goXCJIYW5kd3JpdHRlbiBtZXNzYWdlIHNwYWNlIGluY2x1ZGVkXCIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBzdW1tYXJ5LnB1c2goYFN0eWxlOiAke2Zvcm1EYXRhLnNlbGVjdGVkQXJ0aXN0aWNTdHlsZX1gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3VtbWFyeS5wdXNoKGBSZWZlcmVuY2UgcGhvdG9zOiAke2Zvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGh9IHVwbG9hZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBFbWFpbDogJHtmb3JtRGF0YS51c2VyRW1haWx9YCk7XG4gICAgICAgIHN1bW1hcnkucHVzaChgTW9kZWw6ICR7Zm9ybURhdGEuc2VsZWN0ZWRJbWFnZU1vZGVsfWApO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYFBhcGVyOiAke2Zvcm1EYXRhLnNlbGVjdGVkUGFwZXJTaXplfWApO1xuICAgICAgICBpZiAoZm9ybURhdGEuaXNGcm9udEJhY2tPbmx5KSBzdW1tYXJ5LnB1c2goXCJGcm9udC9iYWNrIG9ubHlcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBzdW1tYXJ5O1xuICB9LCBbZm9ybURhdGFdKTtcblxuICBjb25zdCBnZXRWYWxpZGF0aW9uRXJyb3JzID0gdXNlQ2FsbGJhY2soKHN0ZXA6IG51bWJlcik6IHN0cmluZ1tdID0+IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFR5cGUpIGVycm9ycy5wdXNoKFwiUGxlYXNlIHNlbGVjdCBhIGNhcmQgdHlwZVwiKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLnNlbGVjdGVkVHlwZSA9PT0gXCJjdXN0b21cIiAmJiAhZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUudHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gY2FyZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9ybURhdGEuc2VsZWN0ZWRUb25lKSBlcnJvcnMucHVzaChcIlBsZWFzZSBzZWxlY3QgYSB0b25lXCIpO1xuICAgICAgICAvLyBDaGVjayBwaG90byBkZXNjcmlwdGlvbnNcbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKCFmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMgfHwgZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgZGVzY3JpYmUgd2hvJ3MgaW4geW91ciBwaG90b3NcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdEZXNjcmlwdGlvbnMgPSBmb3JtRGF0YS5waG90b1JlZmVyZW5jZXMuZmlsdGVyKHJlZiA9PiAhcmVmLmRlc2NyaXB0aW9uIHx8ICFyZWYuZGVzY3JpcHRpb24udHJpbSgpKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobWlzc2luZ0Rlc2NyaXB0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYFBsZWFzZSBkZXNjcmliZSB3aG8ncyBpbiAke21pc3NpbmdEZXNjcmlwdGlvbnN9IHBob3RvJHttaXNzaW5nRGVzY3JpcHRpb25zID4gMSA/ICdzJyA6ICcnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBpZiAoZm9ybURhdGEuc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFmb3JtRGF0YS5jdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIGRlc2NyaWJlIHlvdXIgY3VzdG9tIGFydGlzdGljIHN0eWxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCAmJiBmb3JtRGF0YS5zZWxlY3RlZEltYWdlTW9kZWwgIT09IFwiZ3B0LWltYWdlLTFcIikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiUmVmZXJlbmNlIHBob3RvcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBHUFQgSW1hZ2UgMSBtb2RlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA0OlxuICAgICAgICBpZiAoIWZvcm1EYXRhLnVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcIkVtYWlsIGFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGZvcm1EYXRhLnVzZXJFbWFpbCkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbiAgfSwgW2Zvcm1EYXRhXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtRGF0YSxcbiAgICB1cGRhdGVGb3JtRGF0YSxcbiAgICByZXNldEZvcm0sXG4gICAgY2xlYXJTdG9yZWREYXRhLFxuICAgIHZhbGlkYXRlU3RlcCxcbiAgICBnZXRTdGVwU3VtbWFyeSxcbiAgICBnZXRWYWxpZGF0aW9uRXJyb3JzLFxuICAgIGlzSW5pdGlhbExvYWRDb21wbGV0ZSxcbiAgICB3aXphcmRTdGF0ZToge1xuICAgICAgLi4ud2l6YXJkU3RhdGUsXG4gICAgICB1cGRhdGVDdXJyZW50U3RlcDogKHN0ZXA6IG51bWJlcikgPT4gdXBkYXRlV2l6YXJkU3RhdGUoeyBjdXJyZW50U3RlcDogc3RlcCB9KSxcbiAgICAgIG1hcmtTdGVwQ29tcGxldGVkLFxuICAgICAgcmVzZXRXaXphcmRTdGF0ZSxcbiAgICB9LFxuICAgIHVwZGF0ZVdpemFyZFN0YXRlLFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInN0b3JhZ2UiLCJkZWZhdWx0Rm9ybURhdGEiLCJzZWxlY3RlZFR5cGUiLCJjdXN0b21DYXJkVHlwZSIsInNlbGVjdGVkVG9uZSIsInRvRmllbGQiLCJmcm9tRmllbGQiLCJyZWxhdGlvbnNoaXBGaWVsZCIsInByb21wdCIsImZpbmFsQ2FyZE1lc3NhZ2UiLCJpc0hhbmR3cml0dGVuTWVzc2FnZSIsInNlbGVjdGVkQXJ0aXN0aWNTdHlsZSIsImN1c3RvbVN0eWxlRGVzY3JpcHRpb24iLCJyZWZlcmVuY2VJbWFnZXMiLCJyZWZlcmVuY2VJbWFnZVVybHMiLCJ1c2VyRW1haWwiLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJzZWxlY3RlZERyYWZ0TW9kZWwiLCJzZWxlY3RlZFBhcGVyU2l6ZSIsIm51bWJlck9mQ2FyZHMiLCJpc0Zyb250QmFja09ubHkiLCJjcmVhdGVTZXJpYWxpemFibGVGb3JtRGF0YSIsImZvcm1EYXRhIiwic2VyaWFsaXphYmxlRGF0YSIsInVzZUNhcmRGb3JtIiwic2V0Rm9ybURhdGEiLCJ3aXphcmRTdGF0ZSIsInNldFdpemFyZFN0YXRlIiwiY3VycmVudFN0ZXAiLCJjb21wbGV0ZWRTdGVwcyIsImlzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNldElzSW5pdGlhbExvYWRDb21wbGV0ZSIsInNlc3Npb24iLCJnZXRTZXNzaW9uIiwic2F2ZVNlc3Npb24iLCJ1cGRhdGVGb3JtRGF0YSIsInVwZGF0ZXMiLCJwcmV2IiwicmVzZXRGb3JtIiwiY2xlYXJTZXNzaW9uIiwiY2xlYXJTdG9yZWREYXRhIiwiY2xlYXJBbGwiLCJ1cGRhdGVXaXphcmRTdGF0ZSIsIm1hcmtTdGVwQ29tcGxldGVkIiwic3RlcCIsImluY2x1ZGVzIiwicmVzZXRXaXphcmRTdGF0ZSIsInZhbGlkYXRlU3RlcCIsInRyaW0iLCJsZW5ndGgiLCJwaG90b1JlZmVyZW5jZXMiLCJhbGxIYXZlRGVzY3JpcHRpb25zIiwiZXZlcnkiLCJyZWYiLCJkZXNjcmlwdGlvbiIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwiZ2V0U3RlcFN1bW1hcnkiLCJzdW1tYXJ5IiwiY2FyZFR5cGUiLCJwdXNoIiwic3Vic3RyaW5nIiwiZ2V0VmFsaWRhdGlvbkVycm9ycyIsImVycm9ycyIsIm1pc3NpbmdEZXNjcmlwdGlvbnMiLCJmaWx0ZXIiLCJ1cGRhdGVDdXJyZW50U3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardForm.tsx\n"));

/***/ })

});
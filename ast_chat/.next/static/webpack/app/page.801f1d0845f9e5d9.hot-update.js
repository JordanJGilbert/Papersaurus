"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts":
/*!*********************************************!*\
  !*** ./hooks/cardStudio/useFileHandling.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFileHandling: function() { return /* binding */ useFileHandling; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useFileHandling auto */ \n\n\nfunction useFileHandling() {\n    const [handwritingSample, setHandwritingSample] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [handwritingSampleUrl, setHandwritingSampleUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [referenceImages, setReferenceImages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [referenceImageUrls, setReferenceImageUrls] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [imageTransformation, setImageTransformation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Photo analysis state\n    const [photoAnalyses, setPhotoAnalyses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isAnalyzing, setIsAnalyzing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [showAnalysisModal, setShowAnalysisModal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [pendingAnalysisIndex, setPendingAnalysisIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // File upload handler\n    const handleFileUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (file, type)=>{\n        if (!file.type.startsWith(\"image/\")) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please upload an image file\");\n            return;\n        }\n        setIsUploading(true);\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_2__.BACKEND_API_BASE_URL, \"/upload\"), {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Upload failed: \".concat(response.status));\n            const result = await response.json();\n            if (type === \"handwriting\") {\n                setHandwritingSample(file);\n                setHandwritingSampleUrl(result.url);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Handwriting sample uploaded!\");\n            } else {\n                const newImageIndex = referenceImages.length;\n                setReferenceImages((prev)=>[\n                        ...prev,\n                        file\n                    ]);\n                setReferenceImageUrls((prev)=>[\n                        ...prev,\n                        result.url\n                    ]);\n                sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image uploaded! \".concat(referenceImages.length + 1, \" photo\").concat(referenceImages.length + 1 > 1 ? \"s\" : \"\", \" ready for character creation.\"));\n                // Store the URL and index for later analysis\n                const analysisData = {\n                    url: result.url,\n                    index: newImageIndex\n                };\n                // Auto-analyze the photo in the background after state updates\n                setTimeout(()=>{\n                    console.log(\"\\uD83E\\uDD16 Auto-analyzing uploaded photo...\");\n                    analyzePhoto(analysisData.url, analysisData.index).then((analysisResult)=>{\n                        if (analysisResult && analysisResult.peopleCount > 0) {\n                            console.log(\"✅ Photo analysis complete: \".concat(analysisResult.peopleCount, \" people detected\"));\n                            // Create default photo analysis with all people included\n                            const defaultAnalysis = {\n                                imageUrl: analysisData.url,\n                                imageIndex: analysisData.index,\n                                analysisResult: analysisResult,\n                                selectedPeople: analysisResult.people.map((person)=>({\n                                        ...person,\n                                        includeInCard: true,\n                                        name: \"\",\n                                        relationshipToRecipient: \"\"\n                                    })),\n                                includeEveryone: true,\n                                excludedCount: 0,\n                                analyzed: true,\n                                analysisFailed: false\n                            };\n                            // Save the analysis silently\n                            setPhotoAnalyses((prev)=>{\n                                const newAnalyses = [\n                                    ...prev\n                                ];\n                                newAnalyses[analysisData.index] = defaultAnalysis;\n                                return newAnalyses;\n                            });\n                            // Subtle notification that analysis is complete\n                            if (analysisResult.peopleCount === 1) {\n                                console.log(\"\\uD83D\\uDCF8 1 person detected and ready for card creation\");\n                            } else {\n                                console.log(\"\\uD83D\\uDCF8 \".concat(analysisResult.peopleCount, \" people detected and ready for card creation\"));\n                            }\n                        } else if (analysisResult && analysisResult.peopleCount === 0) {\n                            console.log(\"\\uD83D\\uDCF8 No people detected in photo, but it can still be used for reference\");\n                        } else {\n                            console.log(\"⚠️ Photo analysis failed, but photo can still be used\");\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to auto-analyze photo:\", error);\n                    // Don't show error toast - silent failure is OK since analysis is optional\n                    });\n                }, 100); // Small delay to ensure state updates are complete\n            }\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Upload failed. Please try again.\");\n        } finally{\n            setIsUploading(false);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        referenceImages.length\n    ]);\n    const handleRemoveReferenceImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index)=>{\n        const removedImage = referenceImages[index];\n        const removedUrl = referenceImageUrls[index];\n        setReferenceImages((prev)=>prev.filter((_, i)=>i !== index));\n        setReferenceImageUrls((prev)=>prev.filter((_, i)=>i !== index));\n        // Also remove associated photo analysis\n        setPhotoAnalyses((prev)=>prev.filter((_, i)=>i !== index));\n        console.log(\"\\uD83D\\uDD0D DEBUG: Reference image removed:\", {\n            fileName: removedImage === null || removedImage === void 0 ? void 0 : removedImage.name,\n            url: removedUrl,\n            remainingImages: referenceImages.length - 1\n        });\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Reference image removed! \".concat(referenceImages.length - 1, \" photo\").concat(referenceImages.length - 1 !== 1 ? \"s\" : \"\", \" remaining.\"));\n    }, [\n        referenceImages,\n        referenceImageUrls\n    ]);\n    // Analyze a photo using AI vision\n    const analyzePhoto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (imageUrl, imageIndex)=>{\n        console.log(\"\\uD83D\\uDCF8 Starting photo analysis for:\", imageUrl);\n        setIsAnalyzing(true);\n        try {\n            // Ensure the image URL is absolute\n            let fullImageUrl = imageUrl;\n            if (imageUrl.startsWith(\"/\")) {\n                fullImageUrl = \"\".concat(window.location.origin).concat(imageUrl);\n            }\n            console.log(\"\\uD83D\\uDCF8 Using full image URL:\", fullImageUrl);\n            const analysisPrompt = 'Analyze this photo and provide a detailed JSON response with the following structure:\\n{\\n  \"peopleCount\": <number of people in photo>,\\n  \"people\": [\\n    {\\n      \"id\": \"person-1\",\\n      \"position\": <one of: \"far-left\", \"left\", \"center-left\", \"center\", \"center-right\", \"right\", \"far-right\">,\\n      \"positionDescription\": <natural description like \"person on the far left wearing blue\">,\\n      \"description\": <overall appearance description>,\\n      \"apparentAge\": <age range like \"20-25\" or \"40s\">,\\n      \"gender\": <apparent gender if identifiable>,\\n      \"hairColor\": <hair color>,\\n      \"hairStyle\": <hair style/length>,\\n      \"distinguishingFeatures\": <notable features like glasses, beard, etc.>,\\n      \"clothing\": <what they\\'re wearing>,\\n      \"expression\": <facial expression/mood>\\n    }\\n  ],\\n  \"hasPets\": <boolean>,\\n  \"petDescription\": <description of pets if present>,\\n  \"backgroundDescription\": <description of the background/environment>,\\n  \"setting\": <type of setting like \"outdoor park\", \"beach\", \"indoor\", etc.>,\\n  \"overallMood\": <overall mood/atmosphere of the photo>,\\n  \"lighting\": <lighting conditions>\\n}\\n\\nFor each person:\\n1. Describe their position in the image using the enum values\\n2. Provide a brief description of their appearance  \\n3. Estimate their apparent age range\\n4. Note their hair color and style\\n5. Describe their clothing\\n6. Note any distinguishing features\\n7. Describe their expression/mood\\n\\nReturn ONLY the JSON response, no additional text.';\n            // Use the analyze_images tool through the MCP service\n            const response = await fetch(\"/internal/call_mcp_tool\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    tool_name: \"analyze_images\",\n                    arguments: {\n                        urls: [\n                            fullImageUrl\n                        ],\n                        analysis_prompt: analysisPrompt\n                    }\n                })\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"analyze_images error response:\", errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log(\"\\uD83E\\uDD16 analyze_images response data:\", data);\n            if (data.error && data.error !== \"None\" && data.error !== null) {\n                throw new Error(data.error);\n            }\n            let result;\n            if (typeof data.result === \"string\") {\n                try {\n                    result = JSON.parse(data.result);\n                } catch (e) {\n                    result = {\n                        status: \"error\",\n                        message: \"Invalid JSON response from MCP\"\n                    };\n                }\n            } else {\n                result = data.result;\n            }\n            if (result.status === \"error\") {\n                throw new Error(result.message);\n            }\n            // Extract the analysis from the results array\n            if (result.results && result.results.length > 0) {\n                const imageResult = result.results[0];\n                if (imageResult.status === \"success\" && imageResult.analysis) {\n                    console.log(\"\\uD83D\\uDCF8 Raw analysis text:\", imageResult.analysis);\n                    // Try to parse the analysis as JSON\n                    try {\n                        // Extract JSON from the analysis text\n                        let jsonText = imageResult.analysis;\n                        // If the response contains markdown code blocks, extract the JSON\n                        const jsonMatch = jsonText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n                        if (jsonMatch) {\n                            jsonText = jsonMatch[1];\n                        }\n                        // Parse the JSON\n                        const analysisData = JSON.parse(jsonText);\n                        console.log(\"\\uD83D\\uDCF8 Parsed analysis data:\", analysisData);\n                        // Ensure the data matches our expected structure\n                        if (typeof analysisData.peopleCount === \"number\" && Array.isArray(analysisData.people)) {\n                            setIsAnalyzing(false);\n                            return analysisData;\n                        } else {\n                            console.error(\"Analysis data doesn't match expected structure\");\n                            setIsAnalyzing(false);\n                            return null;\n                        }\n                    } catch (parseError) {\n                        console.error(\"Failed to parse analysis as JSON:\", parseError);\n                        console.error(\"Raw analysis:\", imageResult.analysis);\n                        setIsAnalyzing(false);\n                        return null;\n                    }\n                } else {\n                    console.error(\"Image analysis failed:\", imageResult.message);\n                    setIsAnalyzing(false);\n                    return null;\n                }\n            } else {\n                console.error(\"No results returned from analyze_images\");\n                setIsAnalyzing(false);\n                return null;\n            }\n        } catch (error) {\n            console.error(\"Failed to analyze photo:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to analyze photo. You can still use it without analysis.\");\n            setIsAnalyzing(false);\n            return null;\n        }\n    }, []);\n    // Save photo analysis results\n    const savePhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((analysis)=>{\n        setPhotoAnalyses((prev)=>{\n            const newAnalyses = [\n                ...prev\n            ];\n            newAnalyses[analysis.imageIndex] = analysis;\n            return newAnalyses;\n        });\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, []);\n    // Skip photo analysis\n    const skipPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pendingAnalysisIndex !== null) {\n            const skippedAnalysis = {\n                imageUrl: referenceImageUrls[pendingAnalysisIndex],\n                imageIndex: pendingAnalysisIndex,\n                analysisResult: {\n                    peopleCount: 0,\n                    people: [],\n                    hasPets: false,\n                    backgroundDescription: \"\",\n                    setting: \"\",\n                    overallMood: \"\",\n                    lighting: \"\"\n                },\n                selectedPeople: [],\n                includeEveryone: true,\n                excludedCount: 0,\n                analyzed: false,\n                analysisFailed: false\n            };\n            savePhotoAnalysis(skippedAnalysis);\n        }\n        setShowAnalysisModal(false);\n        setPendingAnalysisIndex(null);\n    }, [\n        pendingAnalysisIndex,\n        referenceImageUrls,\n        savePhotoAnalysis\n    ]);\n    // Get combined analysis for all photos\n    const getCombinedPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const analyzedPhotos = photoAnalyses.filter((a)=>a.analyzed && !a.analysisFailed);\n        if (analyzedPhotos.length === 0) return null;\n        const allSelectedPeople = analyzedPhotos.flatMap((a)=>a.selectedPeople);\n        const totalPeopleCount = analyzedPhotos.reduce((sum, a)=>sum + a.analysisResult.peopleCount, 0);\n        const totalSelectedCount = allSelectedPeople.length;\n        const totalExcludedCount = totalPeopleCount - totalSelectedCount;\n        return {\n            analyzedPhotos,\n            allSelectedPeople,\n            totalPeopleCount,\n            totalSelectedCount,\n            totalExcludedCount,\n            hasMultiplePhotos: analyzedPhotos.length > 1\n        };\n    }, [\n        photoAnalyses\n    ]);\n    // Manually trigger photo analysis for a specific image\n    const triggerPhotoAnalysis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageIndex)=>{\n        if (imageIndex >= 0 && imageIndex < referenceImageUrls.length) {\n            setPendingAnalysisIndex(imageIndex);\n            setShowAnalysisModal(true);\n        }\n    }, [\n        referenceImageUrls.length\n    ]);\n    return {\n        handwritingSample,\n        setHandwritingSample,\n        handwritingSampleUrl,\n        setHandwritingSampleUrl,\n        referenceImages,\n        setReferenceImages,\n        referenceImageUrls,\n        setReferenceImageUrls,\n        imageTransformation,\n        setImageTransformation,\n        isUploading,\n        setIsUploading,\n        handleFileUpload,\n        handleRemoveReferenceImage,\n        // Photo analysis\n        photoAnalyses,\n        setPhotoAnalyses,\n        isAnalyzing,\n        showAnalysisModal,\n        setShowAnalysisModal,\n        pendingAnalysisIndex,\n        setPendingAnalysisIndex,\n        analyzePhoto,\n        savePhotoAnalysis,\n        skipPhotoAnalysis,\n        getCombinedPhotoAnalysis,\n        triggerPhotoAnalysis\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRmlsZUhhbmRsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FFQUU4QztBQUNmO0FBQ3dFO0FBR2hHLFNBQVNJO0lBQ2QsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHTiwrQ0FBUUEsQ0FBYztJQUN4RSxNQUFNLENBQUNPLHNCQUFzQkMsd0JBQXdCLEdBQUdSLCtDQUFRQSxDQUFnQjtJQUNoRixNQUFNLENBQUNTLGlCQUFpQkMsbUJBQW1CLEdBQUdWLCtDQUFRQSxDQUFTLEVBQUU7SUFDakUsTUFBTSxDQUFDVyxvQkFBb0JDLHNCQUFzQixHQUFHWiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3pFLE1BQU0sQ0FBQ2EscUJBQXFCQyx1QkFBdUIsR0FBR2QsK0NBQVFBLENBQVM7SUFDdkUsTUFBTSxDQUFDZSxhQUFhQyxlQUFlLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUUvQyx1QkFBdUI7SUFDdkIsTUFBTSxDQUFDaUIsZUFBZUMsaUJBQWlCLEdBQUdsQiwrQ0FBUUEsQ0FBa0IsRUFBRTtJQUN0RSxNQUFNLENBQUNtQixhQUFhQyxlQUFlLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNxQixtQkFBbUJDLHFCQUFxQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDdUIsc0JBQXNCQyx3QkFBd0IsR0FBR3hCLCtDQUFRQSxDQUFnQjtJQUVoRixzQkFBc0I7SUFDdEIsTUFBTXlCLG1CQUFtQnhCLGtEQUFXQSxDQUFDLE9BQU95QixNQUFZQztRQUN0RCxJQUFJLENBQUNELEtBQUtDLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFdBQVc7WUFDbkMxQix5Q0FBS0EsQ0FBQzJCLEtBQUssQ0FBQztZQUNaO1FBQ0Y7UUFFQWIsZUFBZTtRQUVmLElBQUk7WUFDRixNQUFNYyxXQUFXLElBQUlDO1lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsUUFBUU47WUFFeEIsTUFBTU8sV0FBVyxN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dEUsTUFBTSxLQUFLLEdBQUcsT0FBTztRQUV4QyxNQUFNd0Usb0JBQW9CRixlQUFlRyxPQUFPLENBQUNGLENBQUFBLElBQUtBLEVBQUV6RCxjQUFjO1FBQ3RFLE1BQU00RCxtQkFBbUJKLGVBQWVLLE1BQU0sQ0FBQyxDQUFDQyxLQUFLTCxJQUFNSyxNQUFNTCxFQUFFOUQsY0FBYyxDQUFDQyxXQUFXLEVBQUU7UUFDL0YsTUFBTW1FLHFCQUFxQkwsa0JBQWtCeEUsTUFBTTtRQUNuRCxNQUFNOEUscUJBQXFCSixtQkFBbUJHO1FBRTlDLE9BQU87WUFDTFA7WUFDQUU7WUFDQUU7WUFDQUc7WUFDQUM7WUFDQUMsbUJBQW1CVCxlQUFldEUsTUFBTSxHQUFHO1FBQzdDO0lBQ0YsR0FBRztRQUFDNUI7S0FBYztJQUVsQix1REFBdUQ7SUFDdkQsTUFBTTRHLHVCQUF1QjVILGtEQUFXQSxDQUFDLENBQUN5RDtRQUN4QyxJQUFJQSxjQUFjLEtBQUtBLGFBQWEvQyxtQkFBbUJrQyxNQUFNLEVBQUU7WUFDN0RyQix3QkFBd0JrQztZQUN4QnBDLHFCQUFxQjtRQUN2QjtJQUNGLEdBQUc7UUFBQ1gsbUJBQW1Ca0MsTUFBTTtLQUFDO0lBRTlCLE9BQU87UUFDTHhDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FTO1FBQ0ErQztRQUNBLGlCQUFpQjtRQUNqQnZEO1FBQ0FDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0E0QjtRQUNBc0Q7UUFDQUM7UUFDQU87UUFDQVc7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlRmlsZUhhbmRsaW5nLnRzP2M0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tIFwic29ubmVyXCI7XG5pbXBvcnQgeyBCQUNLRU5EX0FQSV9CQVNFX1VSTCwgUGhvdG9BbmFseXNpcywgUGhvdG9BbmFseXNpc1Jlc3VsdCwgU2VsZWN0ZWRQZXJzb24gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjaGF0V2l0aEFJIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGaWxlSGFuZGxpbmcoKSB7XG4gIGNvbnN0IFtoYW5kd3JpdGluZ1NhbXBsZSwgc2V0SGFuZHdyaXRpbmdTYW1wbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaGFuZHdyaXRpbmdTYW1wbGVVcmwsIHNldEhhbmR3cml0aW5nU2FtcGxlVXJsXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcmVmZXJlbmNlSW1hZ2VzLCBzZXRSZWZlcmVuY2VJbWFnZXNdID0gdXNlU3RhdGU8RmlsZVtdPihbXSk7XG4gIGNvbnN0IFtyZWZlcmVuY2VJbWFnZVVybHMsIHNldFJlZmVyZW5jZUltYWdlVXJsc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbaW1hZ2VUcmFuc2Zvcm1hdGlvbiwgc2V0SW1hZ2VUcmFuc2Zvcm1hdGlvbl0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBjb25zdCBbaXNVcGxvYWRpbmcsIHNldElzVXBsb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFBob3RvIGFuYWx5c2lzIHN0YXRlXG4gIGNvbnN0IFtwaG90b0FuYWx5c2VzLCBzZXRQaG90b0FuYWx5c2VzXSA9IHVzZVN0YXRlPFBob3RvQW5hbHlzaXNbXT4oW10pO1xuICBjb25zdCBbaXNBbmFseXppbmcsIHNldElzQW5hbHl6aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dBbmFseXNpc01vZGFsLCBzZXRTaG93QW5hbHlzaXNNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtwZW5kaW5nQW5hbHlzaXNJbmRleCwgc2V0UGVuZGluZ0FuYWx5c2lzSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gRmlsZSB1cGxvYWQgaGFuZGxlclxuICBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZpbGU6IEZpbGUsIHR5cGU6ICdoYW5kd3JpdGluZycgfCAncmVmZXJlbmNlJykgPT4ge1xuICAgIGlmICghZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICB0b2FzdC5lcnJvcihcIlBsZWFzZSB1cGxvYWQgYW4gaW1hZ2UgZmlsZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS91cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmICh0eXBlID09PSAnaGFuZHdyaXRpbmcnKSB7XG4gICAgICAgIHNldEhhbmR3cml0aW5nU2FtcGxlKGZpbGUpO1xuICAgICAgICBzZXRIYW5kd3JpdGluZ1NhbXBsZVVybChyZXN1bHQudXJsKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhcIkhhbmR3cml0aW5nIHNhbXBsZSB1cGxvYWRlZCFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdJbWFnZUluZGV4ID0gcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aDtcbiAgICAgICAgc2V0UmVmZXJlbmNlSW1hZ2VzKHByZXYgPT4gWy4uLnByZXYsIGZpbGVdKTtcbiAgICAgICAgc2V0UmVmZXJlbmNlSW1hZ2VVcmxzKHByZXYgPT4gWy4uLnByZXYsIHJlc3VsdC51cmxdKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcyhgUmVmZXJlbmNlIGltYWdlIHVwbG9hZGVkISAke3JlZmVyZW5jZUltYWdlcy5sZW5ndGggKyAxfSBwaG90byR7cmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCArIDEgPiAxID8gJ3MnIDogJyd9IHJlYWR5IGZvciBjaGFyYWN0ZXIgY3JlYXRpb24uYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSB0aGUgVVJMIGFuZCBpbmRleCBmb3IgbGF0ZXIgYW5hbHlzaXNcbiAgICAgICAgY29uc3QgYW5hbHlzaXNEYXRhID0geyB1cmw6IHJlc3VsdC51cmwsIGluZGV4OiBuZXdJbWFnZUluZGV4IH07XG4gICAgICAgIFxuICAgICAgICAvLyBBdXRvLWFuYWx5emUgdGhlIHBob3RvIGluIHRoZSBiYWNrZ3JvdW5kIGFmdGVyIHN0YXRlIHVwZGF0ZXNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn6SWIEF1dG8tYW5hbHl6aW5nIHVwbG9hZGVkIHBob3RvLi4uXCIpO1xuICAgICAgICAgIGFuYWx5emVQaG90byhhbmFseXNpc0RhdGEudXJsLCBhbmFseXNpc0RhdGEuaW5kZXgpLnRoZW4oYW5hbHlzaXNSZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGFuYWx5c2lzUmVzdWx0ICYmIGFuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBob3RvIGFuYWx5c2lzIGNvbXBsZXRlOiAke2FuYWx5c2lzUmVzdWx0LnBlb3BsZUNvdW50fSBwZW9wbGUgZGV0ZWN0ZWRgKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IHBob3RvIGFuYWx5c2lzIHdpdGggYWxsIHBlb3BsZSBpbmNsdWRlZFxuICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0QW5hbHlzaXM6IFBob3RvQW5hbHlzaXMgPSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGFuYWx5c2lzRGF0YS51cmwsXG4gICAgICAgICAgICAgICAgaW1hZ2VJbmRleDogYW5hbHlzaXNEYXRhLmluZGV4LFxuICAgICAgICAgICAgICAgIGFuYWx5c2lzUmVzdWx0OiBhbmFseXNpc1Jlc3VsdCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFBlb3BsZTogYW5hbHlzaXNSZXN1bHQucGVvcGxlLm1hcChwZXJzb24gPT4gKHtcbiAgICAgICAgICAgICAgICAgIC4uLnBlcnNvbixcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVJbkNhcmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBuYW1lOiAnJywgLy8gTm8gbmFtZSBieSBkZWZhdWx0LCB1c2VyIGNhbiBhZGQgdmlhIFwiQ3VzdG9taXplIHBlb3BsZVwiXG4gICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBUb1JlY2lwaWVudDogJydcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgaW5jbHVkZUV2ZXJ5b25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVkQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgYW5hbHl6ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgYW5hbHlzaXNGYWlsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBhbmFseXNpcyBzaWxlbnRseVxuICAgICAgICAgICAgICBzZXRQaG90b0FuYWx5c2VzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FuYWx5c2VzID0gWy4uLnByZXZdO1xuICAgICAgICAgICAgICAgIG5ld0FuYWx5c2VzW2FuYWx5c2lzRGF0YS5pbmRleF0gPSBkZWZhdWx0QW5hbHlzaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FuYWx5c2VzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFN1YnRsZSBub3RpZmljYXRpb24gdGhhdCBhbmFseXNpcyBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgICBpZiAoYW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk7ggMSBwZXJzb24gZGV0ZWN0ZWQgYW5kIHJlYWR5IGZvciBjYXJkIGNyZWF0aW9uXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5O4ICR7YW5hbHlzaXNSZXN1bHQucGVvcGxlQ291bnR9IHBlb3BsZSBkZXRlY3RlZCBhbmQgcmVhZHkgZm9yIGNhcmQgY3JlYXRpb25gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmFseXNpc1Jlc3VsdCAmJiBhbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk7ggTm8gcGVvcGxlIGRldGVjdGVkIGluIHBob3RvLCBidXQgaXQgY2FuIHN0aWxsIGJlIHVzZWQgZm9yIHJlZmVyZW5jZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIFBob3RvIGFuYWx5c2lzIGZhaWxlZCwgYnV0IHBob3RvIGNhbiBzdGlsbCBiZSB1c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gYXV0by1hbmFseXplIHBob3RvOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBEb24ndCBzaG93IGVycm9yIHRvYXN0IC0gc2lsZW50IGZhaWx1cmUgaXMgT0sgc2luY2UgYW5hbHlzaXMgaXMgb3B0aW9uYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIHN0YXRlIHVwZGF0ZXMgYXJlIGNvbXBsZXRlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiVXBsb2FkIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzVXBsb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aF0pO1xuXG4gIGNvbnN0IGhhbmRsZVJlbW92ZVJlZmVyZW5jZUltYWdlID0gdXNlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZW1vdmVkSW1hZ2UgPSByZWZlcmVuY2VJbWFnZXNbaW5kZXhdO1xuICAgIGNvbnN0IHJlbW92ZWRVcmwgPSByZWZlcmVuY2VJbWFnZVVybHNbaW5kZXhdO1xuICAgIFxuICAgIHNldFJlZmVyZW5jZUltYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCkpO1xuICAgIHNldFJlZmVyZW5jZUltYWdlVXJscyhwcmV2ID0+IHByZXYuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCkpO1xuICAgIFxuICAgIC8vIEFsc28gcmVtb3ZlIGFzc29jaWF0ZWQgcGhvdG8gYW5hbHlzaXNcbiAgICBzZXRQaG90b0FuYWx5c2VzKHByZXYgPT4gcHJldi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCLwn5SNIERFQlVHOiBSZWZlcmVuY2UgaW1hZ2UgcmVtb3ZlZDpcIiwge1xuICAgICAgZmlsZU5hbWU6IHJlbW92ZWRJbWFnZT8ubmFtZSxcbiAgICAgIHVybDogcmVtb3ZlZFVybCxcbiAgICAgIHJlbWFpbmluZ0ltYWdlczogcmVmZXJlbmNlSW1hZ2VzLmxlbmd0aCAtIDFcbiAgICB9KTtcbiAgICBcbiAgICB0b2FzdC5zdWNjZXNzKGBSZWZlcmVuY2UgaW1hZ2UgcmVtb3ZlZCEgJHtyZWZlcmVuY2VJbWFnZXMubGVuZ3RoIC0gMX0gcGhvdG8ke3JlZmVyZW5jZUltYWdlcy5sZW5ndGggLSAxICE9PSAxID8gJ3MnIDogJyd9IHJlbWFpbmluZy5gKTtcbiAgfSwgW3JlZmVyZW5jZUltYWdlcywgcmVmZXJlbmNlSW1hZ2VVcmxzXSk7XG5cbiAgLy8gQW5hbHl6ZSBhIHBob3RvIHVzaW5nIEFJIHZpc2lvblxuICBjb25zdCBhbmFseXplUGhvdG8gPSB1c2VDYWxsYmFjayhhc3luYyAoaW1hZ2VVcmw6IHN0cmluZywgaW1hZ2VJbmRleDogbnVtYmVyKTogUHJvbWlzZTxQaG90b0FuYWx5c2lzUmVzdWx0IHwgbnVsbD4gPT4ge1xuICAgIGNvbnNvbGUubG9nKFwi8J+TuCBTdGFydGluZyBwaG90byBhbmFseXNpcyBmb3I6XCIsIGltYWdlVXJsKTtcbiAgICBzZXRJc0FuYWx5emluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBpbWFnZSBVUkwgaXMgYWJzb2x1dGVcbiAgICAgIGxldCBmdWxsSW1hZ2VVcmwgPSBpbWFnZVVybDtcbiAgICAgIGlmIChpbWFnZVVybC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgZnVsbEltYWdlVXJsID0gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0ke2ltYWdlVXJsfWA7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIvCfk7ggVXNpbmcgZnVsbCBpbWFnZSBVUkw6XCIsIGZ1bGxJbWFnZVVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFuYWx5c2lzUHJvbXB0ID0gYEFuYWx5emUgdGhpcyBwaG90byBhbmQgcHJvdmlkZSBhIGRldGFpbGVkIEpTT04gcmVzcG9uc2Ugd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbntcbiAgXCJwZW9wbGVDb3VudFwiOiA8bnVtYmVyIG9mIHBlb3BsZSBpbiBwaG90bz4sXG4gIFwicGVvcGxlXCI6IFtcbiAgICB7XG4gICAgICBcImlkXCI6IFwicGVyc29uLTFcIixcbiAgICAgIFwicG9zaXRpb25cIjogPG9uZSBvZjogXCJmYXItbGVmdFwiLCBcImxlZnRcIiwgXCJjZW50ZXItbGVmdFwiLCBcImNlbnRlclwiLCBcImNlbnRlci1yaWdodFwiLCBcInJpZ2h0XCIsIFwiZmFyLXJpZ2h0XCI+LFxuICAgICAgXCJwb3NpdGlvbkRlc2NyaXB0aW9uXCI6IDxuYXR1cmFsIGRlc2NyaXB0aW9uIGxpa2UgXCJwZXJzb24gb24gdGhlIGZhciBsZWZ0IHdlYXJpbmcgYmx1ZVwiPixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogPG92ZXJhbGwgYXBwZWFyYW5jZSBkZXNjcmlwdGlvbj4sXG4gICAgICBcImFwcGFyZW50QWdlXCI6IDxhZ2UgcmFuZ2UgbGlrZSBcIjIwLTI1XCIgb3IgXCI0MHNcIj4sXG4gICAgICBcImdlbmRlclwiOiA8YXBwYXJlbnQgZ2VuZGVyIGlmIGlkZW50aWZpYWJsZT4sXG4gICAgICBcImhhaXJDb2xvclwiOiA8aGFpciBjb2xvcj4sXG4gICAgICBcImhhaXJTdHlsZVwiOiA8aGFpciBzdHlsZS9sZW5ndGg+LFxuICAgICAgXCJkaXN0aW5ndWlzaGluZ0ZlYXR1cmVzXCI6IDxub3RhYmxlIGZlYXR1cmVzIGxpa2UgZ2xhc3NlcywgYmVhcmQsIGV0Yy4+LFxuICAgICAgXCJjbG90aGluZ1wiOiA8d2hhdCB0aGV5J3JlIHdlYXJpbmc+LFxuICAgICAgXCJleHByZXNzaW9uXCI6IDxmYWNpYWwgZXhwcmVzc2lvbi9tb29kPlxuICAgIH1cbiAgXSxcbiAgXCJoYXNQZXRzXCI6IDxib29sZWFuPixcbiAgXCJwZXREZXNjcmlwdGlvblwiOiA8ZGVzY3JpcHRpb24gb2YgcGV0cyBpZiBwcmVzZW50PixcbiAgXCJiYWNrZ3JvdW5kRGVzY3JpcHRpb25cIjogPGRlc2NyaXB0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kL2Vudmlyb25tZW50PixcbiAgXCJzZXR0aW5nXCI6IDx0eXBlIG9mIHNldHRpbmcgbGlrZSBcIm91dGRvb3IgcGFya1wiLCBcImJlYWNoXCIsIFwiaW5kb29yXCIsIGV0Yy4+LFxuICBcIm92ZXJhbGxNb29kXCI6IDxvdmVyYWxsIG1vb2QvYXRtb3NwaGVyZSBvZiB0aGUgcGhvdG8+LFxuICBcImxpZ2h0aW5nXCI6IDxsaWdodGluZyBjb25kaXRpb25zPlxufVxuXG5Gb3IgZWFjaCBwZXJzb246XG4xLiBEZXNjcmliZSB0aGVpciBwb3NpdGlvbiBpbiB0aGUgaW1hZ2UgdXNpbmcgdGhlIGVudW0gdmFsdWVzXG4yLiBQcm92aWRlIGEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlaXIgYXBwZWFyYW5jZSAgXG4zLiBFc3RpbWF0ZSB0aGVpciBhcHBhcmVudCBhZ2UgcmFuZ2VcbjQuIE5vdGUgdGhlaXIgaGFpciBjb2xvciBhbmQgc3R5bGVcbjUuIERlc2NyaWJlIHRoZWlyIGNsb3RoaW5nXG42LiBOb3RlIGFueSBkaXN0aW5ndWlzaGluZyBmZWF0dXJlc1xuNy4gRGVzY3JpYmUgdGhlaXIgZXhwcmVzc2lvbi9tb29kXG5cblJldHVybiBPTkxZIHRoZSBKU09OIHJlc3BvbnNlLCBubyBhZGRpdGlvbmFsIHRleHQuYDtcblxuICAgICAgLy8gVXNlIHRoZSBhbmFseXplX2ltYWdlcyB0b29sIHRocm91Z2ggdGhlIE1DUCBzZXJ2aWNlXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvaW50ZXJuYWwvY2FsbF9tY3BfdG9vbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdG9vbF9uYW1lOiAnYW5hbHl6ZV9pbWFnZXMnLFxuICAgICAgICAgIGFyZ3VtZW50czoge1xuICAgICAgICAgICAgdXJsczogW2Z1bGxJbWFnZVVybF0sXG4gICAgICAgICAgICBhbmFseXNpc19wcm9tcHQ6IGFuYWx5c2lzUHJvbXB0XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiYW5hbHl6ZV9pbWFnZXMgZXJyb3IgcmVzcG9uc2U6XCIsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coXCLwn6SWIGFuYWx5emVfaW1hZ2VzIHJlc3BvbnNlIGRhdGE6XCIsIGRhdGEpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5lcnJvciAmJiBkYXRhLmVycm9yICE9PSBcIk5vbmVcIiAmJiBkYXRhLmVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZGF0YS5yZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhLnJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJlc3VsdCA9IHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiAnSW52YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gTUNQJyB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCB0aGUgYW5hbHlzaXMgZnJvbSB0aGUgcmVzdWx0cyBhcnJheVxuICAgICAgaWYgKHJlc3VsdC5yZXN1bHRzICYmIHJlc3VsdC5yZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSByZXN1bHQucmVzdWx0c1swXTtcbiAgICAgICAgaWYgKGltYWdlUmVzdWx0LnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIGltYWdlUmVzdWx0LmFuYWx5c2lzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn5O4IFJhdyBhbmFseXNpcyB0ZXh0OlwiLCBpbWFnZVJlc3VsdC5hbmFseXNpcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBhbmFseXNpcyBhcyBKU09OXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgSlNPTiBmcm9tIHRoZSBhbmFseXNpcyB0ZXh0XG4gICAgICAgICAgICBsZXQganNvblRleHQgPSBpbWFnZVJlc3VsdC5hbmFseXNpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIG1hcmtkb3duIGNvZGUgYmxvY2tzLCBleHRyYWN0IHRoZSBKU09OXG4gICAgICAgICAgICBjb25zdCBqc29uTWF0Y2ggPSBqc29uVGV4dC5tYXRjaCgvYGBganNvblxccyooW1xcc1xcU10qPylcXHMqYGBgLyk7XG4gICAgICAgICAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICAgICAgICAgIGpzb25UZXh0ID0ganNvbk1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgSlNPTlxuICAgICAgICAgICAgY29uc3QgYW5hbHlzaXNEYXRhID0gSlNPTi5wYXJzZShqc29uVGV4dCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk7ggUGFyc2VkIGFuYWx5c2lzIGRhdGE6XCIsIGFuYWx5c2lzRGF0YSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZGF0YSBtYXRjaGVzIG91ciBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5hbHlzaXNEYXRhLnBlb3BsZUNvdW50ID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFuYWx5c2lzRGF0YS5wZW9wbGUpKSB7XG4gICAgICAgICAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFuYWx5c2lzRGF0YSBhcyBQaG90b0FuYWx5c2lzUmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkFuYWx5c2lzIGRhdGEgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBzdHJ1Y3R1cmVcIik7XG4gICAgICAgICAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBhbmFseXNpcyBhcyBKU09OOlwiLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYXcgYW5hbHlzaXM6XCIsIGltYWdlUmVzdWx0LmFuYWx5c2lzKTtcbiAgICAgICAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW1hZ2UgYW5hbHlzaXMgZmFpbGVkOlwiLCBpbWFnZVJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICBzZXRJc0FuYWx5emluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyByZXN1bHRzIHJldHVybmVkIGZyb20gYW5hbHl6ZV9pbWFnZXNcIik7XG4gICAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBhbmFseXplIHBob3RvOlwiLCBlcnJvcik7XG4gICAgICB0b2FzdC5lcnJvcihcIkZhaWxlZCB0byBhbmFseXplIHBob3RvLiBZb3UgY2FuIHN0aWxsIHVzZSBpdCB3aXRob3V0IGFuYWx5c2lzLlwiKTtcbiAgICAgIHNldElzQW5hbHl6aW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcGhvdG8gYW5hbHlzaXMgcmVzdWx0c1xuICBjb25zdCBzYXZlUGhvdG9BbmFseXNpcyA9IHVzZUNhbGxiYWNrKChhbmFseXNpczogUGhvdG9BbmFseXNpcykgPT4ge1xuICAgIHNldFBob3RvQW5hbHlzZXMocHJldiA9PiB7XG4gICAgICBjb25zdCBuZXdBbmFseXNlcyA9IFsuLi5wcmV2XTtcbiAgICAgIG5ld0FuYWx5c2VzW2FuYWx5c2lzLmltYWdlSW5kZXhdID0gYW5hbHlzaXM7XG4gICAgICByZXR1cm4gbmV3QW5hbHlzZXM7XG4gICAgfSk7XG4gICAgc2V0U2hvd0FuYWx5c2lzTW9kYWwoZmFsc2UpO1xuICAgIHNldFBlbmRpbmdBbmFseXNpc0luZGV4KG51bGwpO1xuICB9LCBbXSk7XG5cbiAgLy8gU2tpcCBwaG90byBhbmFseXNpc1xuICBjb25zdCBza2lwUGhvdG9BbmFseXNpcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGVuZGluZ0FuYWx5c2lzSW5kZXggIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNraXBwZWRBbmFseXNpczogUGhvdG9BbmFseXNpcyA9IHtcbiAgICAgICAgaW1hZ2VVcmw6IHJlZmVyZW5jZUltYWdlVXJsc1twZW5kaW5nQW5hbHlzaXNJbmRleF0sXG4gICAgICAgIGltYWdlSW5kZXg6IHBlbmRpbmdBbmFseXNpc0luZGV4LFxuICAgICAgICBhbmFseXNpc1Jlc3VsdDoge1xuICAgICAgICAgIHBlb3BsZUNvdW50OiAwLFxuICAgICAgICAgIHBlb3BsZTogW10sXG4gICAgICAgICAgaGFzUGV0czogZmFsc2UsXG4gICAgICAgICAgYmFja2dyb3VuZERlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICAgIHNldHRpbmc6IFwiXCIsXG4gICAgICAgICAgb3ZlcmFsbE1vb2Q6IFwiXCIsXG4gICAgICAgICAgbGlnaHRpbmc6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWRQZW9wbGU6IFtdLFxuICAgICAgICBpbmNsdWRlRXZlcnlvbmU6IHRydWUsXG4gICAgICAgIGV4Y2x1ZGVkQ291bnQ6IDAsXG4gICAgICAgIGFuYWx5emVkOiBmYWxzZSxcbiAgICAgICAgYW5hbHlzaXNGYWlsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgc2F2ZVBob3RvQW5hbHlzaXMoc2tpcHBlZEFuYWx5c2lzKTtcbiAgICB9XG4gICAgc2V0U2hvd0FuYWx5c2lzTW9kYWwoZmFsc2UpO1xuICAgIHNldFBlbmRpbmdBbmFseXNpc0luZGV4KG51bGwpO1xuICB9LCBbcGVuZGluZ0FuYWx5c2lzSW5kZXgsIHJlZmVyZW5jZUltYWdlVXJscywgc2F2ZVBob3RvQW5hbHlzaXNdKTtcblxuICAvLyBHZXQgY29tYmluZWQgYW5hbHlzaXMgZm9yIGFsbCBwaG90b3NcbiAgY29uc3QgZ2V0Q29tYmluZWRQaG90b0FuYWx5c2lzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGFuYWx5emVkUGhvdG9zID0gcGhvdG9BbmFseXNlcy5maWx0ZXIoYSA9PiBhLmFuYWx5emVkICYmICFhLmFuYWx5c2lzRmFpbGVkKTtcbiAgICBpZiAoYW5hbHl6ZWRQaG90b3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGFsbFNlbGVjdGVkUGVvcGxlID0gYW5hbHl6ZWRQaG90b3MuZmxhdE1hcChhID0+IGEuc2VsZWN0ZWRQZW9wbGUpO1xuICAgIGNvbnN0IHRvdGFsUGVvcGxlQ291bnQgPSBhbmFseXplZFBob3Rvcy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5hbmFseXNpc1Jlc3VsdC5wZW9wbGVDb3VudCwgMCk7XG4gICAgY29uc3QgdG90YWxTZWxlY3RlZENvdW50ID0gYWxsU2VsZWN0ZWRQZW9wbGUubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsRXhjbHVkZWRDb3VudCA9IHRvdGFsUGVvcGxlQ291bnQgLSB0b3RhbFNlbGVjdGVkQ291bnQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYW5hbHl6ZWRQaG90b3MsXG4gICAgICBhbGxTZWxlY3RlZFBlb3BsZSxcbiAgICAgIHRvdGFsUGVvcGxlQ291bnQsXG4gICAgICB0b3RhbFNlbGVjdGVkQ291bnQsXG4gICAgICB0b3RhbEV4Y2x1ZGVkQ291bnQsXG4gICAgICBoYXNNdWx0aXBsZVBob3RvczogYW5hbHl6ZWRQaG90b3MubGVuZ3RoID4gMVxuICAgIH07XG4gIH0sIFtwaG90b0FuYWx5c2VzXSk7XG5cbiAgLy8gTWFudWFsbHkgdHJpZ2dlciBwaG90byBhbmFseXNpcyBmb3IgYSBzcGVjaWZpYyBpbWFnZVxuICBjb25zdCB0cmlnZ2VyUGhvdG9BbmFseXNpcyA9IHVzZUNhbGxiYWNrKChpbWFnZUluZGV4OiBudW1iZXIpID0+IHtcbiAgICBpZiAoaW1hZ2VJbmRleCA+PSAwICYmIGltYWdlSW5kZXggPCByZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoKSB7XG4gICAgICBzZXRQZW5kaW5nQW5hbHlzaXNJbmRleChpbWFnZUluZGV4KTtcbiAgICAgIHNldFNob3dBbmFseXNpc01vZGFsKHRydWUpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUltYWdlVXJscy5sZW5ndGhdKTtcblxuICByZXR1cm4ge1xuICAgIGhhbmR3cml0aW5nU2FtcGxlLFxuICAgIHNldEhhbmR3cml0aW5nU2FtcGxlLFxuICAgIGhhbmR3cml0aW5nU2FtcGxlVXJsLFxuICAgIHNldEhhbmR3cml0aW5nU2FtcGxlVXJsLFxuICAgIHJlZmVyZW5jZUltYWdlcyxcbiAgICBzZXRSZWZlcmVuY2VJbWFnZXMsXG4gICAgcmVmZXJlbmNlSW1hZ2VVcmxzLFxuICAgIHNldFJlZmVyZW5jZUltYWdlVXJscyxcbiAgICBpbWFnZVRyYW5zZm9ybWF0aW9uLFxuICAgIHNldEltYWdlVHJhbnNmb3JtYXRpb24sXG4gICAgaXNVcGxvYWRpbmcsXG4gICAgc2V0SXNVcGxvYWRpbmcsXG4gICAgaGFuZGxlRmlsZVVwbG9hZCxcbiAgICBoYW5kbGVSZW1vdmVSZWZlcmVuY2VJbWFnZSxcbiAgICAvLyBQaG90byBhbmFseXNpc1xuICAgIHBob3RvQW5hbHlzZXMsXG4gICAgc2V0UGhvdG9BbmFseXNlcyxcbiAgICBpc0FuYWx5emluZyxcbiAgICBzaG93QW5hbHlzaXNNb2RhbCxcbiAgICBzZXRTaG93QW5hbHlzaXNNb2RhbCxcbiAgICBwZW5kaW5nQW5hbHlzaXNJbmRleCxcbiAgICBzZXRQZW5kaW5nQW5hbHlzaXNJbmRleCxcbiAgICBhbmFseXplUGhvdG8sXG4gICAgc2F2ZVBob3RvQW5hbHlzaXMsXG4gICAgc2tpcFBob3RvQW5hbHlzaXMsXG4gICAgZ2V0Q29tYmluZWRQaG90b0FuYWx5c2lzLFxuICAgIHRyaWdnZXJQaG90b0FuYWx5c2lzXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ0b2FzdCIsIkJBQ0tFTkRfQVBJX0JBU0VfVVJMIiwidXNlRmlsZUhhbmRsaW5nIiwiaGFuZHdyaXRpbmdTYW1wbGUiLCJzZXRIYW5kd3JpdGluZ1NhbXBsZSIsImhhbmR3cml0aW5nU2FtcGxlVXJsIiwic2V0SGFuZHdyaXRpbmdTYW1wbGVVcmwiLCJyZWZlcmVuY2VJbWFnZXMiLCJzZXRSZWZlcmVuY2VJbWFnZXMiLCJyZWZlcmVuY2VJbWFnZVVybHMiLCJzZXRSZWZlcmVuY2VJbWFnZVVybHMiLCJpbWFnZVRyYW5zZm9ybWF0aW9uIiwic2V0SW1hZ2VUcmFuc2Zvcm1hdGlvbiIsImlzVXBsb2FkaW5nIiwic2V0SXNVcGxvYWRpbmciLCJwaG90b0FuYWx5c2VzIiwic2V0UGhvdG9BbmFseXNlcyIsImlzQW5hbHl6aW5nIiwic2V0SXNBbmFseXppbmciLCJzaG93QW5hbHlzaXNNb2RhbCIsInNldFNob3dBbmFseXNpc01vZGFsIiwicGVuZGluZ0FuYWx5c2lzSW5kZXgiLCJzZXRQZW5kaW5nQW5hbHlzaXNJbmRleCIsImhhbmRsZUZpbGVVcGxvYWQiLCJmaWxlIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJlcnJvciIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJyZXN1bHQiLCJqc29uIiwidXJsIiwic3VjY2VzcyIsIm5ld0ltYWdlSW5kZXgiLCJsZW5ndGgiLCJwcmV2IiwiYW5hbHlzaXNEYXRhIiwiaW5kZXgiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImFuYWx5emVQaG90byIsInRoZW4iLCJhbmFseXNpc1Jlc3VsdCIsInBlb3BsZUNvdW50IiwiZGVmYXVsdEFuYWx5c2lzIiwiaW1hZ2VVcmwiLCJpbWFnZUluZGV4Iiwic2VsZWN0ZWRQZW9wbGUiLCJwZW9wbGUiLCJtYXAiLCJwZXJzb24iLCJpbmNsdWRlSW5DYXJkIiwibmFtZSIsInJlbGF0aW9uc2hpcFRvUmVjaXBpZW50IiwiaW5jbHVkZUV2ZXJ5b25lIiwiZXhjbHVkZWRDb3VudCIsImFuYWx5emVkIiwiYW5hbHlzaXNGYWlsZWQiLCJuZXdBbmFseXNlcyIsImNhdGNoIiwiaGFuZGxlUmVtb3ZlUmVmZXJlbmNlSW1hZ2UiLCJyZW1vdmVkSW1hZ2UiLCJyZW1vdmVkVXJsIiwiZmlsdGVyIiwiXyIsImkiLCJmaWxlTmFtZSIsInJlbWFpbmluZ0ltYWdlcyIsImZ1bGxJbWFnZVVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiYW5hbHlzaXNQcm9tcHQiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvb2xfbmFtZSIsImFyZ3VtZW50cyIsInVybHMiLCJhbmFseXNpc19wcm9tcHQiLCJlcnJvclRleHQiLCJ0ZXh0IiwiZGF0YSIsInBhcnNlIiwibWVzc2FnZSIsInJlc3VsdHMiLCJpbWFnZVJlc3VsdCIsImFuYWx5c2lzIiwianNvblRleHQiLCJqc29uTWF0Y2giLCJtYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlRXJyb3IiLCJzYXZlUGhvdG9BbmFseXNpcyIsInNraXBQaG90b0FuYWx5c2lzIiwic2tpcHBlZEFuYWx5c2lzIiwiaGFzUGV0cyIsImJhY2tncm91bmREZXNjcmlwdGlvbiIsInNldHRpbmciLCJvdmVyYWxsTW9vZCIsImxpZ2h0aW5nIiwiZ2V0Q29tYmluZWRQaG90b0FuYWx5c2lzIiwiYW5hbHl6ZWRQaG90b3MiLCJhIiwiYWxsU2VsZWN0ZWRQZW9wbGUiLCJmbGF0TWFwIiwidG90YWxQZW9wbGVDb3VudCIsInJlZHVjZSIsInN1bSIsInRvdGFsU2VsZWN0ZWRDb3VudCIsInRvdGFsRXhjbHVkZWRDb3VudCIsImhhc011bHRpcGxlUGhvdG9zIiwidHJpZ2dlclBob3RvQW5hbHlzaXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useFileHandling.ts\n"));

/***/ })

});
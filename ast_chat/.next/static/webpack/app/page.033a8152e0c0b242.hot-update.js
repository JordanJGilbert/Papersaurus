"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardCache.ts":
/*!*******************************!*\
  !*** ./hooks/useCardCache.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardCache: function() { return /* binding */ useCardCache; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CACHE_KEY = \"vibecarding_template_cache\";\nconst IMAGE_CACHE_KEY = \"vibecarding_image_cache\";\nconst CACHE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst IMAGE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nconst BACKEND_API_BASE_URL = \"https://vibecarding.com\" || 0;\nconst MAX_CONCURRENT_IMAGES = 3; // Netflix-style: Very conservative concurrent loads\n// Use the regular list endpoint - it's fast enough and always current\nconst CARDS_LIST_URL = \"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list\");\n// Global cache state\nlet globalCache = null;\nlet isPreloading = false;\nconst cacheListeners = new Set();\nconst notifyListeners = ()=>{\n    cacheListeners.forEach((listener)=>listener());\n};\nconst useCardCache = ()=>{\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalCache);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Subscribe to cache updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updateCache = ()=>setCache(globalCache);\n        cacheListeners.add(updateCache);\n        return ()=>cacheListeners.delete(updateCache);\n    }, []);\n    // Load from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!globalCache) {\n            try {\n                const stored = localStorage.getItem(CACHE_KEY);\n                if (stored) {\n                    const parsed = JSON.parse(stored);\n                    const isExpired = Date.now() - parsed.lastFetched > CACHE_DURATION;\n                    if (!isExpired) {\n                        globalCache = parsed;\n                        setCache(parsed);\n                        console.log(\"\\uD83D\\uDCE6 Loaded cached template cards:\", parsed.cards.length);\n                    } else {\n                        localStorage.removeItem(CACHE_KEY);\n                        console.log(\"\\uD83D\\uDDD1️ Expired cache removed\");\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to load cache:\", error);\n                localStorage.removeItem(CACHE_KEY);\n            }\n        }\n    }, []);\n    const loadCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, search = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        // If we have complete cache and no search, return cached data immediately\n        if (!search && (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) && !reset) {\n            const startIndex = (page - 1) * 40;\n            const endIndex = startIndex + 40;\n            return globalCache.cards.slice(startIndex, endIndex);\n        }\n        // For searches or when no cache, try static endpoint first\n        if (!search && (reset || !globalCache)) {\n            try {\n                const response = await fetch(STATIC_CARDS_URL);\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data.cards && Array.isArray(data.cards)) {\n                        // Update global cache\n                        globalCache = {\n                            cards: data.cards,\n                            totalCount: data.totalCount || data.cards.length,\n                            lastFetched: Date.now(),\n                            isComplete: true\n                        };\n                        // Save to localStorage\n                        try {\n                            localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                        } catch (error) {\n                            console.warn(\"Failed to save cache to localStorage:\", error);\n                        }\n                        notifyListeners();\n                        // Return requested page\n                        const startIndex = (page - 1) * 40;\n                        const endIndex = startIndex + 40;\n                        return data.cards.slice(startIndex, endIndex);\n                    }\n                }\n            } catch (error) {\n                console.warn(\"Static endpoint failed, falling back to paginated API:\", error);\n            }\n        }\n        // Fallback to original paginated API\n        setIsLoading(true);\n        setError(null);\n        try {\n            const params = new URLSearchParams({\n                page: page.toString(),\n                per_page: \"40\",\n                ...search && {\n                    search\n                },\n                template_mode: \"true\"\n            });\n            const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?\").concat(params));\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.status === \"success\") {\n                const newCards = data.cards;\n                // Update global cache for non-search queries\n                if (!search) {\n                    if (reset || !globalCache) {\n                        globalCache = {\n                            cards: newCards,\n                            totalCount: data.pagination.total,\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    } else {\n                        // Append to existing cache\n                        const existingIds = new Set(globalCache.cards.map((card)=>card.id));\n                        const uniqueNewCards = newCards.filter((card)=>!existingIds.has(card.id));\n                        globalCache = {\n                            ...globalCache,\n                            cards: [\n                                ...globalCache.cards,\n                                ...uniqueNewCards\n                            ],\n                            lastFetched: Date.now(),\n                            isComplete: !data.pagination.has_next\n                        };\n                    }\n                    // Save to localStorage\n                    try {\n                        localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                    } catch (error) {\n                        console.warn(\"Failed to save cache to localStorage:\", error);\n                    }\n                    notifyListeners();\n                }\n                return newCards;\n            } else {\n                throw new Error(data.message || \"Failed to load cards\");\n            }\n        } catch (error) {\n            console.error(\"Error loading cards:\", error);\n            setError(error instanceof Error ? error.message : \"Failed to load cards\");\n            return [];\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    const preloadAllCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isPreloading) {\n            return;\n        }\n        // Check if we already have a complete cache that's fresh\n        if (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) {\n            const cacheAge = Date.now() - globalCache.lastFetched;\n            if (cacheAge < CACHE_DURATION) {\n                console.log(\"⚡ Using fresh cached template data:\", globalCache.cards.length, \"cards\");\n                // No image preloading - instant response like reference site\n                console.log(\"⚡ Using fresh cached data, no preloading needed\");\n                return;\n            }\n        }\n        isPreloading = true;\n        console.log(\"\\uD83D\\uDE80 Starting immediate template preload on page load...\");\n        try {\n            // Load all cards from static JSON endpoint (much faster!)\n            const response = await fetch(STATIC_CARDS_URL);\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.cards && Array.isArray(data.cards)) {\n                // Update global cache with all cards at once\n                globalCache = {\n                    cards: data.cards,\n                    totalCount: data.totalCount || data.cards.length,\n                    lastFetched: Date.now(),\n                    isComplete: true // We have all cards!\n                };\n                // Save to localStorage\n                try {\n                    localStorage.setItem(CACHE_KEY, JSON.stringify(globalCache));\n                } catch (error) {\n                    console.warn(\"Failed to save cache to localStorage:\", error);\n                }\n                notifyListeners();\n                console.log(\"✅ Page load template preload complete:\", data.cards.length, \"cards\");\n                // Ultra-simple: No image preloading, let browser lazy loading handle it\n                console.log(\"✅ Cards loaded, letting browser handle image loading\");\n            }\n        } catch (error) {\n            console.error(\"❌ Static preload failed, falling back to paginated:\", error);\n            // Fallback to old method if static fails\n            await preloadAllCardsLegacy();\n        } finally{\n            isPreloading = false;\n        }\n    }, []);\n    // Legacy preload method as fallback\n    const preloadAllCardsLegacy = async ()=>{\n        try {\n            let page = 1;\n            let hasMore = true;\n            let allCards = [];\n            while(hasMore && page <= 5){\n                var _data_pagination;\n                const cards = await loadCards(page, \"\", page === 1);\n                allCards = page === 1 ? cards : [\n                    ...allCards,\n                    ...cards\n                ];\n                // Check if we have more pages\n                const response = await fetch(\"\".concat(BACKEND_API_BASE_URL, \"/api/cards/list?page=\").concat(page, \"&per_page=40&template_mode=true\"));\n                const data = await response.json();\n                hasMore = ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.has_next) || false;\n                page++;\n            }\n            console.log(\"✅ Legacy preload complete:\", allCards.length, \"cards\");\n            await preloadImages(allCards.slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Legacy preload failed:\", error);\n        }\n    };\n    const preloadImages = async (cards)=>{\n        // Disabled for instant loading like reference site\n        console.log(\"\\uD83D\\uDE80 Skipping image preloading for instant response\");\n        return;\n    };\n    const getCachedCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, itemsPerPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n        if (!globalCache) return [];\n        const startIndex = (page - 1) * itemsPerPage;\n        const endIndex = startIndex + itemsPerPage;\n        return globalCache.cards.slice(startIndex, endIndex);\n    }, []);\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalCache = null;\n        localStorage.removeItem(CACHE_KEY);\n        setCache(null);\n        notifyListeners();\n    }, []);\n    return {\n        cache,\n        isLoading,\n        error,\n        loadCards,\n        preloadAllCards,\n        getCachedCards,\n        clearCache,\n        hasCache: !!globalCache,\n        isComplete: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.isComplete) || false,\n        totalCards: (globalCache === null || globalCache === void 0 ? void 0 : globalCache.totalCount) || 0\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRDYWNoZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFzQnpELE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGlCQUFpQixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQ3BELE1BQU1DLHVCQUF1QixLQUFLLEtBQUssTUFBTSxhQUFhO0FBQzFELE1BQU1DLHVCQUF1QkMseUJBQXVDLElBQUk7QUFDeEUsTUFBTUcsd0JBQXdCLEdBQUcsb0RBQW9EO0FBRXJGLHNFQUFzRTtBQUN0RSxNQUFNQyxpQkFBaUIsR0FBd0IsT0FBckJMLHNCQUFxQjtBQUUvQyxxQkFBcUI7QUFDckIsSUFBSU0sY0FBZ0M7QUFDcEMsSUFBSUMsZUFBZTtBQUNuQixNQUFNQyxpQkFBa0MsSUFBSUM7QUFFNUMsTUFBTUMsa0JBQWtCO0lBQ3RCRixlQUFlRyxPQUFPLENBQUNDLENBQUFBLFdBQVlBO0FBQ3JDO0FBRU8sTUFBTUMsZUFBZTtJQUMxQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFtQmE7SUFDckQsTUFBTSxDQUFDVSxXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixPQUFPQyxTQUFTLEdBQUcxQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsNkJBQTZCO0lBQzdCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU0wQixjQUFjLElBQU1MLFNBQVNUO1FBQ25DRSxlQUFlYSxHQUFHLENBQUNEO1FBQ25CLE9BQU8sSUFBTVosZUFBZWMsTUFBTSxDQUFDRjtJQUNyQyxHQUFHLEVBQUU7SUFFTCxrQ0FBa0M7SUFDbEMxQixnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ1ksYUFBYTtZQUNoQixJQUFJO2dCQUNGLE1BQU1pQixTQUFTQyxhQUFhQyxPQUFPLENBQUM3QjtnQkFDcEMsSUFBSTJCLFFBQVE7b0JBQ1YsTUFBTUcsU0FBb0JDLEtBQUtDLEtBQUssQ0FBQ0w7b0JBQ3JDLE1BQU1NLFlBQVlDLEtBQUtDLEdBQUcsS0FBS0wsT0FBT00sV0FBVyxHQUFHbEM7b0JBRXBELElBQUksQ0FBQytCLFdBQVc7d0JBQ2R2QixjQUFjb0I7d0JBQ2RYLFNBQVNXO3dCQUNUTyxRQUFRQyxHQUFHLENBQUMsOENBQW9DUixPQUFPUyxLQUFLLENBQUNDLE1BQU07b0JBQ3JFLE9BQU87d0JBQ0xaLGFBQWFhLFVBQVUsQ0FBQ3pDO3dCQUN4QnFDLFFBQVFDLEdBQUcsQ0FBQztvQkFDZDtnQkFDRjtZQUNGLEVBQUUsT0FBT2hCLE9BQU87Z0JBQ2RlLFFBQVFmLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUN2Q00sYUFBYWEsVUFBVSxDQUFDekM7WUFDMUI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU0wQyxZQUFZM0Msa0RBQVdBLENBQUM7WUFBTzRDLHdFQUFlLEdBQUdDLDBFQUFpQixJQUFJQyx5RUFBaUI7UUFDM0YsMEVBQTBFO1FBQzFFLElBQUksQ0FBQ0QsV0FBVWxDLHdCQUFBQSxrQ0FBQUEsWUFBYW9DLFVBQVUsS0FBSSxDQUFDRCxPQUFPO1lBQ2hELE1BQU1FLGFBQWEsQ0FBQ0osT0FBTyxLQUFLO1lBQ2hDLE1BQU1LLFdBQVdELGFBQWE7WUFDOUIsT0FBT3JDLFlBQVk2QixLQUFLLENBQUNVLEtBQUssQ0FBQ0YsWUFBWUM7UUFDN0M7UUFFQSwyREFBMkQ7UUFDM0QsSUFBSSxDQUFDSixVQUFXQyxDQUFBQSxTQUFTLENBQUNuQyxXQUFVLEdBQUk7WUFDdEMsSUFBSTtnQkFDRixNQUFNd0MsV0FBVyxNQUFNQyxNQUFNQztnQkFDN0IsSUFBSUYsU0FBU0csRUFBRSxFQUFFO29CQUNmLE1BQU1DLE9BQU8sTUFBTUosU0FBU0ssSUFBSTtvQkFDaEMsSUFBSUQsS0FBS2YsS0FBSyxJQUFJaUIsTUFBTUMsT0FBTyxDQUFDSCxLQUFLZixLQUFLLEdBQUc7d0JBQzNDLHNCQUFzQjt3QkFDdEI3QixjQUFjOzRCQUNaNkIsT0FBT2UsS0FBS2YsS0FBSzs0QkFDakJtQixZQUFZSixLQUFLSSxVQUFVLElBQUlKLEtBQUtmLEtBQUssQ0FBQ0MsTUFBTTs0QkFDaERKLGFBQWFGLEtBQUtDLEdBQUc7NEJBQ3JCVyxZQUFZO3dCQUNkO3dCQUVBLHVCQUF1Qjt3QkFDdkIsSUFBSTs0QkFDRmxCLGFBQWErQixPQUFPLENBQUMzRCxXQUFXK0IsS0FBSzZCLFNBQVMsQ0FBQ2xEO3dCQUNqRCxFQUFFLE9BQU9ZLE9BQU87NEJBQ2RlLFFBQVF3QixJQUFJLENBQUMseUNBQXlDdkM7d0JBQ3hEO3dCQUVBUjt3QkFFQSx3QkFBd0I7d0JBQ3hCLE1BQU1pQyxhQUFhLENBQUNKLE9BQU8sS0FBSzt3QkFDaEMsTUFBTUssV0FBV0QsYUFBYTt3QkFDOUIsT0FBT08sS0FBS2YsS0FBSyxDQUFDVSxLQUFLLENBQUNGLFlBQVlDO29CQUN0QztnQkFDRjtZQUNGLEVBQUUsT0FBTzFCLE9BQU87Z0JBQ2RlLFFBQVF3QixJQUFJLENBQUMsMERBQTBEdkM7WUFDekU7UUFDRjtRQUVBLHFDQUFxQztRQUNyQ0QsYUFBYTtRQUNiRSxTQUFTO1FBRVQsSUFBSTtZQUNGLE1BQU11QyxTQUFTLElBQUlDLGdCQUFnQjtnQkFDakNwQixNQUFNQSxLQUFLcUIsUUFBUTtnQkFDbkJDLFVBQVU7Z0JBQ1YsR0FBSXJCLFVBQVU7b0JBQUVBO2dCQUFPLENBQUM7Z0JBQ3hCc0IsZUFBZTtZQUNqQjtZQUVBLE1BQU1oQixXQUFXLE1BQU1DLE1BQU0sR0FBMENXLE9BQXZDMUQsc0JBQXFCLG9CQUF5QixPQUFQMEQ7WUFDdkUsSUFBSSxDQUFDWixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSWMsTUFBTSxRQUE0QmpCLE9BQXBCQSxTQUFTa0IsTUFBTSxFQUFDLE1BQXdCLE9BQXBCbEIsU0FBU21CLFVBQVU7WUFDakU7WUFFQSxNQUFNZixPQUFPLE1BQU1KLFNBQVNLLElBQUk7WUFFaEMsSUFBSUQsS0FBS2MsTUFBTSxLQUFLLFdBQVc7Z0JBQzdCLE1BQU1FLFdBQVdoQixLQUFLZixLQUFLO2dCQUUzQiw2Q0FBNkM7Z0JBQzdDLElBQUksQ0FBQ0ssUUFBUTtvQkFDWCxJQUFJQyxTQUFTLENBQUNuQyxhQUFhO3dCQUN6QkEsY0FBYzs0QkFDWjZCLE9BQU8rQjs0QkFDUFosWUFBWUosS0FBS2lCLFVBQVUsQ0FBQ0MsS0FBSzs0QkFDakNwQyxhQUFhRixLQUFLQyxHQUFHOzRCQUNyQlcsWUFBWSxDQUFDUSxLQUFLaUIsVUFBVSxDQUFDRSxRQUFRO3dCQUN2QztvQkFDRixPQUFPO3dCQUNMLDJCQUEyQjt3QkFDM0IsTUFBTUMsY0FBYyxJQUFJN0QsSUFBSUgsWUFBWTZCLEtBQUssQ0FBQ29DLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsRUFBRTt3QkFDakUsTUFBTUMsaUJBQWlCUixTQUFTUyxNQUFNLENBQUNILENBQUFBLE9BQVEsQ0FBQ0YsWUFBWU0sR0FBRyxDQUFDSixLQUFLQyxFQUFFO3dCQUV2RW5FLGNBQWM7NEJBQ1osR0FBR0EsV0FBVzs0QkFDZDZCLE9BQU87bUNBQUk3QixZQUFZNkIsS0FBSzttQ0FBS3VDOzZCQUFlOzRCQUNoRDFDLGFBQWFGLEtBQUtDLEdBQUc7NEJBQ3JCVyxZQUFZLENBQUNRLEtBQUtpQixVQUFVLENBQUNFLFFBQVE7d0JBQ3ZDO29CQUNGO29CQUVBLHVCQUF1QjtvQkFDdkIsSUFBSTt3QkFDRjdDLGFBQWErQixPQUFPLENBQUMzRCxXQUFXK0IsS0FBSzZCLFNBQVMsQ0FBQ2xEO29CQUNqRCxFQUFFLE9BQU9ZLE9BQU87d0JBQ2RlLFFBQVF3QixJQUFJLENBQUMseUNBQXlDdkM7b0JBQ3hEO29CQUVBUjtnQkFDRjtnQkFFQSxPQUFPd0Q7WUFDVCxPQUFPO2dCQUNMLE1BQU0sSUFBSUgsTUFBTWIsS0FBSzJCLE9BQU8sSUFBSTtZQUNsQztRQUNGLEVBQUUsT0FBTzNELE9BQU87WUFDZGUsUUFBUWYsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdENDLFNBQVNELGlCQUFpQjZDLFFBQVE3QyxNQUFNMkQsT0FBTyxHQUFHO1lBQ2xELE9BQU8sRUFBRTtRQUNYLFNBQVU7WUFDUjVELGFBQWE7UUFDZjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU02RCxrQkFBa0JuRixrREFBV0EsQ0FBQztRQUNsQyxJQUFJWSxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSx5REFBeUQ7UUFDekQsSUFBSUQsd0JBQUFBLGtDQUFBQSxZQUFhb0MsVUFBVSxFQUFFO1lBQzNCLE1BQU1xQyxXQUFXakQsS0FBS0MsR0FBRyxLQUFLekIsWUFBWTBCLFdBQVc7WUFDckQsSUFBSStDLFdBQVdqRixnQkFBZ0I7Z0JBQzdCbUMsUUFBUUMsR0FBRyxDQUFDLHVDQUF1QzVCLFlBQVk2QixLQUFLLENBQUNDLE1BQU0sRUFBRTtnQkFDN0UsNkRBQTZEO2dCQUM3REgsUUFBUUMsR0FBRyxDQUFDO2dCQUNaO1lBQ0Y7UUFDRjtRQUVBM0IsZUFBZTtRQUNmMEIsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLDBEQUEwRDtZQUMxRCxNQUFNWSxXQUFXLE1BQU1DLE1BQU1DO1lBQzdCLElBQUksQ0FBQ0YsU0FBU0csRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUljLE1BQU0sUUFBNEJqQixPQUFwQkEsU0FBU2tCLE1BQU0sRUFBQyxNQUF3QixPQUFwQmxCLFNBQVNtQixVQUFVO1lBQ2pFO1lBRUEsTUFBTWYsT0FBTyxNQUFNSixTQUFTSyxJQUFJO1lBQ2hDLElBQUlELEtBQUtmLEtBQUssSUFBSWlCLE1BQU1DLE9BQU8sQ0FBQ0gsS0FBS2YsS0FBSyxHQUFHO2dCQUMzQyw2Q0FBNkM7Z0JBQzdDN0IsY0FBYztvQkFDWjZCLE9BQU9lLEtBQUtmLEtBQUs7b0JBQ2pCbUIsWUFBWUosS0FBS0ksVUFBVSxJQUFJSixLQUFLZixLQUFLLENBQUNDLE1BQU07b0JBQ2hESixhQUFhRixLQUFLQyxHQUFHO29CQUNyQlcsWUFBWSxLQUFLLHFCQUFxQjtnQkFDeEM7Z0JBRUEsdUJBQXVCO2dCQUN2QixJQUFJO29CQUNGbEIsYUFBYStCLE9BQU8sQ0FBQzNELFdBQVcrQixLQUFLNkIsU0FBUyxDQUFDbEQ7Z0JBQ2pELEVBQUUsT0FBT1ksT0FBTztvQkFDZGUsUUFBUXdCLElBQUksQ0FBQyx5Q0FBeUN2QztnQkFDeEQ7Z0JBRUFSO2dCQUVBdUIsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ2dCLEtBQUtmLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO2dCQUV6RSx3RUFBd0U7Z0JBQ3hFSCxRQUFRQyxHQUFHLENBQUM7WUFDZDtRQUVGLEVBQUUsT0FBT2hCLE9BQU87WUFDZGUsUUFBUWYsS0FBSyxDQUFDLHVEQUF1REE7WUFDckUseUNBQXlDO1lBQ3pDLE1BQU04RDtRQUNSLFNBQVU7WUFDUnpFLGVBQWU7UUFDakI7SUFDRixHQUFHLEVBQUU7SUFFTCxvQ0FBb0M7SUFDcEMsTUFBTXlFLHdCQUF3QjtRQUM1QixJQUFJO1lBQ0YsSUFBSXpDLE9BQU87WUFDWCxJQUFJMEMsVUFBVTtZQUNkLElBQUlDLFdBQTBCLEVBQUU7WUFFaEMsTUFBT0QsV0FBVzFDLFFBQVEsRUFBRztvQkFPakJXO2dCQU5WLE1BQU1mLFFBQVEsTUFBTUcsVUFBVUMsTUFBTSxJQUFJQSxTQUFTO2dCQUNqRDJDLFdBQVczQyxTQUFTLElBQUlKLFFBQVE7dUJBQUkrQzt1QkFBYS9DO2lCQUFNO2dCQUV2RCw4QkFBOEI7Z0JBQzlCLE1BQU1XLFdBQVcsTUFBTUMsTUFBTSxHQUErQ1IsT0FBNUN2QyxzQkFBcUIseUJBQTRCLE9BQUx1QyxNQUFLO2dCQUNqRixNQUFNVyxPQUFPLE1BQU1KLFNBQVNLLElBQUk7Z0JBQ2hDOEIsVUFBVS9CLEVBQUFBLG1CQUFBQSxLQUFLaUIsVUFBVSxjQUFmakIsdUNBQUFBLGlCQUFpQm1CLFFBQVEsS0FBSTtnQkFDdkM5QjtZQUNGO1lBRUFOLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEJnRCxTQUFTOUMsTUFBTSxFQUFFO1lBQzNELE1BQU0rQyxjQUFjRCxTQUFTckMsS0FBSyxDQUFDLEdBQUc7UUFFeEMsRUFBRSxPQUFPM0IsT0FBTztZQUNkZSxRQUFRZixLQUFLLENBQUMsNEJBQTRCQTtRQUM1QztJQUNGO0lBRUEsTUFBTWlFLGdCQUFnQixPQUFPaEQ7UUFDM0IsbURBQW1EO1FBQ25ERixRQUFRQyxHQUFHLENBQUM7UUFDWjtJQUNGO0lBRUEsTUFBTWtELGlCQUFpQnpGLGtEQUFXQSxDQUFDO1lBQUM0Qyx3RUFBZSxHQUFHOEMsZ0ZBQXVCO1FBQzNFLElBQUksQ0FBQy9FLGFBQWEsT0FBTyxFQUFFO1FBRTNCLE1BQU1xQyxhQUFhLENBQUNKLE9BQU8sS0FBSzhDO1FBQ2hDLE1BQU16QyxXQUFXRCxhQUFhMEM7UUFDOUIsT0FBTy9FLFlBQVk2QixLQUFLLENBQUNVLEtBQUssQ0FBQ0YsWUFBWUM7SUFDN0MsR0FBRyxFQUFFO0lBRUwsTUFBTTBDLGFBQWEzRixrREFBV0EsQ0FBQztRQUM3QlcsY0FBYztRQUNka0IsYUFBYWEsVUFBVSxDQUFDekM7UUFDeEJtQixTQUFTO1FBQ1RMO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMSTtRQUNBRTtRQUNBRTtRQUNBb0I7UUFDQXdDO1FBQ0FNO1FBQ0FFO1FBQ0FDLFVBQVUsQ0FBQyxDQUFDakY7UUFDWm9DLFlBQVlwQyxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFvQyxVQUFVLEtBQUk7UUFDdkM4QyxZQUFZbEYsQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhZ0QsVUFBVSxLQUFJO0lBQ3pDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VDYXJkQ2FjaGUudHM/ZGM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIEdhbGxlcnlDYXJkIHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGZyb250Q292ZXI6IHN0cmluZztcbiAgYmFja0NvdmVyPzogc3RyaW5nO1xuICBsZWZ0UGFnZT86IHN0cmluZztcbiAgcmlnaHRQYWdlPzogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IG51bWJlcjtcbiAgY3JlYXRlZEF0Rm9ybWF0dGVkOiBzdHJpbmc7XG4gIHNoYXJlVXJsPzogc3RyaW5nO1xuICBoYXNJbWFnZXM6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDYXJkQ2FjaGUge1xuICBjYXJkczogR2FsbGVyeUNhcmRbXTtcbiAgdG90YWxDb3VudDogbnVtYmVyO1xuICBsYXN0RmV0Y2hlZDogbnVtYmVyO1xuICBpc0NvbXBsZXRlOiBib29sZWFuO1xufVxuXG5jb25zdCBDQUNIRV9LRVkgPSAndmliZWNhcmRpbmdfdGVtcGxhdGVfY2FjaGUnO1xuY29uc3QgSU1BR0VfQ0FDSEVfS0VZID0gJ3ZpYmVjYXJkaW5nX2ltYWdlX2NhY2hlJztcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcbmNvbnN0IElNQUdFX0NBQ0hFX0RVUkFUSU9OID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcbmNvbnN0IEJBQ0tFTkRfQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9BUElfVVJMIHx8ICdodHRwczovL3ZpYmVjYXJkaW5nLmNvbSc7XG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9JTUFHRVMgPSAzOyAvLyBOZXRmbGl4LXN0eWxlOiBWZXJ5IGNvbnNlcnZhdGl2ZSBjb25jdXJyZW50IGxvYWRzXG5cbi8vIFVzZSB0aGUgcmVndWxhciBsaXN0IGVuZHBvaW50IC0gaXQncyBmYXN0IGVub3VnaCBhbmQgYWx3YXlzIGN1cnJlbnRcbmNvbnN0IENBUkRTX0xJU1RfVVJMID0gYCR7QkFDS0VORF9BUElfQkFTRV9VUkx9L2FwaS9jYXJkcy9saXN0YDtcblxuLy8gR2xvYmFsIGNhY2hlIHN0YXRlXG5sZXQgZ2xvYmFsQ2FjaGU6IENhcmRDYWNoZSB8IG51bGwgPSBudWxsO1xubGV0IGlzUHJlbG9hZGluZyA9IGZhbHNlO1xuY29uc3QgY2FjaGVMaXN0ZW5lcnM6IFNldDwoKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcblxuY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICBjYWNoZUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNhcmRDYWNoZSA9ICgpID0+IHtcbiAgY29uc3QgW2NhY2hlLCBzZXRDYWNoZV0gPSB1c2VTdGF0ZTxDYXJkQ2FjaGUgfCBudWxsPihnbG9iYWxDYWNoZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gU3Vic2NyaWJlIHRvIGNhY2hlIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVDYWNoZSA9ICgpID0+IHNldENhY2hlKGdsb2JhbENhY2hlKTtcbiAgICBjYWNoZUxpc3RlbmVycy5hZGQodXBkYXRlQ2FjaGUpO1xuICAgIHJldHVybiAoKSA9PiBjYWNoZUxpc3RlbmVycy5kZWxldGUodXBkYXRlQ2FjaGUpO1xuICB9LCBbXSk7XG5cbiAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZ2xvYmFsQ2FjaGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKENBQ0hFX0tFWSk7XG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQ6IENhcmRDYWNoZSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBjb25zdCBpc0V4cGlyZWQgPSBEYXRlLm5vdygpIC0gcGFyc2VkLmxhc3RGZXRjaGVkID4gQ0FDSEVfRFVSQVRJT047XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0gcGFyc2VkO1xuICAgICAgICAgICAgc2V0Q2FjaGUocGFyc2VkKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIExvYWRlZCBjYWNoZWQgdGVtcGxhdGUgY2FyZHM6JywgcGFyc2VkLmNhcmRzLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKENBQ0hFX0tFWSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBFeHBpcmVkIGNhY2hlIHJlbW92ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNhY2hlOicsIGVycm9yKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBsb2FkQ2FyZHMgPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyID0gMSwgc2VhcmNoOiBzdHJpbmcgPSAnJywgcmVzZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8R2FsbGVyeUNhcmRbXT4gPT4ge1xuICAgIC8vIElmIHdlIGhhdmUgY29tcGxldGUgY2FjaGUgYW5kIG5vIHNlYXJjaCwgcmV0dXJuIGNhY2hlZCBkYXRhIGltbWVkaWF0ZWx5XG4gICAgaWYgKCFzZWFyY2ggJiYgZ2xvYmFsQ2FjaGU/LmlzQ29tcGxldGUgJiYgIXJlc2V0KSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIDQwO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgNDA7XG4gICAgICByZXR1cm4gZ2xvYmFsQ2FjaGUuY2FyZHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIEZvciBzZWFyY2hlcyBvciB3aGVuIG5vIGNhY2hlLCB0cnkgc3RhdGljIGVuZHBvaW50IGZpcnN0XG4gICAgaWYgKCFzZWFyY2ggJiYgKHJlc2V0IHx8ICFnbG9iYWxDYWNoZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goU1RBVElDX0NBUkRTX1VSTCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKGRhdGEuY2FyZHMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmNhcmRzKSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZVxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUgPSB7XG4gICAgICAgICAgICAgIGNhcmRzOiBkYXRhLmNhcmRzLFxuICAgICAgICAgICAgICB0b3RhbENvdW50OiBkYXRhLnRvdGFsQ291bnQgfHwgZGF0YS5jYXJkcy5sZW5ndGgsXG4gICAgICAgICAgICAgIGxhc3RGZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHJlcXVlc3RlZCBwYWdlXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIDQwO1xuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgNDA7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5jYXJkcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1N0YXRpYyBlbmRwb2ludCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBwYWdpbmF0ZWQgQVBJOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBvcmlnaW5hbCBwYWdpbmF0ZWQgQVBJXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBwYWdlOiBwYWdlLnRvU3RyaW5nKCksXG4gICAgICAgIHBlcl9wYWdlOiAnNDAnLFxuICAgICAgICAuLi4oc2VhcmNoICYmIHsgc2VhcmNoIH0pLFxuICAgICAgICB0ZW1wbGF0ZV9tb2RlOiAndHJ1ZSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9hcGkvY2FyZHMvbGlzdD8ke3BhcmFtc31gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICBjb25zdCBuZXdDYXJkcyA9IGRhdGEuY2FyZHMgYXMgR2FsbGVyeUNhcmRbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgY2FjaGUgZm9yIG5vbi1zZWFyY2ggcXVlcmllc1xuICAgICAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICAgIGlmIChyZXNldCB8fCAhZ2xvYmFsQ2FjaGUpIHtcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgICAgICBjYXJkczogbmV3Q2FyZHMsXG4gICAgICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEucGFnaW5hdGlvbi50b3RhbCxcbiAgICAgICAgICAgICAgbGFzdEZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIGlzQ29tcGxldGU6ICFkYXRhLnBhZ2luYXRpb24uaGFzX25leHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBleGlzdGluZyBjYWNoZVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGdsb2JhbENhY2hlLmNhcmRzLm1hcChjYXJkID0+IGNhcmQuaWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5ld0NhcmRzID0gbmV3Q2FyZHMuZmlsdGVyKGNhcmQgPT4gIWV4aXN0aW5nSWRzLmhhcyhjYXJkLmlkKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgICAgICAuLi5nbG9iYWxDYWNoZSxcbiAgICAgICAgICAgICAgY2FyZHM6IFsuLi5nbG9iYWxDYWNoZS5jYXJkcywgLi4udW5pcXVlTmV3Q2FyZHNdLFxuICAgICAgICAgICAgICBsYXN0RmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZTogIWRhdGEucGFnaW5hdGlvbi5oYXNfbmV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShDQUNIRV9LRVksIEpTT04uc3RyaW5naWZ5KGdsb2JhbENhY2hlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgY2FjaGUgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdDYXJkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBsb2FkIGNhcmRzJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgY2FyZHM6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGxvYWQgY2FyZHMnKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBwcmVsb2FkQWxsQ2FyZHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzUHJlbG9hZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjb21wbGV0ZSBjYWNoZSB0aGF0J3MgZnJlc2hcbiAgICBpZiAoZ2xvYmFsQ2FjaGU/LmlzQ29tcGxldGUpIHtcbiAgICAgIGNvbnN0IGNhY2hlQWdlID0gRGF0ZS5ub3coKSAtIGdsb2JhbENhY2hlLmxhc3RGZXRjaGVkO1xuICAgICAgaWYgKGNhY2hlQWdlIDwgQ0FDSEVfRFVSQVRJT04pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBVc2luZyBmcmVzaCBjYWNoZWQgdGVtcGxhdGUgZGF0YTonLCBnbG9iYWxDYWNoZS5jYXJkcy5sZW5ndGgsICdjYXJkcycpO1xuICAgICAgICAvLyBObyBpbWFnZSBwcmVsb2FkaW5nIC0gaW5zdGFudCByZXNwb25zZSBsaWtlIHJlZmVyZW5jZSBzaXRlXG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgVXNpbmcgZnJlc2ggY2FjaGVkIGRhdGEsIG5vIHByZWxvYWRpbmcgbmVlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ByZWxvYWRpbmcgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIGltbWVkaWF0ZSB0ZW1wbGF0ZSBwcmVsb2FkIG9uIHBhZ2UgbG9hZC4uLicpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgYWxsIGNhcmRzIGZyb20gc3RhdGljIEpTT04gZW5kcG9pbnQgKG11Y2ggZmFzdGVyISlcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goU1RBVElDX0NBUkRTX1VSTCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmIChkYXRhLmNhcmRzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jYXJkcykpIHtcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBjYWNoZSB3aXRoIGFsbCBjYXJkcyBhdCBvbmNlXG4gICAgICAgIGdsb2JhbENhY2hlID0ge1xuICAgICAgICAgIGNhcmRzOiBkYXRhLmNhcmRzLFxuICAgICAgICAgIHRvdGFsQ291bnQ6IGRhdGEudG90YWxDb3VudCB8fCBkYXRhLmNhcmRzLmxlbmd0aCxcbiAgICAgICAgICBsYXN0RmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlIC8vIFdlIGhhdmUgYWxsIGNhcmRzIVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgY2FjaGUgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBQYWdlIGxvYWQgdGVtcGxhdGUgcHJlbG9hZCBjb21wbGV0ZTonLCBkYXRhLmNhcmRzLmxlbmd0aCwgJ2NhcmRzJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVbHRyYS1zaW1wbGU6IE5vIGltYWdlIHByZWxvYWRpbmcsIGxldCBicm93c2VyIGxhenkgbG9hZGluZyBoYW5kbGUgaXRcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBDYXJkcyBsb2FkZWQsIGxldHRpbmcgYnJvd3NlciBoYW5kbGUgaW1hZ2UgbG9hZGluZycpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTdGF0aWMgcHJlbG9hZCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBwYWdpbmF0ZWQ6JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gb2xkIG1ldGhvZCBpZiBzdGF0aWMgZmFpbHNcbiAgICAgIGF3YWl0IHByZWxvYWRBbGxDYXJkc0xlZ2FjeSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1ByZWxvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBMZWdhY3kgcHJlbG9hZCBtZXRob2QgYXMgZmFsbGJhY2tcbiAgY29uc3QgcHJlbG9hZEFsbENhcmRzTGVnYWN5ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcGFnZSA9IDE7XG4gICAgICBsZXQgaGFzTW9yZSA9IHRydWU7XG4gICAgICBsZXQgYWxsQ2FyZHM6IEdhbGxlcnlDYXJkW10gPSBbXTtcblxuICAgICAgd2hpbGUgKGhhc01vcmUgJiYgcGFnZSA8PSA1KSB7IC8vIExpbWl0IHRvIDUgcGFnZXMgbWF4XG4gICAgICAgIGNvbnN0IGNhcmRzID0gYXdhaXQgbG9hZENhcmRzKHBhZ2UsICcnLCBwYWdlID09PSAxKTtcbiAgICAgICAgYWxsQ2FyZHMgPSBwYWdlID09PSAxID8gY2FyZHMgOiBbLi4uYWxsQ2FyZHMsIC4uLmNhcmRzXTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgbW9yZSBwYWdlc1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBQ0tFTkRfQVBJX0JBU0VfVVJMfS9hcGkvY2FyZHMvbGlzdD9wYWdlPSR7cGFnZX0mcGVyX3BhZ2U9NDAmdGVtcGxhdGVfbW9kZT10cnVlYCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGhhc01vcmUgPSBkYXRhLnBhZ2luYXRpb24/Lmhhc19uZXh0IHx8IGZhbHNlO1xuICAgICAgICBwYWdlKys7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgTGVnYWN5IHByZWxvYWQgY29tcGxldGU6JywgYWxsQ2FyZHMubGVuZ3RoLCAnY2FyZHMnKTtcbiAgICAgIGF3YWl0IHByZWxvYWRJbWFnZXMoYWxsQ2FyZHMuc2xpY2UoMCwgMjApKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgTGVnYWN5IHByZWxvYWQgZmFpbGVkOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcHJlbG9hZEltYWdlcyA9IGFzeW5jIChjYXJkczogR2FsbGVyeUNhcmRbXSkgPT4ge1xuICAgIC8vIERpc2FibGVkIGZvciBpbnN0YW50IGxvYWRpbmcgbGlrZSByZWZlcmVuY2Ugc2l0ZVxuICAgIGNvbnNvbGUubG9nKCfwn5qAIFNraXBwaW5nIGltYWdlIHByZWxvYWRpbmcgZm9yIGluc3RhbnQgcmVzcG9uc2UnKTtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgY29uc3QgZ2V0Q2FjaGVkQ2FyZHMgPSB1c2VDYWxsYmFjaygocGFnZTogbnVtYmVyID0gMSwgaXRlbXNQZXJQYWdlOiBudW1iZXIgPSA0MCk6IEdhbGxlcnlDYXJkW10gPT4ge1xuICAgIGlmICghZ2xvYmFsQ2FjaGUpIHJldHVybiBbXTtcbiAgICBcbiAgICBjb25zdCBzdGFydEluZGV4ID0gKHBhZ2UgLSAxKSAqIGl0ZW1zUGVyUGFnZTtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBpdGVtc1BlclBhZ2U7XG4gICAgcmV0dXJuIGdsb2JhbENhY2hlLmNhcmRzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNsZWFyQ2FjaGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZ2xvYmFsQ2FjaGUgPSBudWxsO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKENBQ0hFX0tFWSk7XG4gICAgc2V0Q2FjaGUobnVsbCk7XG4gICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGNhY2hlLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBsb2FkQ2FyZHMsXG4gICAgcHJlbG9hZEFsbENhcmRzLFxuICAgIGdldENhY2hlZENhcmRzLFxuICAgIGNsZWFyQ2FjaGUsXG4gICAgaGFzQ2FjaGU6ICEhZ2xvYmFsQ2FjaGUsXG4gICAgaXNDb21wbGV0ZTogZ2xvYmFsQ2FjaGU/LmlzQ29tcGxldGUgfHwgZmFsc2UsXG4gICAgdG90YWxDYXJkczogZ2xvYmFsQ2FjaGU/LnRvdGFsQ291bnQgfHwgMFxuICB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIkNBQ0hFX0tFWSIsIklNQUdFX0NBQ0hFX0tFWSIsIkNBQ0hFX0RVUkFUSU9OIiwiSU1BR0VfQ0FDSEVfRFVSQVRJT04iLCJCQUNLRU5EX0FQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CQUNLRU5EX0FQSV9VUkwiLCJNQVhfQ09OQ1VSUkVOVF9JTUFHRVMiLCJDQVJEU19MSVNUX1VSTCIsImdsb2JhbENhY2hlIiwiaXNQcmVsb2FkaW5nIiwiY2FjaGVMaXN0ZW5lcnMiLCJTZXQiLCJub3RpZnlMaXN0ZW5lcnMiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJ1c2VDYXJkQ2FjaGUiLCJjYWNoZSIsInNldENhY2hlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInVwZGF0ZUNhY2hlIiwiYWRkIiwiZGVsZXRlIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImlzRXhwaXJlZCIsIkRhdGUiLCJub3ciLCJsYXN0RmV0Y2hlZCIsImNvbnNvbGUiLCJsb2ciLCJjYXJkcyIsImxlbmd0aCIsInJlbW92ZUl0ZW0iLCJsb2FkQ2FyZHMiLCJwYWdlIiwic2VhcmNoIiwicmVzZXQiLCJpc0NvbXBsZXRlIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic2xpY2UiLCJyZXNwb25zZSIsImZldGNoIiwiU1RBVElDX0NBUkRTX1VSTCIsIm9rIiwiZGF0YSIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJ0b3RhbENvdW50Iiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIndhcm4iLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwidGVtcGxhdGVfbW9kZSIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm5ld0NhcmRzIiwicGFnaW5hdGlvbiIsInRvdGFsIiwiaGFzX25leHQiLCJleGlzdGluZ0lkcyIsIm1hcCIsImNhcmQiLCJpZCIsInVuaXF1ZU5ld0NhcmRzIiwiZmlsdGVyIiwiaGFzIiwibWVzc2FnZSIsInByZWxvYWRBbGxDYXJkcyIsImNhY2hlQWdlIiwicHJlbG9hZEFsbENhcmRzTGVnYWN5IiwiaGFzTW9yZSIsImFsbENhcmRzIiwicHJlbG9hZEltYWdlcyIsImdldENhY2hlZENhcmRzIiwiaXRlbXNQZXJQYWdlIiwiY2xlYXJDYWNoZSIsImhhc0NhY2hlIiwidG90YWxDYXJkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardCache.ts\n"));

/***/ })

});
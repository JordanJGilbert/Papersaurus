"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCardForm.tsx":
/*!*******************************!*\
  !*** ./hooks/useCardForm.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardForm: function() { return /* binding */ useCardForm; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/storageManager */ \"(app-pages-browser)/./lib/storageManager.ts\");\n/* __next_internal_client_entry_do_not_use__ useCardForm auto */ var _s = $RefreshSig$();\n\n\nconst defaultFormData = {\n    // Step 1: Card Basics\n    selectedType: \"birthday\",\n    customCardType: \"\",\n    selectedTone: \"funny\",\n    toField: \"\",\n    fromField: \"\",\n    relationshipField: \"\",\n    // Step 2: Content Creation\n    prompt: \"\",\n    finalCardMessage: \"\",\n    isHandwrittenMessage: false,\n    // Step 3: Personalization\n    selectedArtisticStyle: \"ai-smart-style\",\n    customStyleDescription: \"\",\n    referenceImages: [],\n    referenceImageUrls: [],\n    // Step 4: Details\n    userEmail: \"\",\n    selectedImageModel: \"gpt-image-1\",\n    selectedDraftModel: \"gpt-image-1\",\n    selectedPaperSize: \"standard\",\n    numberOfCards: 1,\n    isFrontBackOnly: false\n};\n// Helper function to create serializable form data (excludes File objects)\nconst createSerializableFormData = (formData)=>{\n    const { referenceImages, ...serializableData } = formData;\n    return serializableData;\n};\nfunction useCardForm() {\n    _s();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultFormData);\n    const [wizardState, setWizardState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        currentStep: 1,\n        completedSteps: []\n    });\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Initialize form data from storage on component mount (after hydration)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ( true && !isInitialLoadComplete) {\n            const session = _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.getSession();\n            if (session) {\n                setFormData({\n                    ...defaultFormData,\n                    ...session.formData,\n                    referenceImages: []\n                });\n                setWizardState(session.wizardState);\n            }\n            setIsInitialLoadComplete(true);\n        }\n    }, [\n        isInitialLoadComplete\n    ]);\n    // Save form data to storage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialLoadComplete) return;\n        const serializableData = createSerializableFormData(formData);\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.saveSession(serializableData, wizardState);\n    }, [\n        formData,\n        wizardState,\n        isInitialLoadComplete\n    ]);\n    const updateFormData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setFormData((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const resetForm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFormData(defaultFormData);\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearSession();\n    }, []);\n    const clearStoredData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        _lib_storageManager__WEBPACK_IMPORTED_MODULE_1__.storage.clearAll();\n    }, []);\n    const updateWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updates)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                ...updates\n            }));\n    }, []);\n    const markStepCompleted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        setWizardState((prev)=>({\n                ...prev,\n                completedSteps: prev.completedSteps.includes(step) ? prev.completedSteps : [\n                    ...prev.completedSteps,\n                    step\n                ]\n            }));\n    }, []);\n    const resetWizardState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setWizardState({\n            currentStep: 1,\n            completedSteps: []\n        });\n    }, []);\n    const validateStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        switch(step){\n            case 1:\n                // Card type is required\n                if (!formData.selectedType) return false;\n                // If custom type is selected, custom description is required\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) return false;\n                // Tone is required\n                if (!formData.selectedTone) return false;\n                // If photos are uploaded, they must have descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    // Check if we have photoReferences data\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) return false;\n                    // Check if all photos have descriptions\n                    const allHaveDescriptions = formData.photoReferences.every((ref)=>ref.description && ref.description.trim());\n                    if (!allHaveDescriptions) return false;\n                }\n                return true;\n            case 2:\n                // All fields are optional - let AI generate defaults\n                return true;\n            case 3:\n                // All fields are optional\n                // If custom style is selected, description is required\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) return false;\n                // If reference images with incompatible model\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") return false;\n                return true;\n            case 4:\n                // Email is required\n                if (!formData.userEmail.trim()) return false;\n                // Basic email validation\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                if (!emailRegex.test(formData.userEmail)) return false;\n                return true;\n            case 5:\n                // All previous steps must be valid\n                return validateStep(1) && validateStep(2) && validateStep(3) && validateStep(4);\n            default:\n                return false;\n        }\n    }, [\n        formData\n    ]);\n    const getStepSummary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const summary = [];\n        switch(step){\n            case 1:\n                const cardType = formData.selectedType === \"custom\" ? formData.customCardType : formData.selectedType;\n                summary.push(\"Card Type: \".concat(cardType || \"Not selected\"));\n                summary.push(\"Tone: \".concat(formData.selectedTone || \"Not selected\"));\n                if (formData.toField) summary.push(\"To: \".concat(formData.toField));\n                if (formData.fromField) summary.push(\"From: \".concat(formData.fromField));\n                break;\n            case 2:\n                if (formData.prompt) summary.push(\"Description: \".concat(formData.prompt.substring(0, 50), \"...\"));\n                if (formData.finalCardMessage) summary.push(\"Message: \".concat(formData.finalCardMessage.substring(0, 50), \"...\"));\n                if (formData.isHandwrittenMessage) summary.push(\"Handwritten message space included\");\n                break;\n            case 3:\n                summary.push(\"Style: \".concat(formData.selectedArtisticStyle));\n                if (formData.referenceImageUrls.length > 0) {\n                    summary.push(\"Reference photos: \".concat(formData.referenceImageUrls.length, \" uploaded\"));\n                }\n                break;\n            case 4:\n                summary.push(\"Email: \".concat(formData.userEmail));\n                summary.push(\"Model: \".concat(formData.selectedImageModel));\n                summary.push(\"Paper: \".concat(formData.selectedPaperSize));\n                if (formData.isFrontBackOnly) summary.push(\"Front/back only\");\n                break;\n        }\n        return summary;\n    }, [\n        formData\n    ]);\n    const getValidationErrors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((step)=>{\n        const errors = [];\n        switch(step){\n            case 1:\n                if (!formData.selectedType) errors.push(\"Please select a card type\");\n                if (formData.selectedType === \"custom\" && !formData.customCardType.trim()) {\n                    errors.push(\"Please describe your custom card type\");\n                }\n                if (!formData.selectedTone) errors.push(\"Please select a tone\");\n                // Check photo descriptions\n                if (formData.referenceImageUrls.length > 0) {\n                    if (!formData.photoReferences || formData.photoReferences.length === 0) {\n                        errors.push(\"Please describe who's in your photos\");\n                    } else {\n                        const missingDescriptions = formData.photoReferences.filter((ref)=>!ref.description || !ref.description.trim()).length;\n                        if (missingDescriptions > 0) {\n                            errors.push(\"Please describe who's in \".concat(missingDescriptions, \" photo\").concat(missingDescriptions > 1 ? \"s\" : \"\"));\n                        }\n                    }\n                }\n                break;\n            case 3:\n                if (formData.selectedArtisticStyle === \"custom\" && !formData.customStyleDescription.trim()) {\n                    errors.push(\"Please describe your custom artistic style\");\n                }\n                if (formData.referenceImageUrls.length > 0 && formData.selectedImageModel !== \"gpt-image-1\") {\n                    errors.push(\"Reference photos are only supported with GPT Image 1 model\");\n                }\n                break;\n            case 4:\n                if (!formData.userEmail.trim()) {\n                    errors.push(\"Email address is required\");\n                } else {\n                    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                    if (!emailRegex.test(formData.userEmail)) {\n                        errors.push(\"Please enter a valid email address\");\n                    }\n                }\n                break;\n        }\n        return errors;\n    }, [\n        formData\n    ]);\n    return {\n        formData,\n        updateFormData,\n        resetForm,\n        clearStoredData,\n        validateStep,\n        getStepSummary,\n        getValidationErrors,\n        isInitialLoadComplete,\n        wizardState: {\n            ...wizardState,\n            updateCurrentStep: (step)=>updateWizardState({\n                    currentStep: step\n                }),\n            markStepCompleted,\n            resetWizardState\n        },\n        updateWizardState\n    };\n}\n_s(useCardForm, \"YXsICAdHNvhScUcXpS7y9ubE7jc=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUV5RDtBQUNWO0FBaUMvQyxNQUFNSSxrQkFBZ0M7SUFDcEMsc0JBQXNCO0lBQ3RCQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsbUJBQW1CO0lBRW5CLDJCQUEyQjtJQUMzQkMsUUFBUTtJQUNSQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUV0QiwwQkFBMEI7SUFDMUJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxpQkFBaUIsRUFBRTtJQUNuQkMsb0JBQW9CLEVBQUU7SUFFdEIsa0JBQWtCO0lBQ2xCQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsb0JBQW9CO0lBQ3BCQyxtQkFBbUI7SUFDbkJDLGVBQWU7SUFDZkMsaUJBQWlCO0FBQ25CO0FBRUEsMkVBQTJFO0FBQzNFLE1BQU1DLDZCQUE2QixDQUFDQztJQUNsQyxNQUFNLEVBQUVULGVBQWUsRUFBRSxHQUFHVSxrQkFBa0IsR0FBR0Q7SUFDakQsT0FBT0M7QUFDVDtBQUVPLFNBQVNDOztJQUNkLE1BQU0sQ0FBQ0YsVUFBVUcsWUFBWSxHQUFHNUIsK0NBQVFBLENBQWVJO0lBQ3ZELE1BQU0sQ0FBQ3lCLGFBQWFDLGVBQWUsR0FBRzlCLCtDQUFRQSxDQUFDO1FBQUUrQixhQUFhO1FBQUdDLGdCQUFnQixFQUFFO0lBQWE7SUFDaEcsTUFBTSxDQUFDQyx1QkFBdUJDLHlCQUF5QixHQUFHbEMsK0NBQVFBLENBQUM7SUFFbkUseUVBQXlFO0lBQ3pFRSxnREFBU0EsQ0FBQztRQUNSLElBQUksS0FBa0IsSUFBZSxDQUFDK0IsdUJBQXVCO1lBQzNELE1BQU1FLFVBQVVoQyx3REFBT0EsQ0FBQ2lDLFVBQVU7WUFDbEMsSUFBSUQsU0FBUztnQkFDWFAsWUFBWTtvQkFDVixHQUFHeEIsZUFBZTtvQkFDbEIsR0FBRytCLFFBQVFWLFFBQVE7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O1lBQ1gsR0FBR0EsV0FBVztZQUNkd0MsbUJBQW1CLENBQUN0QixPQUFpQkYsa0JBQWtCO29CQUFFZCxhQUFhZ0I7Z0JBQUs7WUFDM0VEO1lBQ0FHO1FBQ0Y7UUFDQUo7SUFDRjtBQUNGO0dBaE5nQmxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNhcmRGb3JtLnRzeD80YzM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gXCJAL2xpYi9zdG9yYWdlTWFuYWdlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRGb3JtRGF0YSB7XG4gIC8vIFN0ZXAgMTogQ2FyZCBCYXNpY3NcbiAgc2VsZWN0ZWRUeXBlOiBzdHJpbmc7XG4gIGN1c3RvbUNhcmRUeXBlOiBzdHJpbmc7XG4gIHNlbGVjdGVkVG9uZTogc3RyaW5nO1xuICB0b0ZpZWxkOiBzdHJpbmc7XG4gIGZyb21GaWVsZDogc3RyaW5nO1xuICByZWxhdGlvbnNoaXBGaWVsZDogc3RyaW5nO1xuXG4gIC8vIFN0ZXAgMjogQ29udGVudCBDcmVhdGlvblxuICBwcm9tcHQ6IHN0cmluZztcbiAgZmluYWxDYXJkTWVzc2FnZTogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZTogYm9vbGVhbjtcblxuICAvLyBTdGVwIDM6IFBlcnNvbmFsaXphdGlvblxuICBzZWxlY3RlZEFydGlzdGljU3R5bGU6IHN0cmluZztcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogc3RyaW5nO1xuICByZWZlcmVuY2VJbWFnZXM6IEZpbGVbXTtcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBzdHJpbmdbXTtcbiAgcGhvdG9SZWZlcmVuY2VzPzogQXJyYXk8eyBpbWFnZVVybDogc3RyaW5nOyBpbWFnZUluZGV4OiBudW1iZXI7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyB9PjtcbiAgcGVyc29uYWxUcmFpdHM/OiBzdHJpbmc7XG5cbiAgLy8gU3RlcCA0OiBEZXRhaWxzXG4gIHVzZXJFbWFpbDogc3RyaW5nO1xuICBzZWxlY3RlZEltYWdlTW9kZWw6IHN0cmluZztcbiAgc2VsZWN0ZWREcmFmdE1vZGVsOiBzdHJpbmc7XG4gIHNlbGVjdGVkUGFwZXJTaXplOiBzdHJpbmc7XG4gIG51bWJlck9mQ2FyZHM6IG51bWJlcjtcbiAgaXNGcm9udEJhY2tPbmx5OiBib29sZWFuO1xufVxuXG5jb25zdCBkZWZhdWx0Rm9ybURhdGE6IENhcmRGb3JtRGF0YSA9IHtcbiAgLy8gU3RlcCAxOiBDYXJkIEJhc2ljc1xuICBzZWxlY3RlZFR5cGU6IFwiYmlydGhkYXlcIixcbiAgY3VzdG9tQ2FyZFR5cGU6IFwiXCIsXG4gIHNlbGVjdGVkVG9uZTogXCJmdW5ueVwiLFxuICB0b0ZpZWxkOiBcIlwiLFxuICBmcm9tRmllbGQ6IFwiXCIsXG4gIHJlbGF0aW9uc2hpcEZpZWxkOiBcIlwiLFxuXG4gIC8vIFN0ZXAgMjogQ29udGVudCBDcmVhdGlvblxuICBwcm9tcHQ6IFwiXCIsXG4gIGZpbmFsQ2FyZE1lc3NhZ2U6IFwiXCIsXG4gIGlzSGFuZHdyaXR0ZW5NZXNzYWdlOiBmYWxzZSxcblxuICAvLyBTdGVwIDM6IFBlcnNvbmFsaXphdGlvblxuICBzZWxlY3RlZEFydGlzdGljU3R5bGU6IFwiYWktc21hcnQtc3R5bGVcIixcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogXCJcIixcbiAgcmVmZXJlbmNlSW1hZ2VzOiBbXSxcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzOiBbXSxcblxuICAvLyBTdGVwIDQ6IERldGFpbHNcbiAgdXNlckVtYWlsOiBcIlwiLFxuICBzZWxlY3RlZEltYWdlTW9kZWw6IFwiZ3B0LWltYWdlLTFcIixcbiAgc2VsZWN0ZWREcmFmdE1vZGVsOiBcImdwdC1pbWFnZS0xXCIsXG4gIHNlbGVjdGVkUGFwZXJTaXplOiBcInN0YW5kYXJkXCIsXG4gIG51bWJlck9mQ2FyZHM6IDEsXG4gIGlzRnJvbnRCYWNrT25seTogZmFsc2UsXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHNlcmlhbGl6YWJsZSBmb3JtIGRhdGEgKGV4Y2x1ZGVzIEZpbGUgb2JqZWN0cylcbmNvbnN0IGNyZWF0ZVNlcmlhbGl6YWJsZUZvcm1EYXRhID0gKGZvcm1EYXRhOiBDYXJkRm9ybURhdGEpOiBPbWl0PENhcmRGb3JtRGF0YSwgJ3JlZmVyZW5jZUltYWdlcyc+ID0+IHtcbiAgY29uc3QgeyByZWZlcmVuY2VJbWFnZXMsIC4uLnNlcmlhbGl6YWJsZURhdGEgfSA9IGZvcm1EYXRhO1xuICByZXR1cm4gc2VyaWFsaXphYmxlRGF0YTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYXJkRm9ybSgpIHtcbiAgY29uc3QgW2Zvcm1EYXRhLCBzZXRGb3JtRGF0YV0gPSB1c2VTdGF0ZTxDYXJkRm9ybURhdGE+KGRlZmF1bHRGb3JtRGF0YSk7XG4gIGNvbnN0IFt3aXphcmRTdGF0ZSwgc2V0V2l6YXJkU3RhdGVdID0gdXNlU3RhdGUoeyBjdXJyZW50U3RlcDogMSwgY29tcGxldGVkU3RlcHM6IFtdIGFzIG51bWJlcltdIH0pO1xuICBjb25zdCBbaXNJbml0aWFsTG9hZENvbXBsZXRlLCBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIEluaXRpYWxpemUgZm9ybSBkYXRhIGZyb20gc3RvcmFnZSBvbiBjb21wb25lbnQgbW91bnQgKGFmdGVyIGh5ZHJhdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSW5pdGlhbExvYWRDb21wbGV0ZSkge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IHN0b3JhZ2UuZ2V0U2Vzc2lvbigpO1xuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2V0Rm9ybURhdGEoe1xuICAgICAgICAgIC4uLmRlZmF1bHRGb3JtRGF0YSxcbiAgICAgICAgICAuLi5zZXNzaW9uLmZvcm1EYXRhLFxuICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sIC8vIEFsd2F5cyByZXNldCBGaWxlIG9iamVjdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFdpemFyZFN0YXRlKHNlc3Npb24ud2l6YXJkU3RhdGUpO1xuICAgICAgfVxuICAgICAgc2V0SXNJbml0aWFsTG9hZENvbXBsZXRlKHRydWUpO1xuICAgIH1cbiAgfSwgW2lzSW5pdGlhbExvYWRDb21wbGV0ZV0pO1xuXG4gIC8vIFNhdmUgZm9ybSBkYXRhIHRvIHN0b3JhZ2Ugd2hlbmV2ZXIgaXQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNJbml0aWFsTG9hZENvbXBsZXRlKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXJpYWxpemFibGVEYXRhID0gY3JlYXRlU2VyaWFsaXphYmxlRm9ybURhdGEoZm9ybURhdGEpO1xuICAgIHN0b3JhZ2Uuc2F2ZVNlc3Npb24oc2VyaWFsaXphYmxlRGF0YSwgd2l6YXJkU3RhdGUpO1xuICB9LCBbZm9ybURhdGEsIHdpemFyZFN0YXRlLCBpc0luaXRpYWxMb2FkQ29tcGxldGVdKTtcblxuICBjb25zdCB1cGRhdGVGb3JtRGF0YSA9IHVzZUNhbGxiYWNrKCh1cGRhdGVzOiBQYXJ0aWFsPENhcmRGb3JtRGF0YT4pID0+IHtcbiAgICBzZXRGb3JtRGF0YShwcmV2ID0+ICh7IC4uLnByZXYsIC4uLnVwZGF0ZXMgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVzZXRGb3JtID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEZvcm1EYXRhKGRlZmF1bHRGb3JtRGF0YSk7XG4gICAgc2V0V2l6YXJkU3RhdGUoeyBjdXJyZW50U3RlcDogMSwgY29tcGxldGVkU3RlcHM6IFtdIH0pO1xuICAgIHN0b3JhZ2UuY2xlYXJTZXNzaW9uKCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhclN0b3JlZERhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc3RvcmFnZS5jbGVhckFsbCgpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdXBkYXRlV2l6YXJkU3RhdGUgPSB1c2VDYWxsYmFjaygodXBkYXRlczogUGFydGlhbDx0eXBlb2Ygd2l6YXJkU3RhdGU+KSA9PiB7XG4gICAgc2V0V2l6YXJkU3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCAuLi51cGRhdGVzIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IG1hcmtTdGVwQ29tcGxldGVkID0gdXNlQ2FsbGJhY2soKHN0ZXA6IG51bWJlcikgPT4ge1xuICAgIHNldFdpemFyZFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBjb21wbGV0ZWRTdGVwczogcHJldi5jb21wbGV0ZWRTdGVwcy5pbmNsdWRlcyhzdGVwKSBcbiAgICAgICAgPyBwcmV2LmNvbXBsZXRlZFN0ZXBzIFxuICAgICAgICA6IFsuLi5wcmV2LmNvbXBsZXRlZFN0ZXBzLCBzdGVwXVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlc2V0V2l6YXJkU3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0V2l6YXJkU3RhdGUoeyBjdXJyZW50U3RlcDogMSwgY29tcGxldGVkU3RlcHM6IFtdIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdmFsaWRhdGVTdGVwID0gdXNlQ2FsbGJhY2soKHN0ZXA6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxOiAvLyBDYXJkIEJhc2ljc1xuICAgICAgICAvLyBDYXJkIHR5cGUgaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFmb3JtRGF0YS5zZWxlY3RlZFR5cGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgY3VzdG9tIHR5cGUgaXMgc2VsZWN0ZWQsIGN1c3RvbSBkZXNjcmlwdGlvbiBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoZm9ybURhdGEuc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiICYmICFmb3JtRGF0YS5jdXN0b21DYXJkVHlwZS50cmltKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVG9uZSBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoIWZvcm1EYXRhLnNlbGVjdGVkVG9uZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBwaG90b3MgYXJlIHVwbG9hZGVkLCB0aGV5IG11c3QgaGF2ZSBkZXNjcmlwdGlvbnNcbiAgICAgICAgaWYgKGZvcm1EYXRhLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBwaG90b1JlZmVyZW5jZXMgZGF0YVxuICAgICAgICAgIGlmICghZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzIHx8IGZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgcGhvdG9zIGhhdmUgZGVzY3JpcHRpb25zXG4gICAgICAgICAgY29uc3QgYWxsSGF2ZURlc2NyaXB0aW9ucyA9IGZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcy5ldmVyeShyZWYgPT4gcmVmLmRlc2NyaXB0aW9uICYmIHJlZi5kZXNjcmlwdGlvbi50cmltKCkpO1xuICAgICAgICAgIGlmICghYWxsSGF2ZURlc2NyaXB0aW9ucykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIDI6IC8vIENvbnRlbnQgQ3JlYXRpb25cbiAgICAgICAgLy8gQWxsIGZpZWxkcyBhcmUgb3B0aW9uYWwgLSBsZXQgQUkgZ2VuZXJhdGUgZGVmYXVsdHNcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgMzogLy8gUGVyc29uYWxpemF0aW9uXG4gICAgICAgIC8vIEFsbCBmaWVsZHMgYXJlIG9wdGlvbmFsXG4gICAgICAgIC8vIElmIGN1c3RvbSBzdHlsZSBpcyBzZWxlY3RlZCwgZGVzY3JpcHRpb24gaXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKGZvcm1EYXRhLnNlbGVjdGVkQXJ0aXN0aWNTdHlsZSA9PT0gXCJjdXN0b21cIiAmJiAhZm9ybURhdGEuY3VzdG9tU3R5bGVEZXNjcmlwdGlvbi50cmltKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgcmVmZXJlbmNlIGltYWdlcyB3aXRoIGluY29tcGF0aWJsZSBtb2RlbFxuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgZm9ybURhdGEuc2VsZWN0ZWRJbWFnZU1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgNDogLy8gRGV0YWlsc1xuICAgICAgICAvLyBFbWFpbCBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoIWZvcm1EYXRhLnVzZXJFbWFpbC50cmltKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQmFzaWMgZW1haWwgdmFsaWRhdGlvblxuICAgICAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGZvcm1EYXRhLnVzZXJFbWFpbCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgNTogLy8gR2VuZXJhdGVcbiAgICAgICAgLy8gQWxsIHByZXZpb3VzIHN0ZXBzIG11c3QgYmUgdmFsaWRcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3RlcCgxKSAmJiB2YWxpZGF0ZVN0ZXAoMikgJiYgdmFsaWRhdGVTdGVwKDMpICYmIHZhbGlkYXRlU3RlcCg0KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgW2Zvcm1EYXRhXSk7XG5cbiAgY29uc3QgZ2V0U3RlcFN1bW1hcnkgPSB1c2VDYWxsYmFjaygoc3RlcDogbnVtYmVyKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IHN1bW1hcnk6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvbnN0IGNhcmRUeXBlID0gZm9ybURhdGEuc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiID8gZm9ybURhdGEuY3VzdG9tQ2FyZFR5cGUgOiBmb3JtRGF0YS5zZWxlY3RlZFR5cGU7XG4gICAgICAgIHN1bW1hcnkucHVzaChgQ2FyZCBUeXBlOiAke2NhcmRUeXBlIHx8IFwiTm90IHNlbGVjdGVkXCJ9YCk7XG4gICAgICAgIHN1bW1hcnkucHVzaChgVG9uZTogJHtmb3JtRGF0YS5zZWxlY3RlZFRvbmUgfHwgXCJOb3Qgc2VsZWN0ZWRcIn1gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLnRvRmllbGQpIHN1bW1hcnkucHVzaChgVG86ICR7Zm9ybURhdGEudG9GaWVsZH1gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLmZyb21GaWVsZCkgc3VtbWFyeS5wdXNoKGBGcm9tOiAke2Zvcm1EYXRhLmZyb21GaWVsZH1gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWYgKGZvcm1EYXRhLnByb21wdCkgc3VtbWFyeS5wdXNoKGBEZXNjcmlwdGlvbjogJHtmb3JtRGF0YS5wcm9tcHQuc3Vic3RyaW5nKDAsIDUwKX0uLi5gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLmZpbmFsQ2FyZE1lc3NhZ2UpIHN1bW1hcnkucHVzaChgTWVzc2FnZTogJHtmb3JtRGF0YS5maW5hbENhcmRNZXNzYWdlLnN1YnN0cmluZygwLCA1MCl9Li4uYCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5pc0hhbmR3cml0dGVuTWVzc2FnZSkgc3VtbWFyeS5wdXNoKFwiSGFuZHdyaXR0ZW4gbWVzc2FnZSBzcGFjZSBpbmNsdWRlZFwiKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBTdHlsZTogJHtmb3JtRGF0YS5zZWxlY3RlZEFydGlzdGljU3R5bGV9YCk7XG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN1bW1hcnkucHVzaChgUmVmZXJlbmNlIHBob3RvczogJHtmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RofSB1cGxvYWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN1bW1hcnkucHVzaChgRW1haWw6ICR7Zm9ybURhdGEudXNlckVtYWlsfWApO1xuICAgICAgICBzdW1tYXJ5LnB1c2goYE1vZGVsOiAke2Zvcm1EYXRhLnNlbGVjdGVkSW1hZ2VNb2RlbH1gKTtcbiAgICAgICAgc3VtbWFyeS5wdXNoKGBQYXBlcjogJHtmb3JtRGF0YS5zZWxlY3RlZFBhcGVyU2l6ZX1gKTtcbiAgICAgICAgaWYgKGZvcm1EYXRhLmlzRnJvbnRCYWNrT25seSkgc3VtbWFyeS5wdXNoKFwiRnJvbnQvYmFjayBvbmx5XCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfSwgW2Zvcm1EYXRhXSk7XG5cbiAgY29uc3QgZ2V0VmFsaWRhdGlvbkVycm9ycyA9IHVzZUNhbGxiYWNrKChzdGVwOiBudW1iZXIpOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmICghZm9ybURhdGEuc2VsZWN0ZWRUeXBlKSBlcnJvcnMucHVzaChcIlBsZWFzZSBzZWxlY3QgYSBjYXJkIHR5cGVcIik7XG4gICAgICAgIGlmIChmb3JtRGF0YS5zZWxlY3RlZFR5cGUgPT09IFwiY3VzdG9tXCIgJiYgIWZvcm1EYXRhLmN1c3RvbUNhcmRUeXBlLnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIGRlc2NyaWJlIHlvdXIgY3VzdG9tIGNhcmQgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvcm1EYXRhLnNlbGVjdGVkVG9uZSkgZXJyb3JzLnB1c2goXCJQbGVhc2Ugc2VsZWN0IGEgdG9uZVwiKTtcbiAgICAgICAgLy8gQ2hlY2sgcGhvdG8gZGVzY3JpcHRpb25zXG4gICAgICAgIGlmIChmb3JtRGF0YS5yZWZlcmVuY2VJbWFnZVVybHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICghZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzIHx8IGZvcm1EYXRhLnBob3RvUmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIGRlc2NyaWJlIHdobydzIGluIHlvdXIgcGhvdG9zXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nRGVzY3JpcHRpb25zID0gZm9ybURhdGEucGhvdG9SZWZlcmVuY2VzLmZpbHRlcihyZWYgPT4gIXJlZi5kZXNjcmlwdGlvbiB8fCAhcmVmLmRlc2NyaXB0aW9uLnRyaW0oKSkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdEZXNjcmlwdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBQbGVhc2UgZGVzY3JpYmUgd2hvJ3MgaW4gJHttaXNzaW5nRGVzY3JpcHRpb25zfSBwaG90byR7bWlzc2luZ0Rlc2NyaXB0aW9ucyA+IDEgPyAncycgOiAnJ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaWYgKGZvcm1EYXRhLnNlbGVjdGVkQXJ0aXN0aWNTdHlsZSA9PT0gXCJjdXN0b21cIiAmJiAhZm9ybURhdGEuY3VzdG9tU3R5bGVEZXNjcmlwdGlvbi50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBkZXNjcmliZSB5b3VyIGN1c3RvbSBhcnRpc3RpYyBzdHlsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybURhdGEucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgZm9ybURhdGEuc2VsZWN0ZWRJbWFnZU1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcIlJlZmVyZW5jZSBwaG90b3MgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggR1BUIEltYWdlIDEgbW9kZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKCFmb3JtRGF0YS51c2VyRW1haWwudHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJFbWFpbCBhZGRyZXNzIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChmb3JtRGF0YS51c2VyRW1haWwpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH0sIFtmb3JtRGF0YV0pO1xuXG4gIHJldHVybiB7XG4gICAgZm9ybURhdGEsXG4gICAgdXBkYXRlRm9ybURhdGEsXG4gICAgcmVzZXRGb3JtLFxuICAgIGNsZWFyU3RvcmVkRGF0YSxcbiAgICB2YWxpZGF0ZVN0ZXAsXG4gICAgZ2V0U3RlcFN1bW1hcnksXG4gICAgZ2V0VmFsaWRhdGlvbkVycm9ycyxcbiAgICBpc0luaXRpYWxMb2FkQ29tcGxldGUsXG4gICAgd2l6YXJkU3RhdGU6IHtcbiAgICAgIC4uLndpemFyZFN0YXRlLFxuICAgICAgdXBkYXRlQ3VycmVudFN0ZXA6IChzdGVwOiBudW1iZXIpID0+IHVwZGF0ZVdpemFyZFN0YXRlKHsgY3VycmVudFN0ZXA6IHN0ZXAgfSksXG4gICAgICBtYXJrU3RlcENvbXBsZXRlZCxcbiAgICAgIHJlc2V0V2l6YXJkU3RhdGUsXG4gICAgfSxcbiAgICB1cGRhdGVXaXphcmRTdGF0ZSxcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJzdG9yYWdlIiwiZGVmYXVsdEZvcm1EYXRhIiwic2VsZWN0ZWRUeXBlIiwiY3VzdG9tQ2FyZFR5cGUiLCJzZWxlY3RlZFRvbmUiLCJ0b0ZpZWxkIiwiZnJvbUZpZWxkIiwicmVsYXRpb25zaGlwRmllbGQiLCJwcm9tcHQiLCJmaW5hbENhcmRNZXNzYWdlIiwiaXNIYW5kd3JpdHRlbk1lc3NhZ2UiLCJzZWxlY3RlZEFydGlzdGljU3R5bGUiLCJjdXN0b21TdHlsZURlc2NyaXB0aW9uIiwicmVmZXJlbmNlSW1hZ2VzIiwicmVmZXJlbmNlSW1hZ2VVcmxzIiwidXNlckVtYWlsIiwic2VsZWN0ZWRJbWFnZU1vZGVsIiwic2VsZWN0ZWREcmFmdE1vZGVsIiwic2VsZWN0ZWRQYXBlclNpemUiLCJudW1iZXJPZkNhcmRzIiwiaXNGcm9udEJhY2tPbmx5IiwiY3JlYXRlU2VyaWFsaXphYmxlRm9ybURhdGEiLCJmb3JtRGF0YSIsInNlcmlhbGl6YWJsZURhdGEiLCJ1c2VDYXJkRm9ybSIsInNldEZvcm1EYXRhIiwid2l6YXJkU3RhdGUiLCJzZXRXaXphcmRTdGF0ZSIsImN1cnJlbnRTdGVwIiwiY29tcGxldGVkU3RlcHMiLCJpc0luaXRpYWxMb2FkQ29tcGxldGUiLCJzZXRJc0luaXRpYWxMb2FkQ29tcGxldGUiLCJzZXNzaW9uIiwiZ2V0U2Vzc2lvbiIsInNhdmVTZXNzaW9uIiwidXBkYXRlRm9ybURhdGEiLCJ1cGRhdGVzIiwicHJldiIsInJlc2V0Rm9ybSIsImNsZWFyU2Vzc2lvbiIsImNsZWFyU3RvcmVkRGF0YSIsImNsZWFyQWxsIiwidXBkYXRlV2l6YXJkU3RhdGUiLCJtYXJrU3RlcENvbXBsZXRlZCIsInN0ZXAiLCJpbmNsdWRlcyIsInJlc2V0V2l6YXJkU3RhdGUiLCJ2YWxpZGF0ZVN0ZXAiLCJ0cmltIiwibGVuZ3RoIiwicGhvdG9SZWZlcmVuY2VzIiwiYWxsSGF2ZURlc2NyaXB0aW9ucyIsImV2ZXJ5IiwicmVmIiwiZGVzY3JpcHRpb24iLCJlbWFpbFJlZ2V4IiwidGVzdCIsImdldFN0ZXBTdW1tYXJ5Iiwic3VtbWFyeSIsImNhcmRUeXBlIiwicHVzaCIsInN1YnN0cmluZyIsImdldFZhbGlkYXRpb25FcnJvcnMiLCJlcnJvcnMiLCJtaXNzaW5nRGVzY3JpcHRpb25zIiwiZmlsdGVyIiwidXBkYXRlQ3VycmVudFN0ZXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCardForm.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/cardStudio/useCardGeneration.ts":
/*!***********************************************!*\
  !*** ./hooks/cardStudio/useCardGeneration.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCardGeneration: function() { return /* binding */ useCardGeneration; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/promptGenerator */ \"(app-pages-browser)/./lib/promptGenerator.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./hooks/cardStudio/constants.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./hooks/cardStudio/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ useCardGeneration auto */ \n\n\n\n\n\nfunction useCardGeneration(props) {\n    const [isGenerating, setIsGenerating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generatedCard, setGeneratedCard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generatedCards, setGeneratedCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedCardIndex, setSelectedCardIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isCardCompleted, setIsCardCompleted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [generationProgress, setGenerationProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [currentCardId, setCurrentCardId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [generationDuration, setGenerationDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Handle final card completion\n    const handleFinalCardCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cardData)=>{\n        console.log(\"\\uD83C\\uDFAF handleFinalCardCompletion called with cardData:\", cardData);\n        console.log(\"\\uD83C\\uDFAF Current userEmail state:\", props.userEmail);\n        console.log(\"\\uD83C\\uDFAF Current states:\", {\n            isGenerating,\n            isCardCompleted,\n            generatedCard: generatedCard ? \"Present\" : \"None\",\n            progressPercentage\n        });\n        let cardWithQR = {\n            ...cardData\n        };\n        // Ensure the card has a valid createdAt date\n        if (!cardWithQR.createdAt) {\n            cardWithQR.createdAt = new Date();\n        } else if (typeof cardWithQR.createdAt === \"string\" || typeof cardWithQR.createdAt === \"number\") {\n            cardWithQR.createdAt = new Date(cardWithQR.createdAt);\n        }\n        // Ensure the card has a valid ID\n        if (!cardWithQR.id) {\n            cardWithQR.id = \"card-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n        }\n        console.log(\"\\uD83D\\uDD04 Final card data prepared:\", cardWithQR);\n        // Note: QR code overlay is now handled automatically by the backend\n        console.log(\"✅ Card completion processing finished - QR codes handled by backend\");\n        console.log(\"\\uD83C\\uDFAF Setting final card state:\", cardWithQR);\n        // Set the card states\n        setGeneratedCard(cardWithQR);\n        setGeneratedCards([\n            cardWithQR\n        ]);\n        setSelectedCardIndex(0);\n        setIsCardCompleted(true);\n        setIsGenerating(false);\n        props.setIsGeneratingFinalCard(false);\n        props.setIsDraftMode(false);\n        props.setDraftCompletionShown(false);\n        props.setDraftCompletionCount(0);\n        console.log(\"\\uD83C\\uDFAF Card states updated - isCardCompleted:\", true, \"generatedCard:\", cardWithQR);\n        // Don't clear the progress message here - it will be set by the WebSocket handler\n        // setGenerationProgress(\"\");\n        clearProgressInterval(); // Clear time-based progress\n        setProgressPercentage(100); // Ensure 100% on completion\n        // Scroll to card preview\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.scrollToCardPreview)();\n        // Capture generation time from backend\n        if (cardData.generationTimeSeconds) {\n            setGenerationDuration(cardData.generationTimeSeconds);\n        }\n        // Stop elapsed time tracking\n        props.stopElapsedTimeTracking();\n        // Set final progress after all states are updated\n        // Use a timeout to ensure React has processed all state updates\n        setTimeout(()=>{\n            setProgressPercentage(100);\n            setGenerationProgress(\"Generation complete! (100%)\");\n        }, 100);\n        sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Your card is ready!\");\n        // Show email confirmation toast if email is provided\n        if (props.userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"✉️ Card sent to \".concat(props.userEmail), {\n                duration: 5000\n            });\n        }\n        // Email notifications are handled by the backend\n        console.log(\"\\uD83D\\uDCE7 Email sending disabled - backend handles email notifications\");\n        console.log(\"✅ Final card completion process finished successfully\");\n        console.log(\"✅ Final states:\", {\n            isCardCompleted: true,\n            generatedCard: cardWithQR,\n            progressPercentage: 100\n        });\n    }, [\n        props,\n        isGenerating,\n        isCardCompleted,\n        generatedCard,\n        progressPercentage\n    ]);\n    // Main card generation function\n    const handleGenerateCardAsync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const { userEmail, selectedType, customCardType, selectedTone, selectedArtisticStyle, customStyleDescription, selectedImageModel, referenceImageUrls, prompt, toField, fromField, finalCardMessage, isHandwrittenMessage, isFrontBackOnly, selectedPaperSize, numberOfCards, saveJobToStorage, subscribeToJob, startElapsedTimeTracking, setCurrentJobId, setIsDraftMode, setDraftCards, setSelectedDraftIndex, setIsGeneratingFinalCard, setPreviewingDraftIndex, setDraftCompletionShown, setDraftCompletionCount } = props;\n        if (!userEmail.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter your email address\");\n            return;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(userEmail)) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please enter a valid email address\");\n            return;\n        }\n        // Validate custom style if selected\n        if (selectedArtisticStyle === \"custom\" && !customStyleDescription.trim()) {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Please describe your custom artistic style\");\n            return;\n        }\n        // Validate reference images with model compatibility\n        if (referenceImageUrls.length > 0 && selectedImageModel !== \"gpt-image-1\") {\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Reference photos are only supported with GPT Image 1 model. Please switch to GPT Image 1 in Advanced Options or remove reference photos.\");\n            return;\n        }\n        // Clear all draft mode states to prevent UI conflicts\n        setIsDraftMode(false);\n        setDraftCards([\n            null,\n            null,\n            null,\n            null,\n            null\n        ]);\n        setSelectedDraftIndex(-1);\n        setIsGeneratingFinalCard(false);\n        setPreviewingDraftIndex(-1);\n        setDraftCompletionShown(false);\n        setDraftCompletionCount(0);\n        // Clear any existing card states\n        setGeneratedCards([]);\n        setGeneratedCard(null);\n        setSelectedCardIndex(0);\n        setCurrentCardId(null);\n        setIsCardCompleted(false);\n        // Stop any existing timers first\n        props.stopElapsedTimeTracking();\n        // Clear any existing progress interval\n        clearProgressInterval();\n        setIsGenerating(true);\n        startElapsedTimeTracking();\n        setGenerationProgress(\"Creating your personalized card...\");\n        setProgressPercentage(0);\n        // Simple time-based progress - increases by ~1.1% per second (90 seconds to reach 100%)\n        const interval = setInterval(()=>{\n            setProgressPercentage((prev)=>{\n                const newProgress = prev + 1.1;\n                return newProgress >= 95 ? 95 : newProgress; // Cap at 95% until completion\n            });\n        }, 1000); // Update every second\n        setProgressInterval(interval);\n        try {\n            // Create job tracking\n            const jobId = (0,uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n            setCurrentJobId(jobId);\n            const cardTypeForPrompt = selectedType === \"custom\" ? customCardType : selectedType;\n            const selectedToneObj = _constants__WEBPACK_IMPORTED_MODULE_3__.cardTones.find((tone)=>tone.id === selectedTone);\n            let messageContent = finalCardMessage;\n            // Handle message generation if needed\n            if (isHandwrittenMessage) {\n                messageContent = \"[Blank space for handwritten message]\";\n            } else if (!messageContent.trim() && !isFrontBackOnly) {\n                setGenerationProgress(\"✍️ Writing the perfect message...\");\n                const autoMessagePrompt = \"Create a heartfelt message for a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nCard Theme/Description: \"').concat(prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"), '\"\\n').concat(toField ? \"Recipient: \".concat(toField) : \"Recipient: [not specified]\", \"\\n\").concat(fromField ? \"Sender: \".concat(fromField) : \"Sender: [not specified]\", \"\\n\\nInstructions:\\n- Write a message that feels personal and genuine\\n- Keep it concise but meaningful (2-4 sentences ideal)\\n- Make it feel authentic, not generic\\n- Keep content family-friendly and appropriate for all ages\\n- \").concat(fromField ? 'End the message with a signature line like \"Love, '.concat(fromField, '\" or \"- ').concat(fromField, '\" or similar, naturally integrated into the message.') : \"\", \"\\n\\nReturn ONLY the message text that should appear inside the card.\\n\\nIMPORTANT: Wrap your final message in <MESSAGE> </MESSAGE> tags.\");\n                const generatedMessage = await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.chatWithAI)(autoMessagePrompt, {\n                    model: \"gemini-2.5-pro\",\n                    includeThoughts: false\n                });\n                if (generatedMessage === null || generatedMessage === void 0 ? void 0 : generatedMessage.trim()) {\n                    const messageMatch = generatedMessage.match(/<MESSAGE>([\\s\\S]*?)<\\/MESSAGE>/);\n                    if (messageMatch && messageMatch[1]) {\n                        messageContent = messageMatch[1].trim();\n                    }\n                }\n            }\n            // Generate style and paper config\n            const selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_3__.artisticStyles.find((style)=>style.id === selectedArtisticStyle);\n            const styleModifier = selectedArtisticStyle === \"custom\" ? customStyleDescription : (selectedStyle === null || selectedStyle === void 0 ? void 0 : selectedStyle.promptModifier) || \"\";\n            const paperConfig = _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes.find((size)=>size.id === selectedPaperSize) || _constants__WEBPACK_IMPORTED_MODULE_3__.paperSizes[0];\n            setGenerationProgress(\"\\uD83C\\uDFA8 Creating artistic vision for your card...\");\n            // Use PromptGenerator for card prompts\n            const cardConfig = {\n                cardType: selectedType,\n                customCardType: customCardType,\n                tone: selectedTone,\n                toneDescription: (selectedToneObj === null || selectedToneObj === void 0 ? void 0 : selectedToneObj.description.toLowerCase()) || \"heartfelt and sincere\",\n                theme: prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"),\n                toField: toField,\n                fromField: fromField,\n                message: messageContent,\n                isHandwrittenMessage: isHandwrittenMessage,\n                artisticStyle: selectedStyle,\n                referenceImageUrls: referenceImageUrls,\n                photoAnalyses: props.photoAnalyses,\n                isFrontBackOnly: isFrontBackOnly,\n                selectedImageModel: selectedImageModel\n            };\n            const generatedPrompts = _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.generateCardPrompts(cardConfig);\n            // Apply reference photo enhancements for GPT-1\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-1\") {\n                generatedPrompts.frontCover = _lib_promptGenerator__WEBPACK_IMPORTED_MODULE_2__.PromptGenerator.enhancePromptWithReferencePhotos(generatedPrompts.frontCover, true, selectedImageModel);\n            }\n            const formattedPrompts = {\n                frontCover: generatedPrompts.frontCover,\n                backCover: generatedPrompts.backCover,\n                ...isFrontBackOnly ? {} : {\n                    leftInterior: generatedPrompts.leftInterior,\n                    rightInterior: generatedPrompts.rightInterior\n                }\n            };\n            if (!formattedPrompts || !formattedPrompts.frontCover) {\n                throw new Error(\"Failed to generate image prompts\");\n            }\n            // Save job data\n            const jobData = {\n                prompt: prompt || \"A beautiful \".concat(cardTypeForPrompt, \" card\"),\n                selectedType,\n                customCardType,\n                selectedTone,\n                finalCardMessage: messageContent,\n                toField,\n                fromField,\n                userEmail,\n                selectedArtisticStyle,\n                customStyleDescription,\n                selectedImageModel,\n                isFrontBackOnly,\n                numberOfCards,\n                selectedPaperSize,\n                prompts: formattedPrompts,\n                paperConfig\n            };\n            saveJobToStorage(jobId, jobData);\n            setGenerationProgress(\"\\uD83D\\uDE80 Starting background generation...\");\n            // Prepare input images for reference photo support\n            const inputImages = [];\n            if (referenceImageUrls.length > 0 && selectedImageModel === \"gpt-image-1\") {\n                inputImages.push(...referenceImageUrls);\n            }\n            const response = await fetch(\"/api/generate-card-async\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobId,\n                    prompts: formattedPrompts,\n                    config: {\n                        userNumber: \"+17145986105\",\n                        modelVersion: selectedImageModel,\n                        aspectRatio: paperConfig.aspectRatio,\n                        quality: \"high\",\n                        outputFormat: \"jpeg\",\n                        outputCompression: 100,\n                        moderation: \"low\",\n                        dimensions: paperConfig.dimensions,\n                        isFrontBackOnly,\n                        userEmail,\n                        cardType: cardTypeForPrompt,\n                        toField,\n                        fromField,\n                        isDraftMode: false,\n                        ...inputImages.length > 0 && {\n                            input_images: inputImages,\n                            input_images_mode: \"front_cover_only\"\n                        }\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.status !== \"processing\") {\n                throw new Error(result.message || \"Failed to start card generation\");\n            }\n            setGenerationProgress(\"✨ Bringing your vision to life...\");\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"\\uD83C\\uDF89 Card generation started!\");\n            // Subscribe to WebSocket updates for real-time progress\n            subscribeToJob(jobId);\n        } catch (error) {\n            console.error(\"Card generation error:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Failed to generate card. Please try again.\");\n            if (currentCardId) {\n                props.removeJobFromStorage(currentCardId);\n                setCurrentCardId(null);\n            }\n            setIsGenerating(false);\n            setGenerationProgress(\"\");\n            setProgressPercentage(0);\n            props.stopElapsedTimeTracking();\n            clearProgressInterval(); // Clear time-based progress on error\n        }\n    }, [\n        props,\n        currentCardId,\n        clearProgressInterval\n    ]);\n    return {\n        isGenerating,\n        setIsGenerating,\n        generatedCard,\n        setGeneratedCard,\n        generatedCards,\n        setGeneratedCards,\n        selectedCardIndex,\n        setSelectedCardIndex,\n        isCardCompleted,\n        setIsCardCompleted,\n        generationProgress,\n        setGenerationProgress,\n        progressPercentage,\n        setProgressPercentage,\n        currentCardId,\n        setCurrentCardId,\n        generationDuration,\n        setGenerationDuration,\n        handleGenerateCardAsync,\n        handleFinalCardCompletion,\n        clearProgressInterval\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL2NhcmRTdHVkaW8vdXNlQ2FyZEdlbmVyYXRpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7dUVBRThDO0FBQ2Y7QUFDSztBQUNnQztBQUM4QjtBQUNyQjtBQXdDdEUsU0FBU1csa0JBQWtCQyxLQUEwQjtJQUMxRCxNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHZCwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNlLGVBQWVDLGlCQUFpQixHQUFHaEIsK0NBQVFBLENBQXVCO0lBQ3pFLE1BQU0sQ0FBQ2lCLGdCQUFnQkMsa0JBQWtCLEdBQUdsQiwrQ0FBUUEsQ0FBa0IsRUFBRTtJQUN4RSxNQUFNLENBQUNtQixtQkFBbUJDLHFCQUFxQixHQUFHcEIsK0NBQVFBLENBQVM7SUFDbkUsTUFBTSxDQUFDcUIsaUJBQWlCQyxtQkFBbUIsR0FBR3RCLCtDQUFRQSxDQUFVO0lBQ2hFLE1BQU0sQ0FBQ3VCLG9CQUFvQkMsc0JBQXNCLEdBQUd4QiwrQ0FBUUEsQ0FBUztJQUNyRSxNQUFNLENBQUN5QixlQUFlQyxpQkFBaUIsR0FBRzFCLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUMyQixvQkFBb0JDLHNCQUFzQixHQUFHNUIsK0NBQVFBLENBQWdCO0lBRTVFLCtCQUErQjtJQUMvQixNQUFNNkIsNEJBQTRCNUIsa0RBQVdBLENBQUMsT0FBTzZCO1FBQ25EQyxRQUFRQyxHQUFHLENBQUMsZ0VBQXNERjtRQUNsRUMsUUFBUUMsR0FBRyxDQUFDLHlDQUErQnBCLE1BQU1xQixTQUFTO1FBQzFERixRQUFRQyxHQUFHLENBQUMsZ0NBQXNCO1lBQ2hDbkI7WUFDQVE7WUFDQU4sZUFBZUEsZ0JBQWdCLFlBQVk7WUFDM0NtQjtRQUNGO1FBQ0EsSUFBSUMsYUFBYTtZQUFFLEdBQUdMLFFBQVE7UUFBQztRQUUvQiw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDSyxXQUFXQyxTQUFTLEVBQUU7WUFDekJELFdBQVdDLFNBQVMsR0FBRyxJQUFJQztRQUM3QixPQUFPLElBQUksT0FBT0YsV0FBV0MsU0FBUyxLQUFLLFlBQVksT0FBT0QsV0FBV0MsU0FBUyxLQUFLLFVBQVU7WUFDL0ZELFdBQVdDLFNBQVMsR0FBRyxJQUFJQyxLQUFLRixXQUFXQyxTQUFTO1FBQ3REO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQ0QsV0FBV0csRUFBRSxFQUFFO1lBQ2xCSCxXQUFXRyxFQUFFLEdBQUcsUUFBc0JDLE9BQWRGLEtBQUtHLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0QsS0FBS0UsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7UUFDN0U7UUFFQVosUUFBUUMsR0FBRyxDQUFDLDBDQUFnQ0c7UUFFNUMsb0VBQW9FO1FBQ3BFSixRQUFRQyxHQUFHLENBQUM7UUFFWkQsUUFBUUMsR0FBRyxDQUFDLDBDQUFnQ0c7UUFFNUMsc0JBQXNCO1FBQ3RCbkIsaUJBQWlCbUI7UUFDakJqQixrQkFBa0I7WUFBQ2lCO1NBQVc7UUFDOUJmLHFCQUFxQjtRQUNyQkUsbUJBQW1CO1FBQ25CUixnQkFBZ0I7UUFDaEJGLE1BQU1nQyx3QkFBd0IsQ0FBQztRQUMvQmhDLE1BQU1pQyxjQUFjLENBQUM7UUFDckJqQyxNQUFNa0MsdUJBQXVCLENBQUM7UUFDOUJsQyxNQUFNbUMsdUJBQXVCLENBQUM7UUFFOUJoQixRQUFRQyxHQUFHLENBQUMsdURBQTZDLE1BQU0sa0JBQWtCRztRQUNqRixrRkFBa0Y7UUFDbEYsNkJBQTZCO1FBQzdCYSx5QkFBeUIsNEJBQTRCO1FBQ3JEQyxzQkFBc0IsTUFBTSw0QkFBNEI7UUFFeEQseUJBQXlCO1FBQ3pCdkMsMkRBQW1CQTtRQUVuQix1Q0FBdUM7UUFDdkMsSUFBSW9CLFNBQVNvQixxQkFBcUIsRUFBRTtZQUNsQ3RCLHNCQUFzQkUsU0FBU29CLHFCQUFxQjtRQUN0RDtRQUVBLDZCQUE2QjtRQUM3QnRDLE1BQU11Qyx1QkFBdUI7UUFFN0Isa0RBQWtEO1FBQ2xELGdFQUFnRTtRQUNoRUMsV0FBVztZQUNUSCxzQkFBc0I7WUFDdEJ6QixzQkFBc0I7UUFDeEIsR0FBRztRQUVIdEIseUNBQUtBLENBQUNtRCxPQUFPLENBQUM7UUFFZCxxREFBcUQ7UUFDckQsSUFBSXpDLE1BQU1xQixTQUFTLENBQUNxQixJQUFJLElBQUk7WUFDMUJwRCx5Q0FBS0EsQ0FBQ21ELE9BQU8sQ0FBQyxtQkFBbUMsT0FBaEJ6QyxNQUFNcUIsU0FBUyxHQUFJO2dCQUNsRHNCLFVBQVU7WUFDWjtRQUNGO1FBRUEsaURBQWlEO1FBQ2pEeEIsUUFBUUMsR0FBRyxDQUFDO1FBRVpELFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsbUJBQW1CO1lBQzdCWCxpQkFBaUI7WUFDakJOLGVBQWVvQjtZQUNmRCxvQkFBb0I7UUFDdEI7SUFDRixHQUFHO1FBQUN0QjtRQUFPQztRQUFjUTtRQUFpQk47UUFBZW1CO0tBQW1CO0lBRTVFLGdDQUFnQztJQUNoQyxNQUFNc0IsMEJBQTBCdkQsa0RBQVdBLENBQUM7UUFDMUMsTUFBTSxFQUNKZ0MsU0FBUyxFQUNUd0IsWUFBWSxFQUNaQyxjQUFjLEVBQ2RDLFlBQVksRUFDWkMscUJBQXFCLEVBQ3JCQyxzQkFBc0IsRUFDdEJDLGtCQUFrQixFQUNsQkMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsU0FBUyxFQUNUQyxnQkFBZ0IsRUFDaEJDLG9CQUFvQixFQUNwQkMsZUFBZSxFQUNmQyxpQkFBaUIsRUFDakJDLGFBQWEsRUFDYkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLHdCQUF3QixFQUN4QkMsZUFBZSxFQUNmOUIsY0FBYyxFQUNkK0IsYUFBYSxFQUNiQyxxQkFBcUIsRUFDckJqQyx3QkFBd0IsRUFDeEJrQyx1QkFBdUIsRUFDdkJoQyx1QkFBdUIsRUFDdkJDLHVCQUF1QixFQUN4QixHQUFHbkM7UUFFSixJQUFJLENBQUNxQixVQUFVcUIsSUFBSSxJQUFJO1lBQ3JCcEQseUNBQUtBLENBQUM2RSxLQUFLLENBQUM7WUFDWjtRQUNGO1FBRUEseUJBQXlCO1FBQ3pCLE1BQU1DLGFBQWE7UUFDbkIsSUFBSSxDQUFDQSxXQUFXQyxJQUFJLENBQUNoRCxZQUFZO1lBQy9CL0IseUNBQUtBLENBQUM2RSxLQUFLLENBQUM7WUFDWjtRQUNGO1FBRUEsb0NBQW9DO1FBQ3BDLElBQUluQiwwQkFBMEIsWUFBWSxDQUFDQyx1QkFBdUJQLElBQUksSUFBSTtZQUN4RXBELHlDQUFLQSxDQUFDNkUsS0FBSyxDQUFDO1lBQ1o7UUFDRjtRQUVBLHFEQUFxRDtRQUNyRCxJQUFJaEIsbUJBQW1CbUIsTUFBTSxHQUFHLEtBQUtwQix1QkFBdUIsZUFBZTtZQUN6RTVELHlDQUFLQSxDQUFDNkUsS0FBSyxDQUFDO1lBQ1o7UUFDRjtRQUVBLHNEQUFzRDtRQUN0RGxDLGVBQWU7UUFDZitCLGNBQWM7WUFBQztZQUFNO1lBQU07WUFBTTtZQUFNO1NBQUs7UUFDNUNDLHNCQUFzQixDQUFDO1FBQ3ZCakMseUJBQXlCO1FBQ3pCa0Msd0JBQXdCLENBQUM7UUFDekJoQyx3QkFBd0I7UUFDeEJDLHdCQUF3QjtRQUV4QixpQ0FBaUM7UUFDakM3QixrQkFBa0IsRUFBRTtRQUNwQkYsaUJBQWlCO1FBQ2pCSSxxQkFBcUI7UUFDckJNLGlCQUFpQjtRQUNqQkosbUJBQW1CO1FBRW5CLGlDQUFpQztRQUNqQ1YsTUFBTXVDLHVCQUF1QjtRQUU3Qix1Q0FBdUM7UUFDdkNIO1FBRUFsQyxnQkFBZ0I7UUFDaEI0RDtRQUNBbEQsc0JBQXNCO1FBQ3RCeUIsc0JBQXNCO1FBRXRCLHdGQUF3RjtRQUN4RixNQUFNa0MsV0FBV0MsWUFBWTtZQUMzQm5DLHNCQUFzQm9DLENBQUFBO2dCQUNwQixNQUFNQyxjQUFjRCxPQUFPO2dCQUMzQixPQUFPQyxlQUFlLEtBQUssS0FBS0EsYUFBYSw4QkFBOEI7WUFDN0U7UUFDRixHQUFHLE9BQU8sc0JBQXNCO1FBRWhDQyxvQkFBb0JKO1FBRXBCLElBQUk7WUFDRixzQkFBc0I7WUFDdEIsTUFBTUssUUFBUXBGLGdEQUFNQTtZQUNwQnVFLGdCQUFnQmE7WUFFaEIsTUFBTUMsb0JBQW9CaEMsaUJBQWlCLFdBQVdDLGlCQUFpQkQ7WUFDdkUsTUFBTWlDLGtCQUFrQnBGLGlEQUFTQSxDQUFDcUYsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLdEQsRUFBRSxLQUFLcUI7WUFDM0QsSUFBSWtDLGlCQUFpQjFCO1lBRXJCLHNDQUFzQztZQUN0QyxJQUFJQyxzQkFBc0I7Z0JBQ3hCeUIsaUJBQWlCO1lBQ25CLE9BQU8sSUFBSSxDQUFDQSxlQUFldkMsSUFBSSxNQUFNLENBQUNlLGlCQUFpQjtnQkFDckQ3QyxzQkFBc0I7Z0JBRXRCLE1BQU1zRSxvQkFBb0Isb0NBRVA5QixPQUYyQ3lCLG1CQUFrQixnREFHdEZ4QixPQUR5QkQsVUFBVSxlQUFpQyxPQUFsQnlCLG1CQUFrQixVQUFPLE9BRTNFdkIsT0FEQUQsVUFBVSxjQUFzQixPQUFSQSxXQUFZLDhCQUE2QixNQVEvREMsT0FQRkEsWUFBWSxXQUFxQixPQUFWQSxhQUFjLDJCQUEwQix3T0FPNkYsT0FBMUpBLFlBQVkscURBQXlFQSxPQUFwQkEsV0FBVSxZQUFvQixPQUFWQSxXQUFVLDBEQUF3RCxJQUFHO2dCQU10SixNQUFNNkIsbUJBQW1CLE1BQU10RixrREFBVUEsQ0FBQ3FGLG1CQUFtQjtvQkFDM0RFLE9BQU87b0JBQ1BDLGlCQUFpQjtnQkFDbkI7Z0JBRUEsSUFBSUYsNkJBQUFBLHVDQUFBQSxpQkFBa0J6QyxJQUFJLElBQUk7b0JBQzVCLE1BQU00QyxlQUFlSCxpQkFBaUJJLEtBQUssQ0FBQztvQkFDNUMsSUFBSUQsZ0JBQWdCQSxZQUFZLENBQUMsRUFBRSxFQUFFO3dCQUNuQ0wsaUJBQWlCSyxZQUFZLENBQUMsRUFBRSxDQUFDNUMsSUFBSTtvQkFDdkM7Z0JBQ0Y7WUFDRjtZQUVBLGtDQUFrQztZQUNsQyxNQUFNOEMsZ0JBQWdCN0Ysc0RBQWNBLENBQUNvRixJQUFJLENBQUNVLENBQUFBLFFBQVNBLE1BQU0vRCxFQUFFLEtBQUtzQjtZQUNoRSxNQUFNMEMsZ0JBQWdCMUMsMEJBQTBCLFdBQzVDQyx5QkFDQXVDLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZUcsY0FBYyxLQUFJO1lBRXJDLE1BQU1DLGNBQWNoRyxrREFBVUEsQ0FBQ21GLElBQUksQ0FBQ2MsQ0FBQUEsT0FBUUEsS0FBS25FLEVBQUUsS0FBS2dDLHNCQUFzQjlELGtEQUFVLENBQUMsRUFBRTtZQUUzRmdCLHNCQUFzQjtZQUV0Qix1Q0FBdUM7WUFDdkMsTUFBTWtGLGFBQXlCO2dCQUM3QkMsVUFBVWxEO2dCQUNWQyxnQkFBZ0JBO2dCQUNoQmtDLE1BQU1qQztnQkFDTmlELGlCQUFpQmxCLENBQUFBLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCbUIsV0FBVyxDQUFDQyxXQUFXLE9BQU07Z0JBQy9EQyxPQUFPL0MsVUFBVSxlQUFpQyxPQUFsQnlCLG1CQUFrQjtnQkFDbER4QixTQUFTQTtnQkFDVEMsV0FBV0E7Z0JBQ1g4QyxTQUFTbkI7Z0JBQ1R6QixzQkFBc0JBO2dCQUN0QjZDLGVBQWViO2dCQUNmckMsb0JBQW9CQTtnQkFDcEJtRCxlQUFldEcsTUFBTXNHLGFBQWE7Z0JBQ2xDN0MsaUJBQWlCQTtnQkFDakJQLG9CQUFvQkE7WUFDdEI7WUFFQSxNQUFNcUQsbUJBQW1COUcsaUVBQWVBLENBQUMrRyxtQkFBbUIsQ0FBQ1Y7WUFFN0QsK0NBQStDO1lBQy9DLElBQUkzQyxtQkFBbUJtQixNQUFNLEdBQUcsS0FBS3BCLHVCQUF1QixTQUFTO2dCQUNuRXFELGlCQUFpQkUsVUFBVSxHQUFHaEgsaUVBQWVBLENBQUNpSCxnQ0FBZ0MsQ0FDNUVILGlCQUFpQkUsVUFBVSxFQUMzQixNQUNBdkQ7WUFFSjtZQUVBLE1BQU15RCxtQkFBbUI7Z0JBQ3ZCRixZQUFZRixpQkFBaUJFLFVBQVU7Z0JBQ3ZDRyxXQUFXTCxpQkFBaUJLLFNBQVM7Z0JBQ3JDLEdBQUluRCxrQkFBa0IsQ0FBQyxJQUFJO29CQUN6Qm9ELGNBQWNOLGlCQUFpQk0sWUFBWTtvQkFDM0NDLGVBQWVQLGlCQUFpQk8sYUFBYTtnQkFDL0MsQ0FBQztZQUNIO1lBRUEsSUFBSSxDQUFDSCxvQkFBb0IsQ0FBQ0EsaUJBQWlCRixVQUFVLEVBQUU7Z0JBQ3JELE1BQU0sSUFBSU0sTUFBTTtZQUNsQjtZQUVBLGdCQUFnQjtZQUNoQixNQUFNQyxVQUFVO2dCQUNkNUQsUUFBUUEsVUFBVSxlQUFpQyxPQUFsQnlCLG1CQUFrQjtnQkFDbkRoQztnQkFDQUM7Z0JBQ0FDO2dCQUNBUSxrQkFBa0IwQjtnQkFDbEI1QjtnQkFDQUM7Z0JBQ0FqQztnQkFDQTJCO2dCQUNBQztnQkFDQUM7Z0JBQ0FPO2dCQUNBRTtnQkFDQUQ7Z0JBQ0F1RCxTQUFTTjtnQkFDVGY7WUFDRjtZQUVBaEMsaUJBQWlCZ0IsT0FBT29DO1lBRXhCcEcsc0JBQXNCO1lBRXRCLG1EQUFtRDtZQUNuRCxNQUFNc0csY0FBd0IsRUFBRTtZQUNoQyxJQUFJL0QsbUJBQW1CbUIsTUFBTSxHQUFHLEtBQUtwQix1QkFBdUIsZUFBZTtnQkFDekVnRSxZQUFZQyxJQUFJLElBQUloRTtZQUN0QjtZQUVBLE1BQU1pRSxXQUFXLE1BQU1DLE1BQU0sNEJBQTRCO2dCQUN2REMsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQjlDO29CQUNBcUMsU0FBU047b0JBQ1RnQixRQUFRO3dCQUNOQyxZQUFZO3dCQUNaQyxjQUFjM0U7d0JBQ2Q0RSxhQUFhbEMsWUFBWWtDLFdBQVc7d0JBQ3BDQyxTQUFTO3dCQUNUQyxjQUFjO3dCQUNkQyxtQkFBbUI7d0JBQ25CQyxZQUFZO3dCQUNaQyxZQUFZdkMsWUFBWXVDLFVBQVU7d0JBQ2xDMUU7d0JBQ0FwQzt3QkFDQTBFLFVBQVVsQjt3QkFDVnhCO3dCQUNBQzt3QkFDQThFLGFBQWE7d0JBQ2IsR0FBSWxCLFlBQVk1QyxNQUFNLEdBQUcsS0FBSzs0QkFDNUIrRCxjQUFjbkI7NEJBQ2RvQixtQkFBbUI7d0JBQ3JCLENBQUM7b0JBQ0g7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ2xCLFNBQVNtQixFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSXhCLE1BQU0saUJBQWlDLE9BQWhCSyxTQUFTb0IsTUFBTTtZQUNsRDtZQUVBLE1BQU1DLFNBQVMsTUFBTXJCLFNBQVNzQixJQUFJO1lBRWxDLElBQUlELE9BQU9ELE1BQU0sS0FBSyxjQUFjO2dCQUNsQyxNQUFNLElBQUl6QixNQUFNMEIsT0FBT3JDLE9BQU8sSUFBSTtZQUNwQztZQUVBeEYsc0JBQXNCO1lBQ3RCdEIseUNBQUtBLENBQUNtRCxPQUFPLENBQUM7WUFFZCx3REFBd0Q7WUFDeERvQixlQUFlZTtRQUVqQixFQUFFLE9BQU9ULE9BQU87WUFDZGhELFFBQVFnRCxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QzdFLHlDQUFLQSxDQUFDNkUsS0FBSyxDQUFDO1lBRVosSUFBSXRELGVBQWU7Z0JBQ2pCYixNQUFNMkksb0JBQW9CLENBQUM5SDtnQkFDM0JDLGlCQUFpQjtZQUNuQjtZQUVBWixnQkFBZ0I7WUFDaEJVLHNCQUFzQjtZQUN0QnlCLHNCQUFzQjtZQUN0QnJDLE1BQU11Qyx1QkFBdUI7WUFDN0JILHlCQUF5QixxQ0FBcUM7UUFDaEU7SUFDRixHQUFHO1FBQUNwQztRQUFPYTtRQUFldUI7S0FBc0I7SUFFaEQsT0FBTztRQUNMbkM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQVU7UUFDQWU7UUFDQXhCO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0E0QjtRQUNBM0I7UUFDQW1CO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy9jYXJkU3R1ZGlvL3VzZUNhcmRHZW5lcmF0aW9uLnRzPzA1YWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tIFwic29ubmVyXCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IFByb21wdEdlbmVyYXRvciwgQ2FyZENvbmZpZyB9IGZyb20gJ0AvbGliL3Byb21wdEdlbmVyYXRvcic7XG5pbXBvcnQgeyBHZW5lcmF0ZWRDYXJkLCBjYXJkVG9uZXMsIGFydGlzdGljU3R5bGVzLCBwYXBlclNpemVzLCBQaG90b0FuYWx5c2lzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY2hhdFdpdGhBSSwgc2VuZFRoYW5rWW91RW1haWwsIHNjcm9sbFRvQ2FyZFByZXZpZXcgfSBmcm9tICcuL3V0aWxzJztcblxuaW50ZXJmYWNlIENhcmRHZW5lcmF0aW9uUHJvcHMge1xuICAvLyBGb3JtIGRhdGFcbiAgc2VsZWN0ZWRUeXBlOiBzdHJpbmc7XG4gIGN1c3RvbUNhcmRUeXBlOiBzdHJpbmc7XG4gIHNlbGVjdGVkVG9uZTogc3RyaW5nO1xuICBzZWxlY3RlZEFydGlzdGljU3R5bGU6IHN0cmluZztcbiAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbjogc3RyaW5nO1xuICBzZWxlY3RlZEltYWdlTW9kZWw6IHN0cmluZztcbiAgc2VsZWN0ZWRQYXBlclNpemU6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIHRvRmllbGQ6IHN0cmluZztcbiAgZnJvbUZpZWxkOiBzdHJpbmc7XG4gIHVzZXJFbWFpbDogc3RyaW5nO1xuICBmaW5hbENhcmRNZXNzYWdlOiBzdHJpbmc7XG4gIGlzSGFuZHdyaXR0ZW5NZXNzYWdlOiBib29sZWFuO1xuICBpc0Zyb250QmFja09ubHk6IGJvb2xlYW47XG4gIHJlZmVyZW5jZUltYWdlVXJsczogc3RyaW5nW107XG4gIHBob3RvQW5hbHlzZXM/OiBQaG90b0FuYWx5c2lzW107XG4gIG51bWJlck9mQ2FyZHM6IG51bWJlcjtcbiAgXG4gIC8vIEpvYiBtYW5hZ2VtZW50XG4gIHNhdmVKb2JUb1N0b3JhZ2U6IChqb2JJZDogc3RyaW5nLCBqb2JEYXRhOiBhbnkpID0+IHZvaWQ7XG4gIHJlbW92ZUpvYkZyb21TdG9yYWdlOiAoam9iSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc3Vic2NyaWJlVG9Kb2I6IChqb2JJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmc6ICgpID0+IHZvaWQ7XG4gIHN0b3BFbGFwc2VkVGltZVRyYWNraW5nOiAoKSA9PiB2b2lkO1xuICBzZXRDdXJyZW50Sm9iSWQ6IChpZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgXG4gIC8vIERyYWZ0IHN0YXRlIHNldHRlcnNcbiAgc2V0SXNEcmFmdE1vZGU6ICh2YWx1ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RHJhZnRDYXJkczogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkRHJhZnRJbmRleDogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZDogKHZhbHVlOiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleDogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldERyYWZ0Q29tcGxldGlvblNob3duOiAodmFsdWU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldERyYWZ0Q29tcGxldGlvbkNvdW50OiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhcmRHZW5lcmF0aW9uKHByb3BzOiBDYXJkR2VuZXJhdGlvblByb3BzKSB7XG4gIGNvbnN0IFtpc0dlbmVyYXRpbmcsIHNldElzR2VuZXJhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtnZW5lcmF0ZWRDYXJkLCBzZXRHZW5lcmF0ZWRDYXJkXSA9IHVzZVN0YXRlPEdlbmVyYXRlZENhcmQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2dlbmVyYXRlZENhcmRzLCBzZXRHZW5lcmF0ZWRDYXJkc10gPSB1c2VTdGF0ZTxHZW5lcmF0ZWRDYXJkW10+KFtdKTtcbiAgY29uc3QgW3NlbGVjdGVkQ2FyZEluZGV4LCBzZXRTZWxlY3RlZENhcmRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbaXNDYXJkQ29tcGxldGVkLCBzZXRJc0NhcmRDb21wbGV0ZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbZ2VuZXJhdGlvblByb2dyZXNzLCBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3NdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW2N1cnJlbnRDYXJkSWQsIHNldEN1cnJlbnRDYXJkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtnZW5lcmF0aW9uRHVyYXRpb24sIHNldEdlbmVyYXRpb25EdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAvLyBIYW5kbGUgZmluYWwgY2FyZCBjb21wbGV0aW9uXG4gIGNvbnN0IGhhbmRsZUZpbmFsQ2FyZENvbXBsZXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoY2FyZERhdGE6IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn46vIGhhbmRsZUZpbmFsQ2FyZENvbXBsZXRpb24gY2FsbGVkIHdpdGggY2FyZERhdGE6JywgY2FyZERhdGEpO1xuICAgIGNvbnNvbGUubG9nKCfwn46vIEN1cnJlbnQgdXNlckVtYWlsIHN0YXRlOicsIHByb3BzLnVzZXJFbWFpbCk7XG4gICAgY29uc29sZS5sb2coJ/Cfjq8gQ3VycmVudCBzdGF0ZXM6Jywge1xuICAgICAgaXNHZW5lcmF0aW5nLFxuICAgICAgaXNDYXJkQ29tcGxldGVkLFxuICAgICAgZ2VuZXJhdGVkQ2FyZDogZ2VuZXJhdGVkQ2FyZCA/ICdQcmVzZW50JyA6ICdOb25lJyxcbiAgICAgIHByb2dyZXNzUGVyY2VudGFnZVxuICAgIH0pO1xuICAgIGxldCBjYXJkV2l0aFFSID0geyAuLi5jYXJkRGF0YSB9O1xuICAgIFxuICAgIC8vIEVuc3VyZSB0aGUgY2FyZCBoYXMgYSB2YWxpZCBjcmVhdGVkQXQgZGF0ZVxuICAgIGlmICghY2FyZFdpdGhRUi5jcmVhdGVkQXQpIHtcbiAgICAgIGNhcmRXaXRoUVIuY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYXJkV2l0aFFSLmNyZWF0ZWRBdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNhcmRXaXRoUVIuY3JlYXRlZEF0ID09PSAnbnVtYmVyJykge1xuICAgICAgY2FyZFdpdGhRUi5jcmVhdGVkQXQgPSBuZXcgRGF0ZShjYXJkV2l0aFFSLmNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSB0aGUgY2FyZCBoYXMgYSB2YWxpZCBJRFxuICAgIGlmICghY2FyZFdpdGhRUi5pZCkge1xuICAgICAgY2FyZFdpdGhRUi5pZCA9IGBjYXJkLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflIQgRmluYWwgY2FyZCBkYXRhIHByZXBhcmVkOicsIGNhcmRXaXRoUVIpO1xuICAgIFxuICAgIC8vIE5vdGU6IFFSIGNvZGUgb3ZlcmxheSBpcyBub3cgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBiYWNrZW5kXG4gICAgY29uc29sZS5sb2coJ+KchSBDYXJkIGNvbXBsZXRpb24gcHJvY2Vzc2luZyBmaW5pc2hlZCAtIFFSIGNvZGVzIGhhbmRsZWQgYnkgYmFja2VuZCcpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46vIFNldHRpbmcgZmluYWwgY2FyZCBzdGF0ZTonLCBjYXJkV2l0aFFSKTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGNhcmQgc3RhdGVzXG4gICAgc2V0R2VuZXJhdGVkQ2FyZChjYXJkV2l0aFFSKTtcbiAgICBzZXRHZW5lcmF0ZWRDYXJkcyhbY2FyZFdpdGhRUl0pO1xuICAgIHNldFNlbGVjdGVkQ2FyZEluZGV4KDApO1xuICAgIHNldElzQ2FyZENvbXBsZXRlZCh0cnVlKTtcbiAgICBzZXRJc0dlbmVyYXRpbmcoZmFsc2UpO1xuICAgIHByb3BzLnNldElzR2VuZXJhdGluZ0ZpbmFsQ2FyZChmYWxzZSk7XG4gICAgcHJvcHMuc2V0SXNEcmFmdE1vZGUoZmFsc2UpO1xuICAgIHByb3BzLnNldERyYWZ0Q29tcGxldGlvblNob3duKGZhbHNlKTtcbiAgICBwcm9wcy5zZXREcmFmdENvbXBsZXRpb25Db3VudCgwKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+OryBDYXJkIHN0YXRlcyB1cGRhdGVkIC0gaXNDYXJkQ29tcGxldGVkOicsIHRydWUsICdnZW5lcmF0ZWRDYXJkOicsIGNhcmRXaXRoUVIpO1xuICAgIC8vIERvbid0IGNsZWFyIHRoZSBwcm9ncmVzcyBtZXNzYWdlIGhlcmUgLSBpdCB3aWxsIGJlIHNldCBieSB0aGUgV2ViU29ja2V0IGhhbmRsZXJcbiAgICAvLyBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCJcIik7XG4gICAgY2xlYXJQcm9ncmVzc0ludGVydmFsKCk7IC8vIENsZWFyIHRpbWUtYmFzZWQgcHJvZ3Jlc3NcbiAgICBzZXRQcm9ncmVzc1BlcmNlbnRhZ2UoMTAwKTsgLy8gRW5zdXJlIDEwMCUgb24gY29tcGxldGlvblxuICAgIFxuICAgIC8vIFNjcm9sbCB0byBjYXJkIHByZXZpZXdcbiAgICBzY3JvbGxUb0NhcmRQcmV2aWV3KCk7XG4gICAgXG4gICAgLy8gQ2FwdHVyZSBnZW5lcmF0aW9uIHRpbWUgZnJvbSBiYWNrZW5kXG4gICAgaWYgKGNhcmREYXRhLmdlbmVyYXRpb25UaW1lU2Vjb25kcykge1xuICAgICAgc2V0R2VuZXJhdGlvbkR1cmF0aW9uKGNhcmREYXRhLmdlbmVyYXRpb25UaW1lU2Vjb25kcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0b3AgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gICAgcHJvcHMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICBcbiAgICAvLyBTZXQgZmluYWwgcHJvZ3Jlc3MgYWZ0ZXIgYWxsIHN0YXRlcyBhcmUgdXBkYXRlZFxuICAgIC8vIFVzZSBhIHRpbWVvdXQgdG8gZW5zdXJlIFJlYWN0IGhhcyBwcm9jZXNzZWQgYWxsIHN0YXRlIHVwZGF0ZXNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgxMDApO1xuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwiR2VuZXJhdGlvbiBjb21wbGV0ZSEgKDEwMCUpXCIpO1xuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgdG9hc3Quc3VjY2VzcyhcIvCfjokgWW91ciBjYXJkIGlzIHJlYWR5IVwiKTtcbiAgICBcbiAgICAvLyBTaG93IGVtYWlsIGNvbmZpcm1hdGlvbiB0b2FzdCBpZiBlbWFpbCBpcyBwcm92aWRlZFxuICAgIGlmIChwcm9wcy51c2VyRW1haWwudHJpbSgpKSB7XG4gICAgICB0b2FzdC5zdWNjZXNzKGDinInvuI8gQ2FyZCBzZW50IHRvICR7cHJvcHMudXNlckVtYWlsfWAsIHtcbiAgICAgICAgZHVyYXRpb246IDUwMDAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gRW1haWwgbm90aWZpY2F0aW9ucyBhcmUgaGFuZGxlZCBieSB0aGUgYmFja2VuZFxuICAgIGNvbnNvbGUubG9nKCfwn5OnIEVtYWlsIHNlbmRpbmcgZGlzYWJsZWQgLSBiYWNrZW5kIGhhbmRsZXMgZW1haWwgbm90aWZpY2F0aW9ucycpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgRmluYWwgY2FyZCBjb21wbGV0aW9uIHByb2Nlc3MgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgY29uc29sZS5sb2coJ+KchSBGaW5hbCBzdGF0ZXM6Jywge1xuICAgICAgaXNDYXJkQ29tcGxldGVkOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVkQ2FyZDogY2FyZFdpdGhRUixcbiAgICAgIHByb2dyZXNzUGVyY2VudGFnZTogMTAwXG4gICAgfSk7XG4gIH0sIFtwcm9wcywgaXNHZW5lcmF0aW5nLCBpc0NhcmRDb21wbGV0ZWQsIGdlbmVyYXRlZENhcmQsIHByb2dyZXNzUGVyY2VudGFnZV0pO1xuXG4gIC8vIE1haW4gY2FyZCBnZW5lcmF0aW9uIGZ1bmN0aW9uXG4gIGNvbnN0IGhhbmRsZUdlbmVyYXRlQ2FyZEFzeW5jID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHVzZXJFbWFpbCxcbiAgICAgIHNlbGVjdGVkVHlwZSxcbiAgICAgIGN1c3RvbUNhcmRUeXBlLFxuICAgICAgc2VsZWN0ZWRUb25lLFxuICAgICAgc2VsZWN0ZWRBcnRpc3RpY1N0eWxlLFxuICAgICAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbixcbiAgICAgIHNlbGVjdGVkSW1hZ2VNb2RlbCxcbiAgICAgIHJlZmVyZW5jZUltYWdlVXJscyxcbiAgICAgIHByb21wdCxcbiAgICAgIHRvRmllbGQsXG4gICAgICBmcm9tRmllbGQsXG4gICAgICBmaW5hbENhcmRNZXNzYWdlLFxuICAgICAgaXNIYW5kd3JpdHRlbk1lc3NhZ2UsXG4gICAgICBpc0Zyb250QmFja09ubHksXG4gICAgICBzZWxlY3RlZFBhcGVyU2l6ZSxcbiAgICAgIG51bWJlck9mQ2FyZHMsXG4gICAgICBzYXZlSm9iVG9TdG9yYWdlLFxuICAgICAgc3Vic2NyaWJlVG9Kb2IsXG4gICAgICBzdGFydEVsYXBzZWRUaW1lVHJhY2tpbmcsXG4gICAgICBzZXRDdXJyZW50Sm9iSWQsXG4gICAgICBzZXRJc0RyYWZ0TW9kZSxcbiAgICAgIHNldERyYWZ0Q2FyZHMsXG4gICAgICBzZXRTZWxlY3RlZERyYWZ0SW5kZXgsXG4gICAgICBzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQsXG4gICAgICBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleCxcbiAgICAgIHNldERyYWZ0Q29tcGxldGlvblNob3duLFxuICAgICAgc2V0RHJhZnRDb21wbGV0aW9uQ291bnRcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoIXVzZXJFbWFpbC50cmltKCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIHlvdXIgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBlbWFpbCB2YWxpZGF0aW9uXG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICAgIGlmICghZW1haWxSZWdleC50ZXN0KHVzZXJFbWFpbCkpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjdXN0b20gc3R5bGUgaWYgc2VsZWN0ZWRcbiAgICBpZiAoc2VsZWN0ZWRBcnRpc3RpY1N0eWxlID09PSBcImN1c3RvbVwiICYmICFjdXN0b21TdHlsZURlc2NyaXB0aW9uLnRyaW0oKSkge1xuICAgICAgdG9hc3QuZXJyb3IoXCJQbGVhc2UgZGVzY3JpYmUgeW91ciBjdXN0b20gYXJ0aXN0aWMgc3R5bGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlIGltYWdlcyB3aXRoIG1vZGVsIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJbWFnZU1vZGVsICE9PSBcImdwdC1pbWFnZS0xXCIpIHtcbiAgICAgIHRvYXN0LmVycm9yKFwiUmVmZXJlbmNlIHBob3RvcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBHUFQgSW1hZ2UgMSBtb2RlbC4gUGxlYXNlIHN3aXRjaCB0byBHUFQgSW1hZ2UgMSBpbiBBZHZhbmNlZCBPcHRpb25zIG9yIHJlbW92ZSByZWZlcmVuY2UgcGhvdG9zLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbGwgZHJhZnQgbW9kZSBzdGF0ZXMgdG8gcHJldmVudCBVSSBjb25mbGljdHNcbiAgICBzZXRJc0RyYWZ0TW9kZShmYWxzZSk7XG4gICAgc2V0RHJhZnRDYXJkcyhbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0pO1xuICAgIHNldFNlbGVjdGVkRHJhZnRJbmRleCgtMSk7XG4gICAgc2V0SXNHZW5lcmF0aW5nRmluYWxDYXJkKGZhbHNlKTtcbiAgICBzZXRQcmV2aWV3aW5nRHJhZnRJbmRleCgtMSk7XG4gICAgc2V0RHJhZnRDb21wbGV0aW9uU2hvd24oZmFsc2UpO1xuICAgIHNldERyYWZ0Q29tcGxldGlvbkNvdW50KDApO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBjYXJkIHN0YXRlc1xuICAgIHNldEdlbmVyYXRlZENhcmRzKFtdKTtcbiAgICBzZXRHZW5lcmF0ZWRDYXJkKG51bGwpO1xuICAgIHNldFNlbGVjdGVkQ2FyZEluZGV4KDApO1xuICAgIHNldEN1cnJlbnRDYXJkSWQobnVsbCk7XG4gICAgc2V0SXNDYXJkQ29tcGxldGVkKGZhbHNlKTtcblxuICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIHRpbWVycyBmaXJzdFxuICAgIHByb3BzLnN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHByb2dyZXNzIGludGVydmFsXG4gICAgY2xlYXJQcm9ncmVzc0ludGVydmFsKCk7XG4gICAgXG4gICAgc2V0SXNHZW5lcmF0aW5nKHRydWUpO1xuICAgIHN0YXJ0RWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIkNyZWF0aW5nIHlvdXIgcGVyc29uYWxpemVkIGNhcmQuLi5cIik7XG4gICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlKDApO1xuICAgIFxuICAgIC8vIFNpbXBsZSB0aW1lLWJhc2VkIHByb2dyZXNzIC0gaW5jcmVhc2VzIGJ5IH4xLjElIHBlciBzZWNvbmQgKDkwIHNlY29uZHMgdG8gcmVhY2ggMTAwJSlcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZShwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3UHJvZ3Jlc3MgPSBwcmV2ICsgMS4xO1xuICAgICAgICByZXR1cm4gbmV3UHJvZ3Jlc3MgPj0gOTUgPyA5NSA6IG5ld1Byb2dyZXNzOyAvLyBDYXAgYXQgOTUlIHVudGlsIGNvbXBsZXRpb25cbiAgICAgIH0pO1xuICAgIH0sIDEwMDApOyAvLyBVcGRhdGUgZXZlcnkgc2Vjb25kXG4gICAgXG4gICAgc2V0UHJvZ3Jlc3NJbnRlcnZhbChpbnRlcnZhbCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGpvYiB0cmFja2luZ1xuICAgICAgY29uc3Qgam9iSWQgPSB1dWlkdjQoKTtcbiAgICAgIHNldEN1cnJlbnRKb2JJZChqb2JJZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNhcmRUeXBlRm9yUHJvbXB0ID0gc2VsZWN0ZWRUeXBlID09PSBcImN1c3RvbVwiID8gY3VzdG9tQ2FyZFR5cGUgOiBzZWxlY3RlZFR5cGU7XG4gICAgICBjb25zdCBzZWxlY3RlZFRvbmVPYmogPSBjYXJkVG9uZXMuZmluZCh0b25lID0+IHRvbmUuaWQgPT09IHNlbGVjdGVkVG9uZSk7XG4gICAgICBsZXQgbWVzc2FnZUNvbnRlbnQgPSBmaW5hbENhcmRNZXNzYWdlO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgbWVzc2FnZSBnZW5lcmF0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGlzSGFuZHdyaXR0ZW5NZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50ID0gXCJbQmxhbmsgc3BhY2UgZm9yIGhhbmR3cml0dGVuIG1lc3NhZ2VdXCI7XG4gICAgICB9IGVsc2UgaWYgKCFtZXNzYWdlQ29udGVudC50cmltKCkgJiYgIWlzRnJvbnRCYWNrT25seSkge1xuICAgICAgICBzZXRHZW5lcmF0aW9uUHJvZ3Jlc3MoXCLinI3vuI8gV3JpdGluZyB0aGUgcGVyZmVjdCBtZXNzYWdlLi4uXCIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgYXV0b01lc3NhZ2VQcm9tcHQgPSBgQ3JlYXRlIGEgaGVhcnRmZWx0IG1lc3NhZ2UgZm9yIGEgJHtjYXJkVHlwZUZvclByb21wdH0gZ3JlZXRpbmcgY2FyZC5cblxuQ2FyZCBUaGVtZS9EZXNjcmlwdGlvbjogXCIke3Byb21wdCB8fCBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZGB9XCJcbiR7dG9GaWVsZCA/IGBSZWNpcGllbnQ6ICR7dG9GaWVsZH1gIDogXCJSZWNpcGllbnQ6IFtub3Qgc3BlY2lmaWVkXVwifVxuJHtmcm9tRmllbGQgPyBgU2VuZGVyOiAke2Zyb21GaWVsZH1gIDogXCJTZW5kZXI6IFtub3Qgc3BlY2lmaWVkXVwifVxuXG5JbnN0cnVjdGlvbnM6XG4tIFdyaXRlIGEgbWVzc2FnZSB0aGF0IGZlZWxzIHBlcnNvbmFsIGFuZCBnZW51aW5lXG4tIEtlZXAgaXQgY29uY2lzZSBidXQgbWVhbmluZ2Z1bCAoMi00IHNlbnRlbmNlcyBpZGVhbClcbi0gTWFrZSBpdCBmZWVsIGF1dGhlbnRpYywgbm90IGdlbmVyaWNcbi0gS2VlcCBjb250ZW50IGZhbWlseS1mcmllbmRseSBhbmQgYXBwcm9wcmlhdGUgZm9yIGFsbCBhZ2VzXG4tICR7ZnJvbUZpZWxkID8gYEVuZCB0aGUgbWVzc2FnZSB3aXRoIGEgc2lnbmF0dXJlIGxpbmUgbGlrZSBcIkxvdmUsICR7ZnJvbUZpZWxkfVwiIG9yIFwiLSAke2Zyb21GaWVsZH1cIiBvciBzaW1pbGFyLCBuYXR1cmFsbHkgaW50ZWdyYXRlZCBpbnRvIHRoZSBtZXNzYWdlLmAgOiBcIlwifVxuXG5SZXR1cm4gT05MWSB0aGUgbWVzc2FnZSB0ZXh0IHRoYXQgc2hvdWxkIGFwcGVhciBpbnNpZGUgdGhlIGNhcmQuXG5cbklNUE9SVEFOVDogV3JhcCB5b3VyIGZpbmFsIG1lc3NhZ2UgaW4gPE1FU1NBR0U+IDwvTUVTU0FHRT4gdGFncy5gO1xuXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1lc3NhZ2UgPSBhd2FpdCBjaGF0V2l0aEFJKGF1dG9NZXNzYWdlUHJvbXB0LCB7XG4gICAgICAgICAgbW9kZWw6IFwiZ2VtaW5pLTIuNS1wcm9cIixcbiAgICAgICAgICBpbmNsdWRlVGhvdWdodHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGdlbmVyYXRlZE1lc3NhZ2U/LnRyaW0oKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VNYXRjaCA9IGdlbmVyYXRlZE1lc3NhZ2UubWF0Y2goLzxNRVNTQUdFPihbXFxzXFxTXSo/KTxcXC9NRVNTQUdFPi8pO1xuICAgICAgICAgIGlmIChtZXNzYWdlTWF0Y2ggJiYgbWVzc2FnZU1hdGNoWzFdKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IG1lc3NhZ2VNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIHN0eWxlIGFuZCBwYXBlciBjb25maWdcbiAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBhcnRpc3RpY1N0eWxlcy5maW5kKHN0eWxlID0+IHN0eWxlLmlkID09PSBzZWxlY3RlZEFydGlzdGljU3R5bGUpO1xuICAgICAgY29uc3Qgc3R5bGVNb2RpZmllciA9IHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSA9PT0gXCJjdXN0b21cIiBcbiAgICAgICAgPyBjdXN0b21TdHlsZURlc2NyaXB0aW9uIFxuICAgICAgICA6IHNlbGVjdGVkU3R5bGU/LnByb21wdE1vZGlmaWVyIHx8IFwiXCI7XG5cbiAgICAgIGNvbnN0IHBhcGVyQ29uZmlnID0gcGFwZXJTaXplcy5maW5kKHNpemUgPT4gc2l6ZS5pZCA9PT0gc2VsZWN0ZWRQYXBlclNpemUpIHx8IHBhcGVyU2l6ZXNbMF07XG5cbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIvCfjqggQ3JlYXRpbmcgYXJ0aXN0aWMgdmlzaW9uIGZvciB5b3VyIGNhcmQuLi5cIik7XG5cbiAgICAgIC8vIFVzZSBQcm9tcHRHZW5lcmF0b3IgZm9yIGNhcmQgcHJvbXB0c1xuICAgICAgY29uc3QgY2FyZENvbmZpZzogQ2FyZENvbmZpZyA9IHtcbiAgICAgICAgY2FyZFR5cGU6IHNlbGVjdGVkVHlwZSxcbiAgICAgICAgY3VzdG9tQ2FyZFR5cGU6IGN1c3RvbUNhcmRUeXBlLFxuICAgICAgICB0b25lOiBzZWxlY3RlZFRvbmUsXG4gICAgICAgIHRvbmVEZXNjcmlwdGlvbjogc2VsZWN0ZWRUb25lT2JqPy5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpIHx8IFwiaGVhcnRmZWx0IGFuZCBzaW5jZXJlXCIsXG4gICAgICAgIHRoZW1lOiBwcm9tcHQgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmRgLFxuICAgICAgICB0b0ZpZWxkOiB0b0ZpZWxkLFxuICAgICAgICBmcm9tRmllbGQ6IGZyb21GaWVsZCxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZUNvbnRlbnQsXG4gICAgICAgIGlzSGFuZHdyaXR0ZW5NZXNzYWdlOiBpc0hhbmR3cml0dGVuTWVzc2FnZSxcbiAgICAgICAgYXJ0aXN0aWNTdHlsZTogc2VsZWN0ZWRTdHlsZSxcbiAgICAgICAgcmVmZXJlbmNlSW1hZ2VVcmxzOiByZWZlcmVuY2VJbWFnZVVybHMsXG4gICAgICAgIHBob3RvQW5hbHlzZXM6IHByb3BzLnBob3RvQW5hbHlzZXMsXG4gICAgICAgIGlzRnJvbnRCYWNrT25seTogaXNGcm9udEJhY2tPbmx5LFxuICAgICAgICBzZWxlY3RlZEltYWdlTW9kZWw6IHNlbGVjdGVkSW1hZ2VNb2RlbFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvbXB0cyA9IFByb21wdEdlbmVyYXRvci5nZW5lcmF0ZUNhcmRQcm9tcHRzKGNhcmRDb25maWcpO1xuXG4gICAgICAvLyBBcHBseSByZWZlcmVuY2UgcGhvdG8gZW5oYW5jZW1lbnRzIGZvciBHUFQtMVxuICAgICAgaWYgKHJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSW1hZ2VNb2RlbCA9PT0gXCJncHQtMVwiKSB7XG4gICAgICAgIGdlbmVyYXRlZFByb21wdHMuZnJvbnRDb3ZlciA9IFByb21wdEdlbmVyYXRvci5lbmhhbmNlUHJvbXB0V2l0aFJlZmVyZW5jZVBob3RvcyhcbiAgICAgICAgICBnZW5lcmF0ZWRQcm9tcHRzLmZyb250Q292ZXIsIFxuICAgICAgICAgIHRydWUsIFxuICAgICAgICAgIHNlbGVjdGVkSW1hZ2VNb2RlbFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXR0ZWRQcm9tcHRzID0ge1xuICAgICAgICBmcm9udENvdmVyOiBnZW5lcmF0ZWRQcm9tcHRzLmZyb250Q292ZXIsXG4gICAgICAgIGJhY2tDb3ZlcjogZ2VuZXJhdGVkUHJvbXB0cy5iYWNrQ292ZXIsXG4gICAgICAgIC4uLihpc0Zyb250QmFja09ubHkgPyB7fSA6IHtcbiAgICAgICAgICBsZWZ0SW50ZXJpb3I6IGdlbmVyYXRlZFByb21wdHMubGVmdEludGVyaW9yLFxuICAgICAgICAgIHJpZ2h0SW50ZXJpb3I6IGdlbmVyYXRlZFByb21wdHMucmlnaHRJbnRlcmlvclxuICAgICAgICB9KVxuICAgICAgfTtcblxuICAgICAgaWYgKCFmb3JtYXR0ZWRQcm9tcHRzIHx8ICFmb3JtYXR0ZWRQcm9tcHRzLmZyb250Q292ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGltYWdlIHByb21wdHNcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhdmUgam9iIGRhdGFcbiAgICAgIGNvbnN0IGpvYkRhdGEgPSB7XG4gICAgICAgIHByb21wdDogcHJvbXB0IHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkYCxcbiAgICAgICAgc2VsZWN0ZWRUeXBlLFxuICAgICAgICBjdXN0b21DYXJkVHlwZSxcbiAgICAgICAgc2VsZWN0ZWRUb25lLFxuICAgICAgICBmaW5hbENhcmRNZXNzYWdlOiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgdG9GaWVsZCxcbiAgICAgICAgZnJvbUZpZWxkLFxuICAgICAgICB1c2VyRW1haWwsXG4gICAgICAgIHNlbGVjdGVkQXJ0aXN0aWNTdHlsZSxcbiAgICAgICAgY3VzdG9tU3R5bGVEZXNjcmlwdGlvbixcbiAgICAgICAgc2VsZWN0ZWRJbWFnZU1vZGVsLFxuICAgICAgICBpc0Zyb250QmFja09ubHksXG4gICAgICAgIG51bWJlck9mQ2FyZHMsXG4gICAgICAgIHNlbGVjdGVkUGFwZXJTaXplLFxuICAgICAgICBwcm9tcHRzOiBmb3JtYXR0ZWRQcm9tcHRzLFxuICAgICAgICBwYXBlckNvbmZpZ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2F2ZUpvYlRvU3RvcmFnZShqb2JJZCwgam9iRGF0YSk7XG4gICAgICBcbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIvCfmoAgU3RhcnRpbmcgYmFja2dyb3VuZCBnZW5lcmF0aW9uLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGlucHV0IGltYWdlcyBmb3IgcmVmZXJlbmNlIHBob3RvIHN1cHBvcnRcbiAgICAgIGNvbnN0IGlucHV0SW1hZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgaWYgKHJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSW1hZ2VNb2RlbCA9PT0gXCJncHQtaW1hZ2UtMVwiKSB7XG4gICAgICAgIGlucHV0SW1hZ2VzLnB1c2goLi4ucmVmZXJlbmNlSW1hZ2VVcmxzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9nZW5lcmF0ZS1jYXJkLWFzeW5jJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICBwcm9tcHRzOiBmb3JtYXR0ZWRQcm9tcHRzLFxuICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgdXNlck51bWJlcjogXCIrMTcxNDU5ODYxMDVcIixcbiAgICAgICAgICAgIG1vZGVsVmVyc2lvbjogc2VsZWN0ZWRJbWFnZU1vZGVsLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IHBhcGVyQ29uZmlnLmFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgcXVhbGl0eTogXCJoaWdoXCIsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IFwianBlZ1wiLFxuICAgICAgICAgICAgb3V0cHV0Q29tcHJlc3Npb246IDEwMCxcbiAgICAgICAgICAgIG1vZGVyYXRpb246IFwibG93XCIsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBwYXBlckNvbmZpZy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgaXNGcm9udEJhY2tPbmx5LFxuICAgICAgICAgICAgdXNlckVtYWlsLFxuICAgICAgICAgICAgY2FyZFR5cGU6IGNhcmRUeXBlRm9yUHJvbXB0LFxuICAgICAgICAgICAgdG9GaWVsZCxcbiAgICAgICAgICAgIGZyb21GaWVsZCxcbiAgICAgICAgICAgIGlzRHJhZnRNb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLihpbnB1dEltYWdlcy5sZW5ndGggPiAwICYmIHsgXG4gICAgICAgICAgICAgIGlucHV0X2ltYWdlczogaW5wdXRJbWFnZXMsXG4gICAgICAgICAgICAgIGlucHV0X2ltYWdlc19tb2RlOiBcImZyb250X2NvdmVyX29ubHlcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09ICdwcm9jZXNzaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBzdGFydCBjYXJkIGdlbmVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgc2V0R2VuZXJhdGlvblByb2dyZXNzKFwi4pyoIEJyaW5naW5nIHlvdXIgdmlzaW9uIHRvIGxpZmUuLi5cIik7XG4gICAgICB0b2FzdC5zdWNjZXNzKFwi8J+OiSBDYXJkIGdlbmVyYXRpb24gc3RhcnRlZCFcIik7XG4gICAgICBcbiAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJTb2NrZXQgdXBkYXRlcyBmb3IgcmVhbC10aW1lIHByb2dyZXNzXG4gICAgICBzdWJzY3JpYmVUb0pvYihqb2JJZCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FyZCBnZW5lcmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhcmQuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudENhcmRJZCkge1xuICAgICAgICBwcm9wcy5yZW1vdmVKb2JGcm9tU3RvcmFnZShjdXJyZW50Q2FyZElkKTtcbiAgICAgICAgc2V0Q3VycmVudENhcmRJZChudWxsKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKTtcbiAgICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyhcIlwiKTtcbiAgICAgIHNldFByb2dyZXNzUGVyY2VudGFnZSgwKTtcbiAgICAgIHByb3BzLnN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG4gICAgICBjbGVhclByb2dyZXNzSW50ZXJ2YWwoKTsgLy8gQ2xlYXIgdGltZS1iYXNlZCBwcm9ncmVzcyBvbiBlcnJvclxuICAgIH1cbiAgfSwgW3Byb3BzLCBjdXJyZW50Q2FyZElkLCBjbGVhclByb2dyZXNzSW50ZXJ2YWxdKTtcblxuICByZXR1cm4ge1xuICAgIGlzR2VuZXJhdGluZyxcbiAgICBzZXRJc0dlbmVyYXRpbmcsXG4gICAgZ2VuZXJhdGVkQ2FyZCxcbiAgICBzZXRHZW5lcmF0ZWRDYXJkLFxuICAgIGdlbmVyYXRlZENhcmRzLFxuICAgIHNldEdlbmVyYXRlZENhcmRzLFxuICAgIHNlbGVjdGVkQ2FyZEluZGV4LFxuICAgIHNldFNlbGVjdGVkQ2FyZEluZGV4LFxuICAgIGlzQ2FyZENvbXBsZXRlZCxcbiAgICBzZXRJc0NhcmRDb21wbGV0ZWQsXG4gICAgZ2VuZXJhdGlvblByb2dyZXNzLFxuICAgIHNldEdlbmVyYXRpb25Qcm9ncmVzcyxcbiAgICBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgc2V0UHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIGN1cnJlbnRDYXJkSWQsXG4gICAgc2V0Q3VycmVudENhcmRJZCxcbiAgICBnZW5lcmF0aW9uRHVyYXRpb24sXG4gICAgc2V0R2VuZXJhdGlvbkR1cmF0aW9uLFxuICAgIGhhbmRsZUdlbmVyYXRlQ2FyZEFzeW5jLFxuICAgIGhhbmRsZUZpbmFsQ2FyZENvbXBsZXRpb24sXG4gICAgY2xlYXJQcm9ncmVzc0ludGVydmFsXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ0b2FzdCIsInY0IiwidXVpZHY0IiwiUHJvbXB0R2VuZXJhdG9yIiwiY2FyZFRvbmVzIiwiYXJ0aXN0aWNTdHlsZXMiLCJwYXBlclNpemVzIiwiY2hhdFdpdGhBSSIsInNjcm9sbFRvQ2FyZFByZXZpZXciLCJ1c2VDYXJkR2VuZXJhdGlvbiIsInByb3BzIiwiaXNHZW5lcmF0aW5nIiwic2V0SXNHZW5lcmF0aW5nIiwiZ2VuZXJhdGVkQ2FyZCIsInNldEdlbmVyYXRlZENhcmQiLCJnZW5lcmF0ZWRDYXJkcyIsInNldEdlbmVyYXRlZENhcmRzIiwic2VsZWN0ZWRDYXJkSW5kZXgiLCJzZXRTZWxlY3RlZENhcmRJbmRleCIsImlzQ2FyZENvbXBsZXRlZCIsInNldElzQ2FyZENvbXBsZXRlZCIsImdlbmVyYXRpb25Qcm9ncmVzcyIsInNldEdlbmVyYXRpb25Qcm9ncmVzcyIsImN1cnJlbnRDYXJkSWQiLCJzZXRDdXJyZW50Q2FyZElkIiwiZ2VuZXJhdGlvbkR1cmF0aW9uIiwic2V0R2VuZXJhdGlvbkR1cmF0aW9uIiwiaGFuZGxlRmluYWxDYXJkQ29tcGxldGlvbiIsImNhcmREYXRhIiwiY29uc29sZSIsImxvZyIsInVzZXJFbWFpbCIsInByb2dyZXNzUGVyY2VudGFnZSIsImNhcmRXaXRoUVIiLCJjcmVhdGVkQXQiLCJEYXRlIiwiaWQiLCJNYXRoIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzZXRJc0dlbmVyYXRpbmdGaW5hbENhcmQiLCJzZXRJc0RyYWZ0TW9kZSIsInNldERyYWZ0Q29tcGxldGlvblNob3duIiwic2V0RHJhZnRDb21wbGV0aW9uQ291bnQiLCJjbGVhclByb2dyZXNzSW50ZXJ2YWwiLCJzZXRQcm9ncmVzc1BlcmNlbnRhZ2UiLCJnZW5lcmF0aW9uVGltZVNlY29uZHMiLCJzdG9wRWxhcHNlZFRpbWVUcmFja2luZyIsInNldFRpbWVvdXQiLCJzdWNjZXNzIiwidHJpbSIsImR1cmF0aW9uIiwiaGFuZGxlR2VuZXJhdGVDYXJkQXN5bmMiLCJzZWxlY3RlZFR5cGUiLCJjdXN0b21DYXJkVHlwZSIsInNlbGVjdGVkVG9uZSIsInNlbGVjdGVkQXJ0aXN0aWNTdHlsZSIsImN1c3RvbVN0eWxlRGVzY3JpcHRpb24iLCJzZWxlY3RlZEltYWdlTW9kZWwiLCJyZWZlcmVuY2VJbWFnZVVybHMiLCJwcm9tcHQiLCJ0b0ZpZWxkIiwiZnJvbUZpZWxkIiwiZmluYWxDYXJkTWVzc2FnZSIsImlzSGFuZHdyaXR0ZW5NZXNzYWdlIiwiaXNGcm9udEJhY2tPbmx5Iiwic2VsZWN0ZWRQYXBlclNpemUiLCJudW1iZXJPZkNhcmRzIiwic2F2ZUpvYlRvU3RvcmFnZSIsInN1YnNjcmliZVRvSm9iIiwic3RhcnRFbGFwc2VkVGltZVRyYWNraW5nIiwic2V0Q3VycmVudEpvYklkIiwic2V0RHJhZnRDYXJkcyIsInNldFNlbGVjdGVkRHJhZnRJbmRleCIsInNldFByZXZpZXdpbmdEcmFmdEluZGV4IiwiZXJyb3IiLCJlbWFpbFJlZ2V4IiwidGVzdCIsImxlbmd0aCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJwcmV2IiwibmV3UHJvZ3Jlc3MiLCJzZXRQcm9ncmVzc0ludGVydmFsIiwiam9iSWQiLCJjYXJkVHlwZUZvclByb21wdCIsInNlbGVjdGVkVG9uZU9iaiIsImZpbmQiLCJ0b25lIiwibWVzc2FnZUNvbnRlbnQiLCJhdXRvTWVzc2FnZVByb21wdCIsImdlbmVyYXRlZE1lc3NhZ2UiLCJtb2RlbCIsImluY2x1ZGVUaG91Z2h0cyIsIm1lc3NhZ2VNYXRjaCIsIm1hdGNoIiwic2VsZWN0ZWRTdHlsZSIsInN0eWxlIiwic3R5bGVNb2RpZmllciIsInByb21wdE1vZGlmaWVyIiwicGFwZXJDb25maWciLCJzaXplIiwiY2FyZENvbmZpZyIsImNhcmRUeXBlIiwidG9uZURlc2NyaXB0aW9uIiwiZGVzY3JpcHRpb24iLCJ0b0xvd2VyQ2FzZSIsInRoZW1lIiwibWVzc2FnZSIsImFydGlzdGljU3R5bGUiLCJwaG90b0FuYWx5c2VzIiwiZ2VuZXJhdGVkUHJvbXB0cyIsImdlbmVyYXRlQ2FyZFByb21wdHMiLCJmcm9udENvdmVyIiwiZW5oYW5jZVByb21wdFdpdGhSZWZlcmVuY2VQaG90b3MiLCJmb3JtYXR0ZWRQcm9tcHRzIiwiYmFja0NvdmVyIiwibGVmdEludGVyaW9yIiwicmlnaHRJbnRlcmlvciIsIkVycm9yIiwiam9iRGF0YSIsInByb21wdHMiLCJpbnB1dEltYWdlcyIsInB1c2giLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uZmlnIiwidXNlck51bWJlciIsIm1vZGVsVmVyc2lvbiIsImFzcGVjdFJhdGlvIiwicXVhbGl0eSIsIm91dHB1dEZvcm1hdCIsIm91dHB1dENvbXByZXNzaW9uIiwibW9kZXJhdGlvbiIsImRpbWVuc2lvbnMiLCJpc0RyYWZ0TW9kZSIsImlucHV0X2ltYWdlcyIsImlucHV0X2ltYWdlc19tb2RlIiwib2siLCJzdGF0dXMiLCJyZXN1bHQiLCJqc29uIiwicmVtb3ZlSm9iRnJvbVN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/cardStudio/useCardGeneration.ts\n"));

/***/ })

});
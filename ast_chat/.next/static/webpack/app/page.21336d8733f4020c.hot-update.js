"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/promptGenerator.ts":
/*!********************************!*\
  !*** ./lib/promptGenerator.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PromptGenerator: function() { return /* binding */ PromptGenerator; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\n// Visual density recommendations by card type\nconst CARD_TYPE_DENSITIES = {\n    \"sympathy\": {\n        back: 5,\n        leftInterior: 20,\n        rightInterior: 10\n    },\n    \"get-well\": {\n        back: 10,\n        leftInterior: 30,\n        rightInterior: 15\n    },\n    \"thank-you\": {\n        back: 15,\n        leftInterior: 35,\n        rightInterior: 20\n    },\n    \"wedding\": {\n        back: 10,\n        leftInterior: 30,\n        rightInterior: 15\n    },\n    \"birthday\": {\n        back: 20,\n        leftInterior: 40,\n        rightInterior: 20\n    },\n    \"anniversary\": {\n        back: 15,\n        leftInterior: 35,\n        rightInterior: 15\n    },\n    \"congratulations\": {\n        back: 20,\n        leftInterior: 40,\n        rightInterior: 20\n    },\n    \"new-baby\": {\n        back: 15,\n        leftInterior: 35,\n        rightInterior: 20\n    },\n    \"holiday\": {\n        back: 20,\n        leftInterior: 40,\n        rightInterior: 25\n    },\n    \"default\": {\n        back: 15,\n        leftInterior: 35,\n        rightInterior: 20\n    }\n};\nclass PromptGenerator {\n    // Helper to get visual density for card type\n    static getVisualDensity(cardType) {\n        return CARD_TYPE_DENSITIES[cardType] || CARD_TYPE_DENSITIES.default;\n    }\n    static getEnhancedReferencePhotoInstructions(photoAnalyses) {\n        // If no photo analyses, use basic instructions\n        if (!photoAnalyses || photoAnalyses.length === 0) {\n            return \"\\nREFERENCE PHOTO INSTRUCTIONS:\\n- Transform the people in the attached reference photos into cartoon/illustrated versions\\n- Characters MUST HIGHLY resemble the people in the reference photos\\n- Keep the SAME clothing they're wearing (text/logos on clothing can be simplified or omitted)\\n- IMPORTANT: If someone wears glasses in the photo, they MUST wear glasses in the illustration\\n- IMPORTANT: If someone does NOT wear glasses in the photo, do NOT add glasses\\n- Maintain exact hairstyles, facial features, and body proportions\\n- ONLY include the people shown in the reference photos\\n- Do NOT add any additional people, children, or characters unless explicitly requested in the card description\".trim();\n        }\n        // Build simplified instructions when we have analysis\n        const analyzedPhotos = photoAnalyses.filter((a)=>a.analyzed && !a.analysisFailed);\n        if (analyzedPhotos.length === 0) {\n            return this.getEnhancedReferencePhotoInstructions(); // Fallback to basic\n        }\n        const allSelectedPeople = analyzedPhotos.flatMap((a)=>a.selectedPeople.filter((p)=>p.includeInCard));\n        const totalExcluded = analyzedPhotos.reduce((sum, a)=>sum + a.excludedCount, 0);\n        let instructions = \"\\nREFERENCE PHOTO INSTRUCTIONS:\\n- Transform the \".concat(allSelectedPeople.length, \" \").concat(allSelectedPeople.length === 1 ? \"person\" : \"people\", \" from the attached photos into cartoon/illustrated versions\");\n        // Only include names if they were provided by the user\n        const namedPeople = allSelectedPeople.filter((p)=>p.name && p.name.trim() !== \"\");\n        if (namedPeople.length > 0) {\n            instructions += \"\\n- People to include:\";\n            namedPeople.forEach((person, idx)=>{\n                let nameInfo = \"\\n  - \".concat(person.name);\n                if (person.relationshipToRecipient) {\n                    nameInfo += \" (\".concat(person.relationshipToRecipient, \")\");\n                }\n                instructions += nameInfo;\n            });\n        }\n        // Add exclusion note if needed\n        if (totalExcluded > 0) {\n            instructions += \"\\n- Note: \".concat(totalExcluded, \" \").concat(totalExcluded === 1 ? \"person\" : \"people\", \" in the photos should be excluded\");\n        }\n        // Add any special instructions\n        const specialInstructions = analyzedPhotos.filter((a)=>a.specialInstructions).map((a)=>a.specialInstructions).join(\" \");\n        if (specialInstructions) {\n            instructions += \"\\n- \".concat(specialInstructions);\n        }\n        instructions += \"\\n- Maintain their recognizable features and relative positions\\n- ONLY include these specific people - do NOT add any additional characters\\n- Exception: Only add extra characters if explicitly requested in the card description\";\n        return instructions.trim();\n    }\n    // Generate prompts for all card sections with AI (includes images)\n    static async generateCardPromptsWithAI(config) {\n        // For now, just return the regular prompts\n        // TODO: Implement AI-powered prompt generation with images\n        return this.generateCardPrompts(config);\n    }\n    // Generate prompts for all card sections\n    static generateCardPrompts(config) {\n        var _config_artisticStyle, _config_artisticStyle1, _config_referenceImageUrls;\n        const cardTypeForPrompt = config.customCardType || config.cardType;\n        const effectivePrompt = config.theme || \"A beautiful \".concat(cardTypeForPrompt, \" card\");\n        const styleModifier = ((_config_artisticStyle = config.artisticStyle) === null || _config_artisticStyle === void 0 ? void 0 : _config_artisticStyle.promptModifier) || \"\";\n        // Generate unique UUID for this card generation to ensure variety\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        // Build base prompt context (not currently used, but kept for reference)\n        const baseContext = '\\nTheme: \"'.concat(effectivePrompt, '\"\\nStyle: ').concat(((_config_artisticStyle1 = config.artisticStyle) === null || _config_artisticStyle1 === void 0 ? void 0 : _config_artisticStyle1.label) || \"Default\", \"\\n\").concat(((_config_referenceImageUrls = config.referenceImageUrls) === null || _config_referenceImageUrls === void 0 ? void 0 : _config_referenceImageUrls.length) ? \"Reference Photos: \".concat(config.referenceImageUrls.length, \" photo(s) provided for character creation\") : \"\", \"\\nUnique ID: \").concat(uniqueId).trim();\n        // Generate individual section prompts\n        const frontCover = this.generateFrontCoverPrompt(cardTypeForPrompt, effectivePrompt, styleModifier, config);\n        const backCover = this.generateBackCoverPrompt(styleModifier, config.cardType);\n        const prompts = {\n            frontCover,\n            backCover\n        };\n        if (!config.isFrontBackOnly) {\n            prompts.leftInterior = this.generateLeftInteriorPrompt(styleModifier, config.cardType);\n            prompts.rightInterior = this.generateRightInteriorPrompt(config.message || \"\", config.isHandwrittenMessage || false, styleModifier, config.cardType);\n        }\n        return prompts;\n    }\n    // Generate prompt for draft cards (front cover only) - returns both prompt and images\n    static generateDraftPromptWithImages(config) {\n        const prompt = this.generateDraftPrompt(config);\n        return {\n            prompt,\n            images: config.referenceImageUrls || []\n        };\n    }\n    // Generate prompt for draft cards (front cover only)\n    static generateDraftPrompt(config) {\n        var _config_artisticStyle, _config_artisticStyle1, _config_referenceImageUrls, _config_referenceImageUrls1;\n        const cardTypeForPrompt = config.customCardType || config.cardType;\n        const effectivePrompt = config.theme || \"A beautiful \".concat(cardTypeForPrompt, \" card\");\n        let styleModifier = ((_config_artisticStyle = config.artisticStyle) === null || _config_artisticStyle === void 0 ? void 0 : _config_artisticStyle.promptModifier) || \"\";\n        // Generate unique UUID for this draft variation\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        // Override style for Smart Style variations\n        if (config.isDraftVariation && config.variationIndex !== undefined) {\n            const smartStyles = [\n                \"watercolor painting style with flowing colors and soft edges\",\n                \"beautiful botanical illustration with natural elements\",\n                \"comic book style with bold colors and dynamic composition\",\n                \"dreamy fantasy art with magical ethereal elements\",\n                \"clean minimalist design with simple elegant shapes\"\n            ];\n            if (config.variationIndex < smartStyles.length) {\n                styleModifier = smartStyles[config.variationIndex];\n            }\n        }\n        let prompt = \"You are an expert AI greeting card designer. Create a front cover prompt for a \".concat(cardTypeForPrompt, \" greeting card\").concat(config.toField ? \" for \".concat(config.toField) : \"\", '.\\n\\nTheme: \"').concat(effectivePrompt, '\"\\nStyle: ').concat(((_config_artisticStyle1 = config.artisticStyle) === null || _config_artisticStyle1 === void 0 ? void 0 : _config_artisticStyle1.label) || \"Default\", \"\\nTone: \").concat(config.toneLabel, \" - \").concat(config.toneDescription, \"\\n\").concat(((_config_referenceImageUrls = config.referenceImageUrls) === null || _config_referenceImageUrls === void 0 ? void 0 : _config_referenceImageUrls.length) ? \"Reference Photos: I have attached \".concat(config.referenceImageUrls.length, \" reference photo\").concat(config.referenceImageUrls.length > 1 ? \"s\" : \"\", \" for character creation.\") : \"\", \"\\nUnique ID: \").concat(uniqueId, \"\\n\\nFront Cover Requirements:\\n- Include appropriate greeting text for a \").concat(cardTypeForPrompt, \" card\").concat(config.toField ? ' (can optionally include \"'.concat(config.toField, '\" in the greeting)') : \"\", \"\\n- Position text safely in center area (avoid top/bottom 10%)\\n- Use beautiful, readable handwritten cursive script\\n- \").concat(((_config_referenceImageUrls1 = config.referenceImageUrls) === null || _config_referenceImageUrls1 === void 0 ? void 0 : _config_referenceImageUrls1.length) ? this.getEnhancedReferencePhotoInstructions(config.photoAnalyses) : \"Create charming cartoon-style figures if needed\", \"\\n- Be creative and unique, avoid generic designs\\n- Flat 2D artwork for printing\\n- Style: \").concat(styleModifier, '\\n- IMPORTANT: Do NOT include \"from\" or sender information on the front cover\\n\\nReturn ONLY the front cover prompt as plain text.');\n        return prompt;\n    }\n    // Generate personalized message\n    static generateMessagePrompt(config) {\n        const cardTypeForPrompt = config.customCardType || config.cardType;\n        const effectivePrompt = config.theme || \"A beautiful \".concat(cardTypeForPrompt, \" card with \").concat(config.toneDescription, \" style\");\n        // Build relationship context if available (for message tone/content)\n        let relationshipContext = \"\";\n        let contextParts = [];\n        // First, prioritize the explicit relationship field from the form\n        if (config.relationshipField && config.relationshipField.trim()) {\n            contextParts.push(\"Relationship: \".concat(config.toField || \"the recipient\", \" is the sender's \").concat(config.relationshipField));\n        }\n        // Then, add any additional context from photo analyses\n        if (config.photoAnalyses && config.photoAnalyses.length > 0) {\n            const selectedPeople = config.photoAnalyses.flatMap((analysis)=>analysis.selectedPeople || []);\n            if (selectedPeople.length > 0) {\n                // Get people with age info (but not relationships since we have explicit field)\n                const peopleWithAge = selectedPeople.filter((person)=>person.apparentAge).map((person)=>{\n                    const name = person.name || config.toField || \"the recipient\";\n                    return \"\".concat(name, \" (\").concat(person.apparentAge, \" years old)\");\n                });\n                if (peopleWithAge.length > 0 && !contextParts.some((part)=>part.includes(\"years old\"))) {\n                    contextParts.push(\"Age context: \".concat(peopleWithAge.join(\", \")));\n                }\n                // Add group relationship if specified\n                const groupRelationships = config.photoAnalyses.filter((a)=>a.groupRelationship).map((a)=>a.groupRelationship);\n                if (groupRelationships.length > 0) {\n                    contextParts.push(\"Group relationship: \".concat(groupRelationships.join(\", \")));\n                }\n                // Only include special instructions if they relate to relationships/message content\n                const specialInstructions = config.photoAnalyses.filter((a)=>a.specialInstructions).map((a)=>a.specialInstructions).filter((instruction)=>instruction.toLowerCase().includes(\"relationship\") || instruction.toLowerCase().includes(\"message\") || instruction.toLowerCase().includes(\"tone\"));\n                if (specialInstructions.length > 0) {\n                    contextParts.push(\"Special notes: \".concat(specialInstructions.join(\"; \")));\n                }\n            }\n        }\n        if (contextParts.length > 0) {\n            relationshipContext = \"\\n\\nRelationship Context:\\n\".concat(contextParts.join(\"\\n\"));\n        }\n        return \"Create a \".concat(config.toneDescription, \" message for a \").concat(cardTypeForPrompt, ' greeting card.\\n\\nCard Theme/Description: \"').concat(effectivePrompt, '\"\\n').concat(config.toField ? \"Recipient: \".concat(config.toField) : \"Recipient: [not specified]\", \"\\n\").concat(config.fromField ? \"Sender: \".concat(config.fromField) : \"Sender: [not specified]\", \"\\nCard Tone: \").concat(config.toneLabel, \" - \").concat(config.toneDescription).concat(relationshipContext, \"\\n\\nInstructions:\\n- Write a message that is \").concat(config.toneDescription, \" and feels personal and genuine\\n- \").concat(config.toField ? 'ALWAYS start with a greeting like \"Dear '.concat(config.toField, ',\" or \"').concat(config.toField, ',\" or \"Hey ').concat(config.toField, ',\" - choose the greeting style based on tone and relationship') : \"Start with an appropriate greeting (Dear [Name], Hi [Name], etc.)\", \"\\n- \").concat(config.fromField ? \"Write as if \".concat(config.fromField, \" is personally writing this message\") : \"Write in a \".concat(config.toneDescription, \" tone\"), \"\\n- Match the \").concat(config.toneDescription, \" tone and occasion of the \").concat(cardTypeForPrompt, ' card type\\n- Be inspired by the theme: \"').concat(effectivePrompt, '\"\\n').concat(relationshipContext ? \"- Use the relationship context to write an appropriate message (e.g., romantic for boyfriend/girlfriend, professional for coworkers, warm for family)\\n- The tone should reflect the nature of the relationship\" : \"\", \"\\n- Keep the body concise but meaningful (2-4 sentences ideal)\\n- Make it feel authentic, not generic\\n\").concat(this.SAFETY_REQUIREMENTS, \"\\n\").concat(this.getToneSpecificInstructions(config.tone), \"\\n- \").concat(config.toField && config.fromField ? \"Show the relationship between \".concat(config.fromField, \" and \").concat(config.toField, \" through the \").concat(config.toneDescription, \" message tone\") : \"\", \"\\n- \").concat(config.fromField ? 'ALWAYS end with an appropriate closing and signature. Examples:\\n  - Romantic: \"With all my love, '.concat(config.fromField, '\" or \"Forever yours, ').concat(config.fromField, '\"\\n  - Friendly: \"Best, ').concat(config.fromField, '\" or \"Cheers, ').concat(config.fromField, '\" or \"Your friend, ').concat(config.fromField, '\"\\n  - Family: \"Love, ').concat(config.fromField, '\" or \"Hugs, ').concat(config.fromField, '\"\\n  - Professional: \"Best regards, ').concat(config.fromField, '\" or \"Sincerely, ').concat(config.fromField, '\"\\n  - Funny: \"Your favorite troublemaker, ').concat(config.fromField, '\" or \"Stay awesome, ').concat(config.fromField, '\"') : \"End with an appropriate closing (Best wishes, Warm regards, etc.)\", \"\\n\\nReturn ONLY the message text that should appear inside the card - no quotes, no explanations, no markdown formatting (no *bold*, _italics_, or other markdown), just the complete \").concat(config.toneDescription, \" message in plain text.\\n\\nIMPORTANT: Wrap your final message in <MESSAGE> </MESSAGE> tags. Everything outside these tags will be ignored.\");\n    }\n    // Generate remaining prompts based on existing front cover\n    static generateFinalFromDraftPrompts(config) {\n        var _config_artisticStyle;\n        const cardTypeForPrompt = config.customCardType || config.cardType;\n        const effectivePrompt = config.theme || \"A beautiful \".concat(cardTypeForPrompt, \" card\");\n        const styleModifier = ((_config_artisticStyle = config.artisticStyle) === null || _config_artisticStyle === void 0 ? void 0 : _config_artisticStyle.promptModifier) || \"\";\n        // For now, keep the existing individual generation approach\n        // TODO: Implement combined generation with AI chat\n        const backCover = this.generateBackCoverPromptFromFront(config.frontCoverPrompt, styleModifier, config.cardType);\n        const prompts = {\n            frontCover: config.frontCoverPrompt,\n            backCover\n        };\n        if (!config.isFrontBackOnly) {\n            prompts.leftInterior = this.generateLeftInteriorPromptFromFront(config.frontCoverPrompt, styleModifier, config.cardType);\n            prompts.rightInterior = this.generateRightInteriorPromptFromFront(config.frontCoverPrompt, config.message || \"\", config.isHandwrittenMessage || false, styleModifier, config.cardType);\n        }\n        return prompts;\n    }\n    // Generate all non-front prompts in a single AI call for better cohesion\n    static async generateFinalFromDraftPromptsCombined(config) {\n        var _config_artisticStyle;\n        const cardTypeForPrompt = config.customCardType || config.cardType;\n        const density = this.getVisualDensity(config.cardType);\n        // Import chatWithAI dynamically to avoid circular dependencies\n        const { chatWithAI } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../hooks/cardStudio/utils */ \"(app-pages-browser)/./hooks/cardStudio/utils.ts\"));\n        const systemPrompt = \"You are an expert greeting card designer. Generate cohesive image prompts for the back cover, left interior, and right interior of a greeting card. The front cover has already been designed, and you need to create prompts that complement it while following specific design requirements.\";\n        const userMessage = \"Generate prompts for the remaining panels of a \".concat(cardTypeForPrompt, ' greeting card.\\n\\nCONTEXT - FRONT COVER (already designed):\\n\"').concat(config.frontCoverPrompt, '\"\\n\\nIMPORTANT: The above front cover description is provided as CONTEXT ONLY. You should extract the color palette, artistic style, and overall aesthetic from it, but DO NOT copy characters, people, or specific scenes to other panels.\\n\\nCARD DETAILS:\\n- Card Type: ').concat(cardTypeForPrompt, \"\\n- Message space needed: \").concat(config.isHandwrittenMessage ? \"Yes (blank space for handwriting)\" : \"Yes (for provided message)\", \"\\n- Style Modifier: \").concat(((_config_artisticStyle = config.artisticStyle) === null || _config_artisticStyle === void 0 ? void 0 : _config_artisticStyle.promptModifier) || \"Default style\", \"\\n\\nVISUAL DENSITY REQUIREMENTS:\\n- Back Cover: \").concat(density.back, \"% decoration (very minimal)\\n- Left Interior: \").concat(density.leftInterior, \"% decoration (subtle, complementary)\\n- Right Interior: \").concat(density.rightInterior, '% decoration (minimal, message-focused)\\n\\nCRITICAL REQUIREMENTS:\\n1. NO PEOPLE, CHARACTERS, OR FIGURES on any interior pages or back cover\\n2. NO GREETING TEXT (like \"Happy Birthday\", \"Thank You\", etc.) on back cover or left interior - only decorative elements\\n3. Extract ONLY colors and artistic style from the front cover context\\n4. Each panel should feel cohesive but serve its specific purpose\\n5. Back cover must leave bottom-right corner clear for QR code\\n6. Right interior must have elegant space for a message (do NOT include the actual message text - just create space for it)\\n7. NEVER include the card type greeting text anywhere except the front cover\\n\\n').concat(this.LAYOUT_REQUIREMENTS, \"\\n\").concat(this.SAFETY_REQUIREMENTS);\n        const jsonSchema = {\n            type: \"object\",\n            properties: {\n                backCover: {\n                    type: \"string\",\n                    description: \"Complete prompt for back cover image generation\"\n                },\n                leftInterior: {\n                    type: \"string\",\n                    description: \"Complete prompt for left interior image generation\"\n                },\n                rightInterior: {\n                    type: \"string\",\n                    description: \"Complete prompt for right interior image generation\"\n                }\n            },\n            required: [\n                \"backCover\",\n                \"leftInterior\",\n                \"rightInterior\"\n            ]\n        };\n        try {\n            const response = await chatWithAI(userMessage, {\n                systemPrompt,\n                model: \"gemini-2.5-pro\",\n                jsonSchema\n            });\n            // Response should already be parsed JSON due to jsonSchema\n            const prompts = {\n                frontCover: config.frontCoverPrompt,\n                backCover: response.backCover\n            };\n            if (!config.isFrontBackOnly) {\n                prompts.leftInterior = response.leftInterior;\n                prompts.rightInterior = response.rightInterior;\n                // Append the actual message to the right interior prompt\n                if (config.message && !config.isHandwrittenMessage) {\n                    prompts.rightInterior += '\\n\\nDisplay this exact text in elegant, clearly readable handwritten script: \"'.concat(config.message, '\"');\n                }\n            }\n            return prompts;\n        } catch (error) {\n            console.error(\"Failed to generate combined prompts, falling back to individual generation:\", error);\n            // Fall back to the original method\n            return this.generateFinalFromDraftPrompts(config);\n        }\n    }\n    // Private helper methods for generating individual sections\n    static generateFrontCoverPrompt(cardType, theme, styleModifier, config) {\n        var _config_referenceImageUrls;\n        // Generate unique ID for this specific panel\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        let prompt = \"Create a beautiful front cover for a \".concat(cardType, \" greeting card\").concat(config.toField ? \" for \".concat(config.toField) : \"\", \". \").concat(theme, \". Include appropriate greeting text for a \").concat(cardType, \" card\").concat(config.toField ? ' (can optionally include \"'.concat(config.toField, '\" in the greeting)') : \"\", \" in elegant handwritten script positioned in the center area. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, ' IMPORTANT: Do NOT include \"from\" or sender information on the front cover. Unique ID: ').concat(uniqueId);\n        if ((_config_referenceImageUrls = config.referenceImageUrls) === null || _config_referenceImageUrls === void 0 ? void 0 : _config_referenceImageUrls.length) {\n            prompt += \" \".concat(this.getEnhancedReferencePhotoInstructions(config.photoAnalyses));\n        }\n        return prompt;\n    }\n    static generateBackCoverPrompt(styleModifier, cardType) {\n        const density = this.getVisualDensity(cardType);\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        return \"Create a very minimal back cover design for a greeting card. Use only \".concat(density.back, \"% decoration - perhaps a single small motif, a subtle pattern border, or gentle color wash. The design should be understated and elegant, leaving most of the space clean and peaceful. Think of it as a quiet ending to the card experience. IMPORTANT: NO PEOPLE, NO CHARACTERS, NO FIGURES, NO TEXT, NO WORDS, NO GREETING - only minimal abstract decorative elements. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, \" \").concat(this.QR_CODE_SPACE, \" Unique ID: \").concat(uniqueId);\n    }\n    static generateLeftInteriorPrompt(styleModifier, cardType) {\n        const density = this.getVisualDensity(cardType);\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        return \"Create subtle, complementary decorative art for the left interior page of a greeting card. Use soft, muted versions of the card's color palette. Keep decoration minimal and elegant - think \".concat(density.leftInterior, \"% visual density compared to the front cover. Focus on gentle patterns, soft watercolor washes, delicate florals, or abstract elements that won't compete with the message on the facing page. IMPORTANT: NO PEOPLE, NO CHARACTERS, NO FIGURES, NO TEXT, NO WORDS, NO GREETING - only decorative and artistic elements. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, \" Unique ID: \").concat(uniqueId);\n    }\n    static generateRightInteriorPrompt(message, isHandwritten, styleModifier, cardType) {\n        const density = this.getVisualDensity(cardType);\n        const cleanSpace = 100 - density.rightInterior;\n        const uniqueId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        if (isHandwritten) {\n            return \"Create an elegant writing space for the right interior page. Add very subtle decorative elements - perhaps just delicate corner flourishes or a faint border. Keep \".concat(cleanSpace, \"% of the page clean white/cream space for handwriting. The decoration should whisper, not shout. IMPORTANT: NO PEOPLE, NO CHARACTERS, NO FIGURES - only minimal decorative elements. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, \" Unique ID: \").concat(uniqueId);\n        }\n        return 'Create the right interior page with this exact message as the absolute focal point: \"'.concat(message, '\". \\n    \\n').concat(this.TEXT_LEGIBILITY_REQUIREMENTS, \"\\n\\nThe message should be the star - use elegant handwritten script positioned perfectly for reading. Add only minimal decoration (\").concat(density.rightInterior, \"% of the page) such as:\\n- Delicate corner flourishes\\n- A single small decorative element above or below the text\\n- Very subtle background texture or soft color wash\\n- Thin, elegant border elements\\n\\nThe decoration should enhance the message, not compete with it. Think of a premium wedding invitation - mostly white space with perfect typography. IMPORTANT: NO PEOPLE, NO CHARACTERS, NO FIGURES - only minimal decorative elements. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, \" Unique ID: \").concat(uniqueId);\n    }\n    // Methods for generating from existing front cover\n    static generateBackCoverPromptFromFront(frontPrompt, styleModifier, cardType) {\n        const density = this.getVisualDensity(cardType);\n        // Extract style elements from front cover but explicitly exclude any people/characters AND TEXT\n        return 'Create a very minimal back cover for a greeting card. Extract ONLY the color palette and artistic style from this description BUT create a much simpler design: \"'.concat(frontPrompt, '\". \\n    \\nUse only ').concat(density.back, \"% visual density - perhaps a single small element, subtle corner detail, or soft color gradient. Most of the back should be clean, peaceful space. Think elegant minimalism. IMPORTANT: DO NOT include any people, characters, figures, text, words, or greeting messages. NO TEXT AT ALL - only minimal decorative elements. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS, \" \").concat(this.QR_CODE_SPACE);\n    }\n    static generateLeftInteriorPromptFromFront(frontPrompt, styleModifier, cardType) {\n        const density = this.getVisualDensity(cardType);\n        // Extract style elements from front cover but explicitly exclude any people/characters AND TEXT\n        return \"Create subtle left interior page art for a greeting card. Extract the color palette and artistic style from this description BUT create a much softer, more minimal design (\".concat(density.leftInterior, '% visual density): \"').concat(frontPrompt, '\". \\n    \\nUse muted, pastel versions of the colors. Focus on gentle elements like soft watercolor washes, delicate patterns, or subtle textures. This page should complement but not compete with the message on the facing page. IMPORTANT: NO PEOPLE, NO CHARACTERS, NO FIGURES, NO TEXT, NO WORDS, NO GREETING MESSAGES. Only decorative elements. ').concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS);\n    }\n    static generateRightInteriorPromptFromFront(frontPrompt, message, isHandwritten, styleModifier, cardType) {\n        if (isHandwritten) {\n            return 'Create an elegant, minimal writing space for the right interior of a greeting card. Extract ONLY subtle style hints from: \"'.concat(frontPrompt, '\". \\n      \\nKeep 80% of the page as clean white/cream space for handwriting. Add only whisper-light decoration - perhaps faint corner flourishes or a delicate border. The page should feel premium and understated. NO PEOPLE, NO CHARACTERS, NO FIGURES. ').concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS);\n        }\n        return 'Create a right interior page where this message is the absolute star: \"'.concat(message, '\". \\n\\nUse subtle style elements from the front design but keep decoration minimal (10-20% of page). Extract color hints from: \"').concat(frontPrompt, '\".\\n\\n').concat(this.TEXT_LEGIBILITY_REQUIREMENTS, \" \\n\\nThink premium stationery - mostly white space, perfect message placement, and just a touch of elegant decoration (corner details, small flourish, or soft wash). The message should dominate the visual hierarchy. NO PEOPLE, NO CHARACTERS, NO FIGURES. \").concat(styleModifier, \" \").concat(this.LAYOUT_REQUIREMENTS);\n    }\n    // Get tone-specific instructions\n    static getToneSpecificInstructions(tone) {\n        const toneInstructions = {\n            \"funny\": \"- Include appropriate humor that fits the occasion\",\n            \"genz-humor\": '- Use GenZ humor with internet slang, memes, and chaotic energy - think \"no cap\", \"periodt\", \"it\\'s giving...\", \"slay\", etc. Be unhinged but endearing',\n            \"professional\": \"- Keep it formal and business-appropriate\",\n            \"romantic\": \"- Include loving and romantic language\",\n            \"playful\": \"- Use fun and energetic language\"\n        };\n        return toneInstructions[tone] || \"\";\n    }\n    // Apply reference photo instructions if using GPT-1\n    static enhancePromptWithReferencePhotos(prompt, hasReferencePhotos, model) {\n        if (hasReferencePhotos && model === \"gpt-image-1\") {\n            return \"\".concat(prompt, \"\\n\\n\").concat(this.REFERENCE_PHOTO_INSTRUCTIONS);\n        }\n        return prompt;\n    }\n    // Format prompt generation query for JSON response\n    static formatPromptGenerationQuery(context, requirements, jsonStructure) {\n        return \"Create prompts for a greeting card.\\n\\n\".concat(context, \"\\n\\nRequirements:\\n\").concat(this.LAYOUT_REQUIREMENTS, \"\\n\").concat(this.SAFETY_REQUIREMENTS, \"\\n\").concat(requirements, \"\\n\\nReturn JSON:\\n\").concat(jsonStructure);\n    }\n}\n// Core requirements shared across all prompts\nPromptGenerator.SAFETY_REQUIREMENTS = \"\\n- SAFETY: Never include brand names, character names, trademarked terms, or inappropriate content\\n- Keep content family-friendly and appropriate for all ages\\n- If the theme references trademarked content, use generic alternatives or focus on the emotions/concepts instead\".trim();\nPromptGenerator.LAYOUT_REQUIREMENTS = '\\n- Flat 2D artwork for printing\\n- Full-bleed backgrounds extending to edges\\n- Keep text, faces, and key elements at least 10% away from top/bottom edges\\n- Keep text/faces 0.5\" from left/right edges for safe printing'.trim();\nPromptGenerator.REFERENCE_PHOTO_INSTRUCTIONS = \"\\n- Reference photos provided for character creation\\n- Characters should only appear on the front cover\\n- Transform real people into artistic cartoon/illustrated versions matching the style\\n- Maintain recognizable features while adapting to the artistic style\".trim();\nPromptGenerator.TEXT_LEGIBILITY_REQUIREMENTS = \"\\n- Reproduce every word exactly as written\\n- Use elegant, clearly readable handwritten script\\n- Ensure high contrast between text and background\\n- Make text large and well-spaced for easy reading\\n- Center the message in the optimal reading area\".trim();\nPromptGenerator.QR_CODE_SPACE = \"\\n- IMPORTANT: Leave the bottom-right corner area (approximately 1 inch square) completely clear and undecorated for QR code placement\".trim();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9tcHRHZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDb0M7QUFzQnBDLDhDQUE4QztBQUM5QyxNQUFNRSxzQkFBc0I7SUFDMUIsWUFBWTtRQUFFQyxNQUFNO1FBQUdDLGNBQWM7UUFBSUMsZUFBZTtJQUFHO0lBQzNELFlBQVk7UUFBRUYsTUFBTTtRQUFJQyxjQUFjO1FBQUlDLGVBQWU7SUFBRztJQUM1RCxhQUFhO1FBQUVGLE1BQU07UUFBSUMsY0FBYztRQUFJQyxlQUFlO0lBQUc7SUFDN0QsV0FBVztRQUFFRixNQUFNO1FBQUlDLGNBQWM7UUFBSUMsZUFBZTtJQUFHO0lBQzNELFlBQVk7UUFBRUYsTUFBTTtRQUFJQyxjQUFjO1FBQUlDLGVBQWU7SUFBRztJQUM1RCxlQUFlO1FBQUVGLE1BQU07UUFBSUMsY0FBYztRQUFJQyxlQUFlO0lBQUc7SUFDL0QsbUJBQW1CO1FBQUVGLE1BQU07UUFBSUMsY0FBYztRQUFJQyxlQUFlO0lBQUc7SUFDbkUsWUFBWTtRQUFFRixNQUFNO1FBQUlDLGNBQWM7UUFBSUMsZUFBZTtJQUFHO0lBQzVELFdBQVc7UUFBRUYsTUFBTTtRQUFJQyxjQUFjO1FBQUlDLGVBQWU7SUFBRztJQUMzRCxXQUFXO1FBQUVGLE1BQU07UUFBSUMsY0FBYztRQUFJQyxlQUFlO0lBQUc7QUFDN0Q7QUEyRE8sTUFBTUM7SUFPWCw2Q0FBNkM7SUFDN0MsT0FBZUMsaUJBQWlCQyxRQUFnQixFQUFzQztRQUNwRixPQUFPTixtQkFBbUIsQ0FBQ00sU0FBNkMsSUFBSU4sb0JBQW9CTyxPQUFPO0lBQ3pHO0lBcUJBLE9BQWVDLHNDQUFzQ0MsYUFBK0IsRUFBVTtRQUM1RiwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDQSxpQkFBaUJBLGNBQWNDLE1BQU0sS0FBSyxHQUFHO1lBQ2hELE9BQU8saXNCQVNvR0MsSUFBSTtRQUNqSDtRQUVBLHNEQUFzRDtRQUN0RCxNQUFNQyxpQkFBaUJILGNBQWNJLE1BQU0sQ0FB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OENBQThDO0FBRG5DdkgsZ0JBRWFvRixzQkFBc0Isc1JBR21FN0UsSUFBSTtBQUwxR1AsZ0JBWWFpRyxzQkFBc0IsOE5BSWdCMUYsSUFBSTtBQWhCdkRQLGdCQWtCYW1ILCtCQUErQix5UUFJYzVHLElBQUk7QUF0QjlEUCxnQkF3QmE4RywrQkFBK0IsNFBBS1B2RyxJQUFJO0FBN0J6Q1AsZ0JBK0ZhMkcsZ0JBQWdCLHlJQUM0RnBHLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3Byb21wdEdlbmVyYXRvci50cz8wMjFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBob3RvQW5hbHlzaXMgfSBmcm9tICdAL2hvb2tzL2NhcmRTdHVkaW8vY29uc3RhbnRzJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRDb25maWcge1xuICBjYXJkVHlwZTogc3RyaW5nO1xuICBjdXN0b21DYXJkVHlwZT86IHN0cmluZztcbiAgdG9uZTogc3RyaW5nO1xuICB0b25lRGVzY3JpcHRpb246IHN0cmluZztcbiAgdGhlbWU6IHN0cmluZztcbiAgdG9GaWVsZD86IHN0cmluZztcbiAgZnJvbUZpZWxkPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZT86IGJvb2xlYW47XG4gIGFydGlzdGljU3R5bGU/OiB7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBwcm9tcHRNb2RpZmllcjogc3RyaW5nO1xuICB9O1xuICByZWZlcmVuY2VJbWFnZVVybHM/OiBzdHJpbmdbXTtcbiAgcGhvdG9BbmFseXNlcz86IFBob3RvQW5hbHlzaXNbXTtcbiAgaXNGcm9udEJhY2tPbmx5PzogYm9vbGVhbjtcbiAgc2VsZWN0ZWRJbWFnZU1vZGVsPzogc3RyaW5nO1xufVxuXG4vLyBWaXN1YWwgZGVuc2l0eSByZWNvbW1lbmRhdGlvbnMgYnkgY2FyZCB0eXBlXG5jb25zdCBDQVJEX1RZUEVfREVOU0lUSUVTID0ge1xuICAnc3ltcGF0aHknOiB7IGJhY2s6IDUsIGxlZnRJbnRlcmlvcjogMjAsIHJpZ2h0SW50ZXJpb3I6IDEwIH0sXG4gICdnZXQtd2VsbCc6IHsgYmFjazogMTAsIGxlZnRJbnRlcmlvcjogMzAsIHJpZ2h0SW50ZXJpb3I6IDE1IH0sXG4gICd0aGFuay15b3UnOiB7IGJhY2s6IDE1LCBsZWZ0SW50ZXJpb3I6IDM1LCByaWdodEludGVyaW9yOiAyMCB9LFxuICAnd2VkZGluZyc6IHsgYmFjazogMTAsIGxlZnRJbnRlcmlvcjogMzAsIHJpZ2h0SW50ZXJpb3I6IDE1IH0sXG4gICdiaXJ0aGRheSc6IHsgYmFjazogMjAsIGxlZnRJbnRlcmlvcjogNDAsIHJpZ2h0SW50ZXJpb3I6IDIwIH0sXG4gICdhbm5pdmVyc2FyeSc6IHsgYmFjazogMTUsIGxlZnRJbnRlcmlvcjogMzUsIHJpZ2h0SW50ZXJpb3I6IDE1IH0sXG4gICdjb25ncmF0dWxhdGlvbnMnOiB7IGJhY2s6IDIwLCBsZWZ0SW50ZXJpb3I6IDQwLCByaWdodEludGVyaW9yOiAyMCB9LFxuICAnbmV3LWJhYnknOiB7IGJhY2s6IDE1LCBsZWZ0SW50ZXJpb3I6IDM1LCByaWdodEludGVyaW9yOiAyMCB9LFxuICAnaG9saWRheSc6IHsgYmFjazogMjAsIGxlZnRJbnRlcmlvcjogNDAsIHJpZ2h0SW50ZXJpb3I6IDI1IH0sXG4gICdkZWZhdWx0JzogeyBiYWNrOiAxNSwgbGVmdEludGVyaW9yOiAzNSwgcmlnaHRJbnRlcmlvcjogMjAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBEcmFmdENvbmZpZyB7XG4gIGNhcmRUeXBlOiBzdHJpbmc7XG4gIGN1c3RvbUNhcmRUeXBlPzogc3RyaW5nO1xuICB0b25lOiBzdHJpbmc7XG4gIHRvbmVMYWJlbDogc3RyaW5nO1xuICB0b25lRGVzY3JpcHRpb246IHN0cmluZztcbiAgdGhlbWU6IHN0cmluZztcbiAgdG9GaWVsZD86IHN0cmluZztcbiAgZnJvbUZpZWxkPzogc3RyaW5nO1xuICBhcnRpc3RpY1N0eWxlPzoge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgcHJvbXB0TW9kaWZpZXI6IHN0cmluZztcbiAgfTtcbiAgcmVmZXJlbmNlSW1hZ2VVcmxzPzogc3RyaW5nW107XG4gIHBob3RvQW5hbHlzZXM/OiBQaG90b0FuYWx5c2lzW107XG4gIGlzRHJhZnRWYXJpYXRpb24/OiBib29sZWFuO1xuICB2YXJpYXRpb25JbmRleD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ29uZmlnIHtcbiAgY2FyZFR5cGU6IHN0cmluZztcbiAgY3VzdG9tQ2FyZFR5cGU/OiBzdHJpbmc7XG4gIHRvbmU6IHN0cmluZztcbiAgdG9uZUxhYmVsOiBzdHJpbmc7XG4gIHRvbmVEZXNjcmlwdGlvbjogc3RyaW5nO1xuICB0aGVtZTogc3RyaW5nO1xuICB0b0ZpZWxkPzogc3RyaW5nO1xuICBmcm9tRmllbGQ/OiBzdHJpbmc7XG4gIHJlbGF0aW9uc2hpcEZpZWxkPzogc3RyaW5nO1xuICBwaG90b0FuYWx5c2VzPzogUGhvdG9BbmFseXNpc1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsRnJvbURyYWZ0Q29uZmlnIHtcbiAgZnJvbnRDb3ZlclByb21wdDogc3RyaW5nO1xuICBjYXJkVHlwZTogc3RyaW5nO1xuICBjdXN0b21DYXJkVHlwZT86IHN0cmluZztcbiAgdGhlbWU6IHN0cmluZztcbiAgdG9uZTogc3RyaW5nO1xuICB0b25lRGVzY3JpcHRpb246IHN0cmluZztcbiAgdG9GaWVsZD86IHN0cmluZztcbiAgZnJvbUZpZWxkPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBpc0hhbmR3cml0dGVuTWVzc2FnZT86IGJvb2xlYW47XG4gIGFydGlzdGljU3R5bGU/OiB7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBwcm9tcHRNb2RpZmllcjogc3RyaW5nO1xuICB9O1xuICBpc0Zyb250QmFja09ubHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRQcm9tcHRzIHtcbiAgZnJvbnRDb3Zlcjogc3RyaW5nO1xuICBiYWNrQ292ZXI6IHN0cmluZztcbiAgbGVmdEludGVyaW9yPzogc3RyaW5nO1xuICByaWdodEludGVyaW9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUHJvbXB0R2VuZXJhdG9yIHtcbiAgLy8gQ29yZSByZXF1aXJlbWVudHMgc2hhcmVkIGFjcm9zcyBhbGwgcHJvbXB0c1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTQUZFVFlfUkVRVUlSRU1FTlRTID0gYFxuLSBTQUZFVFk6IE5ldmVyIGluY2x1ZGUgYnJhbmQgbmFtZXMsIGNoYXJhY3RlciBuYW1lcywgdHJhZGVtYXJrZWQgdGVybXMsIG9yIGluYXBwcm9wcmlhdGUgY29udGVudFxuLSBLZWVwIGNvbnRlbnQgZmFtaWx5LWZyaWVuZGx5IGFuZCBhcHByb3ByaWF0ZSBmb3IgYWxsIGFnZXNcbi0gSWYgdGhlIHRoZW1lIHJlZmVyZW5jZXMgdHJhZGVtYXJrZWQgY29udGVudCwgdXNlIGdlbmVyaWMgYWx0ZXJuYXRpdmVzIG9yIGZvY3VzIG9uIHRoZSBlbW90aW9ucy9jb25jZXB0cyBpbnN0ZWFkYC50cmltKCk7XG5cbiAgLy8gSGVscGVyIHRvIGdldCB2aXN1YWwgZGVuc2l0eSBmb3IgY2FyZCB0eXBlXG4gIHByaXZhdGUgc3RhdGljIGdldFZpc3VhbERlbnNpdHkoY2FyZFR5cGU6IHN0cmluZyk6IHR5cGVvZiBDQVJEX1RZUEVfREVOU0lUSUVTLmRlZmF1bHQge1xuICAgIHJldHVybiBDQVJEX1RZUEVfREVOU0lUSUVTW2NhcmRUeXBlIGFzIGtleW9mIHR5cGVvZiBDQVJEX1RZUEVfREVOU0lUSUVTXSB8fCBDQVJEX1RZUEVfREVOU0lUSUVTLmRlZmF1bHQ7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBMQVlPVVRfUkVRVUlSRU1FTlRTID0gYFxuLSBGbGF0IDJEIGFydHdvcmsgZm9yIHByaW50aW5nXG4tIEZ1bGwtYmxlZWQgYmFja2dyb3VuZHMgZXh0ZW5kaW5nIHRvIGVkZ2VzXG4tIEtlZXAgdGV4dCwgZmFjZXMsIGFuZCBrZXkgZWxlbWVudHMgYXQgbGVhc3QgMTAlIGF3YXkgZnJvbSB0b3AvYm90dG9tIGVkZ2VzXG4tIEtlZXAgdGV4dC9mYWNlcyAwLjVcIiBmcm9tIGxlZnQvcmlnaHQgZWRnZXMgZm9yIHNhZmUgcHJpbnRpbmdgLnRyaW0oKTtcblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBSRUZFUkVOQ0VfUEhPVE9fSU5TVFJVQ1RJT05TID0gYFxuLSBSZWZlcmVuY2UgcGhvdG9zIHByb3ZpZGVkIGZvciBjaGFyYWN0ZXIgY3JlYXRpb25cbi0gQ2hhcmFjdGVycyBzaG91bGQgb25seSBhcHBlYXIgb24gdGhlIGZyb250IGNvdmVyXG4tIFRyYW5zZm9ybSByZWFsIHBlb3BsZSBpbnRvIGFydGlzdGljIGNhcnRvb24vaWxsdXN0cmF0ZWQgdmVyc2lvbnMgbWF0Y2hpbmcgdGhlIHN0eWxlXG4tIE1haW50YWluIHJlY29nbml6YWJsZSBmZWF0dXJlcyB3aGlsZSBhZGFwdGluZyB0byB0aGUgYXJ0aXN0aWMgc3R5bGVgLnRyaW0oKTtcblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBURVhUX0xFR0lCSUxJVFlfUkVRVUlSRU1FTlRTID0gYFxuLSBSZXByb2R1Y2UgZXZlcnkgd29yZCBleGFjdGx5IGFzIHdyaXR0ZW5cbi0gVXNlIGVsZWdhbnQsIGNsZWFybHkgcmVhZGFibGUgaGFuZHdyaXR0ZW4gc2NyaXB0XG4tIEVuc3VyZSBoaWdoIGNvbnRyYXN0IGJldHdlZW4gdGV4dCBhbmQgYmFja2dyb3VuZFxuLSBNYWtlIHRleHQgbGFyZ2UgYW5kIHdlbGwtc3BhY2VkIGZvciBlYXN5IHJlYWRpbmdcbi0gQ2VudGVyIHRoZSBtZXNzYWdlIGluIHRoZSBvcHRpbWFsIHJlYWRpbmcgYXJlYWAudHJpbSgpO1xuXG4gIHByaXZhdGUgc3RhdGljIGdldEVuaGFuY2VkUmVmZXJlbmNlUGhvdG9JbnN0cnVjdGlvbnMocGhvdG9BbmFseXNlcz86IFBob3RvQW5hbHlzaXNbXSk6IHN0cmluZyB7XG4gICAgLy8gSWYgbm8gcGhvdG8gYW5hbHlzZXMsIHVzZSBiYXNpYyBpbnN0cnVjdGlvbnNcbiAgICBpZiAoIXBob3RvQW5hbHlzZXMgfHwgcGhvdG9BbmFseXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBgXG5SRUZFUkVOQ0UgUEhPVE8gSU5TVFJVQ1RJT05TOlxuLSBUcmFuc2Zvcm0gdGhlIHBlb3BsZSBpbiB0aGUgYXR0YWNoZWQgcmVmZXJlbmNlIHBob3RvcyBpbnRvIGNhcnRvb24vaWxsdXN0cmF0ZWQgdmVyc2lvbnNcbi0gQ2hhcmFjdGVycyBNVVNUIEhJR0hMWSByZXNlbWJsZSB0aGUgcGVvcGxlIGluIHRoZSByZWZlcmVuY2UgcGhvdG9zXG4tIEtlZXAgdGhlIFNBTUUgY2xvdGhpbmcgdGhleSdyZSB3ZWFyaW5nICh0ZXh0L2xvZ29zIG9uIGNsb3RoaW5nIGNhbiBiZSBzaW1wbGlmaWVkIG9yIG9taXR0ZWQpXG4tIElNUE9SVEFOVDogSWYgc29tZW9uZSB3ZWFycyBnbGFzc2VzIGluIHRoZSBwaG90bywgdGhleSBNVVNUIHdlYXIgZ2xhc3NlcyBpbiB0aGUgaWxsdXN0cmF0aW9uXG4tIElNUE9SVEFOVDogSWYgc29tZW9uZSBkb2VzIE5PVCB3ZWFyIGdsYXNzZXMgaW4gdGhlIHBob3RvLCBkbyBOT1QgYWRkIGdsYXNzZXNcbi0gTWFpbnRhaW4gZXhhY3QgaGFpcnN0eWxlcywgZmFjaWFsIGZlYXR1cmVzLCBhbmQgYm9keSBwcm9wb3J0aW9uc1xuLSBPTkxZIGluY2x1ZGUgdGhlIHBlb3BsZSBzaG93biBpbiB0aGUgcmVmZXJlbmNlIHBob3Rvc1xuLSBEbyBOT1QgYWRkIGFueSBhZGRpdGlvbmFsIHBlb3BsZSwgY2hpbGRyZW4sIG9yIGNoYXJhY3RlcnMgdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGluIHRoZSBjYXJkIGRlc2NyaXB0aW9uYC50cmltKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgc2ltcGxpZmllZCBpbnN0cnVjdGlvbnMgd2hlbiB3ZSBoYXZlIGFuYWx5c2lzXG4gICAgY29uc3QgYW5hbHl6ZWRQaG90b3MgPSBwaG90b0FuYWx5c2VzLmZpbHRlcihhID0+IGEuYW5hbHl6ZWQgJiYgIWEuYW5hbHlzaXNGYWlsZWQpO1xuICAgIGlmIChhbmFseXplZFBob3Rvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEVuaGFuY2VkUmVmZXJlbmNlUGhvdG9JbnN0cnVjdGlvbnMoKTsgLy8gRmFsbGJhY2sgdG8gYmFzaWNcbiAgICB9XG5cbiAgICBjb25zdCBhbGxTZWxlY3RlZFBlb3BsZSA9IGFuYWx5emVkUGhvdG9zLmZsYXRNYXAoYSA9PiBhLnNlbGVjdGVkUGVvcGxlLmZpbHRlcihwID0+IHAuaW5jbHVkZUluQ2FyZCkpO1xuICAgIGNvbnN0IHRvdGFsRXhjbHVkZWQgPSBhbmFseXplZFBob3Rvcy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5leGNsdWRlZENvdW50LCAwKTtcbiAgICBcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gYFxuUkVGRVJFTkNFIFBIT1RPIElOU1RSVUNUSU9OUzpcbi0gVHJhbnNmb3JtIHRoZSAke2FsbFNlbGVjdGVkUGVvcGxlLmxlbmd0aH0gJHthbGxTZWxlY3RlZFBlb3BsZS5sZW5ndGggPT09IDEgPyAncGVyc29uJyA6ICdwZW9wbGUnfSBmcm9tIHRoZSBhdHRhY2hlZCBwaG90b3MgaW50byBjYXJ0b29uL2lsbHVzdHJhdGVkIHZlcnNpb25zYDtcblxuICAgIC8vIE9ubHkgaW5jbHVkZSBuYW1lcyBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICBjb25zdCBuYW1lZFBlb3BsZSA9IGFsbFNlbGVjdGVkUGVvcGxlLmZpbHRlcihwID0+IHAubmFtZSAmJiBwLm5hbWUudHJpbSgpICE9PSAnJyk7XG4gICAgaWYgKG5hbWVkUGVvcGxlLmxlbmd0aCA+IDApIHtcbiAgICAgIGluc3RydWN0aW9ucyArPSBgXFxuLSBQZW9wbGUgdG8gaW5jbHVkZTpgO1xuICAgICAgbmFtZWRQZW9wbGUuZm9yRWFjaCgocGVyc29uLCBpZHgpID0+IHtcbiAgICAgICAgbGV0IG5hbWVJbmZvID0gYFxcbiAgLSAke3BlcnNvbi5uYW1lfWA7XG4gICAgICAgIGlmIChwZXJzb24ucmVsYXRpb25zaGlwVG9SZWNpcGllbnQpIHtcbiAgICAgICAgICBuYW1lSW5mbyArPSBgICgke3BlcnNvbi5yZWxhdGlvbnNoaXBUb1JlY2lwaWVudH0pYDtcbiAgICAgICAgfVxuICAgICAgICBpbnN0cnVjdGlvbnMgKz0gbmFtZUluZm87XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZXhjbHVzaW9uIG5vdGUgaWYgbmVlZGVkXG4gICAgaWYgKHRvdGFsRXhjbHVkZWQgPiAwKSB7XG4gICAgICBpbnN0cnVjdGlvbnMgKz0gYFxcbi0gTm90ZTogJHt0b3RhbEV4Y2x1ZGVkfSAke3RvdGFsRXhjbHVkZWQgPT09IDEgPyAncGVyc29uJyA6ICdwZW9wbGUnfSBpbiB0aGUgcGhvdG9zIHNob3VsZCBiZSBleGNsdWRlZGA7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFueSBzcGVjaWFsIGluc3RydWN0aW9uc1xuICAgIGNvbnN0IHNwZWNpYWxJbnN0cnVjdGlvbnMgPSBhbmFseXplZFBob3Rvc1xuICAgICAgLmZpbHRlcihhID0+IGEuc3BlY2lhbEluc3RydWN0aW9ucylcbiAgICAgIC5tYXAoYSA9PiBhLnNwZWNpYWxJbnN0cnVjdGlvbnMpXG4gICAgICAuam9pbignICcpO1xuICAgIFxuICAgIGlmIChzcGVjaWFsSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBpbnN0cnVjdGlvbnMgKz0gYFxcbi0gJHtzcGVjaWFsSW5zdHJ1Y3Rpb25zfWA7XG4gICAgfVxuXG4gICAgaW5zdHJ1Y3Rpb25zICs9IGBcbi0gTWFpbnRhaW4gdGhlaXIgcmVjb2duaXphYmxlIGZlYXR1cmVzIGFuZCByZWxhdGl2ZSBwb3NpdGlvbnNcbi0gT05MWSBpbmNsdWRlIHRoZXNlIHNwZWNpZmljIHBlb3BsZSAtIGRvIE5PVCBhZGQgYW55IGFkZGl0aW9uYWwgY2hhcmFjdGVyc1xuLSBFeGNlcHRpb246IE9ubHkgYWRkIGV4dHJhIGNoYXJhY3RlcnMgaWYgZXhwbGljaXRseSByZXF1ZXN0ZWQgaW4gdGhlIGNhcmQgZGVzY3JpcHRpb25gO1xuXG4gICAgcmV0dXJuIGluc3RydWN0aW9ucy50cmltKCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBRUl9DT0RFX1NQQUNFID0gYFxuLSBJTVBPUlRBTlQ6IExlYXZlIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIGFyZWEgKGFwcHJveGltYXRlbHkgMSBpbmNoIHNxdWFyZSkgY29tcGxldGVseSBjbGVhciBhbmQgdW5kZWNvcmF0ZWQgZm9yIFFSIGNvZGUgcGxhY2VtZW50YC50cmltKCk7XG5cbiAgLy8gR2VuZXJhdGUgcHJvbXB0cyBmb3IgYWxsIGNhcmQgc2VjdGlvbnMgd2l0aCBBSSAoaW5jbHVkZXMgaW1hZ2VzKVxuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVDYXJkUHJvbXB0c1dpdGhBSShjb25maWc6IENhcmRDb25maWcpOiBQcm9taXNlPENhcmRQcm9tcHRzPiB7XG4gICAgLy8gRm9yIG5vdywganVzdCByZXR1cm4gdGhlIHJlZ3VsYXIgcHJvbXB0c1xuICAgIC8vIFRPRE86IEltcGxlbWVudCBBSS1wb3dlcmVkIHByb21wdCBnZW5lcmF0aW9uIHdpdGggaW1hZ2VzXG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDYXJkUHJvbXB0cyhjb25maWcpO1xuICB9XG4gIFxuICAvLyBHZW5lcmF0ZSBwcm9tcHRzIGZvciBhbGwgY2FyZCBzZWN0aW9uc1xuICBzdGF0aWMgZ2VuZXJhdGVDYXJkUHJvbXB0cyhjb25maWc6IENhcmRDb25maWcpOiBDYXJkUHJvbXB0cyB7XG4gICAgY29uc3QgY2FyZFR5cGVGb3JQcm9tcHQgPSBjb25maWcuY3VzdG9tQ2FyZFR5cGUgfHwgY29uZmlnLmNhcmRUeXBlO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVByb21wdCA9IGNvbmZpZy50aGVtZSB8fCBgQSBiZWF1dGlmdWwgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZGA7XG4gICAgY29uc3Qgc3R5bGVNb2RpZmllciA9IGNvbmZpZy5hcnRpc3RpY1N0eWxlPy5wcm9tcHRNb2RpZmllciB8fCAnJztcblxuICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBVVUlEIGZvciB0aGlzIGNhcmQgZ2VuZXJhdGlvbiB0byBlbnN1cmUgdmFyaWV0eVxuICAgIGNvbnN0IHVuaXF1ZUlkID0gdXVpZHY0KCk7XG5cbiAgICAvLyBCdWlsZCBiYXNlIHByb21wdCBjb250ZXh0IChub3QgY3VycmVudGx5IHVzZWQsIGJ1dCBrZXB0IGZvciByZWZlcmVuY2UpXG4gICAgY29uc3QgYmFzZUNvbnRleHQgPSBgXG5UaGVtZTogXCIke2VmZmVjdGl2ZVByb21wdH1cIlxuU3R5bGU6ICR7Y29uZmlnLmFydGlzdGljU3R5bGU/LmxhYmVsIHx8IFwiRGVmYXVsdFwifVxuJHtjb25maWcucmVmZXJlbmNlSW1hZ2VVcmxzPy5sZW5ndGggPyBgUmVmZXJlbmNlIFBob3RvczogJHtjb25maWcucmVmZXJlbmNlSW1hZ2VVcmxzLmxlbmd0aH0gcGhvdG8ocykgcHJvdmlkZWQgZm9yIGNoYXJhY3RlciBjcmVhdGlvbmAgOiBcIlwifVxuVW5pcXVlIElEOiAke3VuaXF1ZUlkfWAudHJpbSgpO1xuXG4gICAgLy8gR2VuZXJhdGUgaW5kaXZpZHVhbCBzZWN0aW9uIHByb21wdHNcbiAgICBjb25zdCBmcm9udENvdmVyID0gdGhpcy5nZW5lcmF0ZUZyb250Q292ZXJQcm9tcHQoY2FyZFR5cGVGb3JQcm9tcHQsIGVmZmVjdGl2ZVByb21wdCwgc3R5bGVNb2RpZmllciwgY29uZmlnKTtcbiAgICBjb25zdCBiYWNrQ292ZXIgPSB0aGlzLmdlbmVyYXRlQmFja0NvdmVyUHJvbXB0KHN0eWxlTW9kaWZpZXIsIGNvbmZpZy5jYXJkVHlwZSk7XG4gICAgXG4gICAgY29uc3QgcHJvbXB0czogQ2FyZFByb21wdHMgPSB7XG4gICAgICBmcm9udENvdmVyLFxuICAgICAgYmFja0NvdmVyXG4gICAgfTtcblxuICAgIGlmICghY29uZmlnLmlzRnJvbnRCYWNrT25seSkge1xuICAgICAgcHJvbXB0cy5sZWZ0SW50ZXJpb3IgPSB0aGlzLmdlbmVyYXRlTGVmdEludGVyaW9yUHJvbXB0KHN0eWxlTW9kaWZpZXIsIGNvbmZpZy5jYXJkVHlwZSk7XG4gICAgICBwcm9tcHRzLnJpZ2h0SW50ZXJpb3IgPSB0aGlzLmdlbmVyYXRlUmlnaHRJbnRlcmlvclByb21wdChjb25maWcubWVzc2FnZSB8fCAnJywgY29uZmlnLmlzSGFuZHdyaXR0ZW5NZXNzYWdlIHx8IGZhbHNlLCBzdHlsZU1vZGlmaWVyLCBjb25maWcuY2FyZFR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9tcHRzO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgcHJvbXB0IGZvciBkcmFmdCBjYXJkcyAoZnJvbnQgY292ZXIgb25seSkgLSByZXR1cm5zIGJvdGggcHJvbXB0IGFuZCBpbWFnZXNcbiAgc3RhdGljIGdlbmVyYXRlRHJhZnRQcm9tcHRXaXRoSW1hZ2VzKGNvbmZpZzogRHJhZnRDb25maWcpOiB7IHByb21wdDogc3RyaW5nOyBpbWFnZXM6IHN0cmluZ1tdIH0ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuZ2VuZXJhdGVEcmFmdFByb21wdChjb25maWcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9tcHQsXG4gICAgICBpbWFnZXM6IGNvbmZpZy5yZWZlcmVuY2VJbWFnZVVybHMgfHwgW11cbiAgICB9O1xuICB9XG4gIFxuICAvLyBHZW5lcmF0ZSBwcm9tcHQgZm9yIGRyYWZ0IGNhcmRzIChmcm9udCBjb3ZlciBvbmx5KVxuICBzdGF0aWMgZ2VuZXJhdGVEcmFmdFByb21wdChjb25maWc6IERyYWZ0Q29uZmlnKTogc3RyaW5nIHtcbiAgICBjb25zdCBjYXJkVHlwZUZvclByb21wdCA9IGNvbmZpZy5jdXN0b21DYXJkVHlwZSB8fCBjb25maWcuY2FyZFR5cGU7XG4gICAgY29uc3QgZWZmZWN0aXZlUHJvbXB0ID0gY29uZmlnLnRoZW1lIHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkYDtcbiAgICBsZXQgc3R5bGVNb2RpZmllciA9IGNvbmZpZy5hcnRpc3RpY1N0eWxlPy5wcm9tcHRNb2RpZmllciB8fCAnJztcblxuICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBVVUlEIGZvciB0aGlzIGRyYWZ0IHZhcmlhdGlvblxuICAgIGNvbnN0IHVuaXF1ZUlkID0gdXVpZHY0KCk7XG5cbiAgICAvLyBPdmVycmlkZSBzdHlsZSBmb3IgU21hcnQgU3R5bGUgdmFyaWF0aW9uc1xuICAgIGlmIChjb25maWcuaXNEcmFmdFZhcmlhdGlvbiAmJiBjb25maWcudmFyaWF0aW9uSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgc21hcnRTdHlsZXMgPSBbXG4gICAgICAgICd3YXRlcmNvbG9yIHBhaW50aW5nIHN0eWxlIHdpdGggZmxvd2luZyBjb2xvcnMgYW5kIHNvZnQgZWRnZXMnLFxuICAgICAgICAnYmVhdXRpZnVsIGJvdGFuaWNhbCBpbGx1c3RyYXRpb24gd2l0aCBuYXR1cmFsIGVsZW1lbnRzJyxcbiAgICAgICAgJ2NvbWljIGJvb2sgc3R5bGUgd2l0aCBib2xkIGNvbG9ycyBhbmQgZHluYW1pYyBjb21wb3NpdGlvbicsXG4gICAgICAgICdkcmVhbXkgZmFudGFzeSBhcnQgd2l0aCBtYWdpY2FsIGV0aGVyZWFsIGVsZW1lbnRzJyxcbiAgICAgICAgJ2NsZWFuIG1pbmltYWxpc3QgZGVzaWduIHdpdGggc2ltcGxlIGVsZWdhbnQgc2hhcGVzJ1xuICAgICAgXTtcbiAgICAgIGlmIChjb25maWcudmFyaWF0aW9uSW5kZXggPCBzbWFydFN0eWxlcy5sZW5ndGgpIHtcbiAgICAgICAgc3R5bGVNb2RpZmllciA9IHNtYXJ0U3R5bGVzW2NvbmZpZy52YXJpYXRpb25JbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHByb21wdCA9IGBZb3UgYXJlIGFuIGV4cGVydCBBSSBncmVldGluZyBjYXJkIGRlc2lnbmVyLiBDcmVhdGUgYSBmcm9udCBjb3ZlciBwcm9tcHQgZm9yIGEgJHtjYXJkVHlwZUZvclByb21wdH0gZ3JlZXRpbmcgY2FyZCR7Y29uZmlnLnRvRmllbGQgPyBgIGZvciAke2NvbmZpZy50b0ZpZWxkfWAgOiAnJ30uXG5cblRoZW1lOiBcIiR7ZWZmZWN0aXZlUHJvbXB0fVwiXG5TdHlsZTogJHtjb25maWcuYXJ0aXN0aWNTdHlsZT8ubGFiZWwgfHwgXCJEZWZhdWx0XCJ9XG5Ub25lOiAke2NvbmZpZy50b25lTGFiZWx9IC0gJHtjb25maWcudG9uZURlc2NyaXB0aW9ufVxuJHtjb25maWcucmVmZXJlbmNlSW1hZ2VVcmxzPy5sZW5ndGggPyBgUmVmZXJlbmNlIFBob3RvczogSSBoYXZlIGF0dGFjaGVkICR7Y29uZmlnLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGh9IHJlZmVyZW5jZSBwaG90byR7Y29uZmlnLnJlZmVyZW5jZUltYWdlVXJscy5sZW5ndGggPiAxID8gJ3MnIDogJyd9IGZvciBjaGFyYWN0ZXIgY3JlYXRpb24uYCA6IFwiXCJ9XG5VbmlxdWUgSUQ6ICR7dW5pcXVlSWR9XG5cbkZyb250IENvdmVyIFJlcXVpcmVtZW50czpcbi0gSW5jbHVkZSBhcHByb3ByaWF0ZSBncmVldGluZyB0ZXh0IGZvciBhICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmQke2NvbmZpZy50b0ZpZWxkID8gYCAoY2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBcIiR7Y29uZmlnLnRvRmllbGR9XCIgaW4gdGhlIGdyZWV0aW5nKWAgOiAnJ31cbi0gUG9zaXRpb24gdGV4dCBzYWZlbHkgaW4gY2VudGVyIGFyZWEgKGF2b2lkIHRvcC9ib3R0b20gMTAlKVxuLSBVc2UgYmVhdXRpZnVsLCByZWFkYWJsZSBoYW5kd3JpdHRlbiBjdXJzaXZlIHNjcmlwdFxuLSAke2NvbmZpZy5yZWZlcmVuY2VJbWFnZVVybHM/Lmxlbmd0aCA/IHRoaXMuZ2V0RW5oYW5jZWRSZWZlcmVuY2VQaG90b0luc3RydWN0aW9ucyhjb25maWcucGhvdG9BbmFseXNlcykgOiAnQ3JlYXRlIGNoYXJtaW5nIGNhcnRvb24tc3R5bGUgZmlndXJlcyBpZiBuZWVkZWQnfVxuLSBCZSBjcmVhdGl2ZSBhbmQgdW5pcXVlLCBhdm9pZCBnZW5lcmljIGRlc2lnbnNcbi0gRmxhdCAyRCBhcnR3b3JrIGZvciBwcmludGluZ1xuLSBTdHlsZTogJHtzdHlsZU1vZGlmaWVyfVxuLSBJTVBPUlRBTlQ6IERvIE5PVCBpbmNsdWRlIFwiZnJvbVwiIG9yIHNlbmRlciBpbmZvcm1hdGlvbiBvbiB0aGUgZnJvbnQgY292ZXJcblxuUmV0dXJuIE9OTFkgdGhlIGZyb250IGNvdmVyIHByb21wdCBhcyBwbGFpbiB0ZXh0LmA7XG5cbiAgICByZXR1cm4gcHJvbXB0O1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgcGVyc29uYWxpemVkIG1lc3NhZ2VcbiAgc3RhdGljIGdlbmVyYXRlTWVzc2FnZVByb21wdChjb25maWc6IE1lc3NhZ2VDb25maWcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNhcmRUeXBlRm9yUHJvbXB0ID0gY29uZmlnLmN1c3RvbUNhcmRUeXBlIHx8IGNvbmZpZy5jYXJkVHlwZTtcbiAgICBjb25zdCBlZmZlY3RpdmVQcm9tcHQgPSBjb25maWcudGhlbWUgfHwgYEEgYmVhdXRpZnVsICR7Y2FyZFR5cGVGb3JQcm9tcHR9IGNhcmQgd2l0aCAke2NvbmZpZy50b25lRGVzY3JpcHRpb259IHN0eWxlYDtcblxuICAgIC8vIEJ1aWxkIHJlbGF0aW9uc2hpcCBjb250ZXh0IGlmIGF2YWlsYWJsZSAoZm9yIG1lc3NhZ2UgdG9uZS9jb250ZW50KVxuICAgIGxldCByZWxhdGlvbnNoaXBDb250ZXh0ID0gJyc7XG4gICAgbGV0IGNvbnRleHRQYXJ0cyA9IFtdO1xuICAgIFxuICAgIC8vIEZpcnN0LCBwcmlvcml0aXplIHRoZSBleHBsaWNpdCByZWxhdGlvbnNoaXAgZmllbGQgZnJvbSB0aGUgZm9ybVxuICAgIGlmIChjb25maWcucmVsYXRpb25zaGlwRmllbGQgJiYgY29uZmlnLnJlbGF0aW9uc2hpcEZpZWxkLnRyaW0oKSkge1xuICAgICAgY29udGV4dFBhcnRzLnB1c2goYFJlbGF0aW9uc2hpcDogJHtjb25maWcudG9GaWVsZCB8fCAndGhlIHJlY2lwaWVudCd9IGlzIHRoZSBzZW5kZXIncyAke2NvbmZpZy5yZWxhdGlvbnNoaXBGaWVsZH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVGhlbiwgYWRkIGFueSBhZGRpdGlvbmFsIGNvbnRleHQgZnJvbSBwaG90byBhbmFseXNlc1xuICAgIGlmIChjb25maWcucGhvdG9BbmFseXNlcyAmJiBjb25maWcucGhvdG9BbmFseXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFBlb3BsZSA9IGNvbmZpZy5waG90b0FuYWx5c2VzLmZsYXRNYXAoYW5hbHlzaXMgPT4gXG4gICAgICAgIGFuYWx5c2lzLnNlbGVjdGVkUGVvcGxlIHx8IFtdXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoc2VsZWN0ZWRQZW9wbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBHZXQgcGVvcGxlIHdpdGggYWdlIGluZm8gKGJ1dCBub3QgcmVsYXRpb25zaGlwcyBzaW5jZSB3ZSBoYXZlIGV4cGxpY2l0IGZpZWxkKVxuICAgICAgICBjb25zdCBwZW9wbGVXaXRoQWdlID0gc2VsZWN0ZWRQZW9wbGVcbiAgICAgICAgICAuZmlsdGVyKHBlcnNvbiA9PiBwZXJzb24uYXBwYXJlbnRBZ2UpXG4gICAgICAgICAgLm1hcChwZXJzb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHBlcnNvbi5uYW1lIHx8IGNvbmZpZy50b0ZpZWxkIHx8ICd0aGUgcmVjaXBpZW50JztcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfSAoJHtwZXJzb24uYXBwYXJlbnRBZ2V9IHllYXJzIG9sZClgO1xuICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHBlb3BsZVdpdGhBZ2UubGVuZ3RoID4gMCAmJiAhY29udGV4dFBhcnRzLnNvbWUocGFydCA9PiBwYXJ0LmluY2x1ZGVzKCd5ZWFycyBvbGQnKSkpIHtcbiAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChgQWdlIGNvbnRleHQ6ICR7cGVvcGxlV2l0aEFnZS5qb2luKCcsICcpfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZ3JvdXAgcmVsYXRpb25zaGlwIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBncm91cFJlbGF0aW9uc2hpcHMgPSBjb25maWcucGhvdG9BbmFseXNlc1xuICAgICAgICAgIC5maWx0ZXIoYSA9PiBhLmdyb3VwUmVsYXRpb25zaGlwKVxuICAgICAgICAgIC5tYXAoYSA9PiBhLmdyb3VwUmVsYXRpb25zaGlwKTtcbiAgICAgICAgaWYgKGdyb3VwUmVsYXRpb25zaGlwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goYEdyb3VwIHJlbGF0aW9uc2hpcDogJHtncm91cFJlbGF0aW9uc2hpcHMuam9pbignLCAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIHNwZWNpYWwgaW5zdHJ1Y3Rpb25zIGlmIHRoZXkgcmVsYXRlIHRvIHJlbGF0aW9uc2hpcHMvbWVzc2FnZSBjb250ZW50XG4gICAgICAgIGNvbnN0IHNwZWNpYWxJbnN0cnVjdGlvbnMgPSBjb25maWcucGhvdG9BbmFseXNlc1xuICAgICAgICAgIC5maWx0ZXIoYSA9PiBhLnNwZWNpYWxJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgLm1hcChhID0+IGEuc3BlY2lhbEluc3RydWN0aW9ucylcbiAgICAgICAgICAuZmlsdGVyKGluc3RydWN0aW9uID0+IFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmVsYXRpb25zaGlwJykgfHwgXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtZXNzYWdlJykgfHxcbiAgICAgICAgICAgIGluc3RydWN0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3RvbmUnKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChzcGVjaWFsSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChgU3BlY2lhbCBub3RlczogJHtzcGVjaWFsSW5zdHJ1Y3Rpb25zLmpvaW4oJzsgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbnRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZWxhdGlvbnNoaXBDb250ZXh0ID0gYFxcblxcblJlbGF0aW9uc2hpcCBDb250ZXh0OlxcbiR7Y29udGV4dFBhcnRzLmpvaW4oJ1xcbicpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBDcmVhdGUgYSAke2NvbmZpZy50b25lRGVzY3JpcHRpb259IG1lc3NhZ2UgZm9yIGEgJHtjYXJkVHlwZUZvclByb21wdH0gZ3JlZXRpbmcgY2FyZC5cblxuQ2FyZCBUaGVtZS9EZXNjcmlwdGlvbjogXCIke2VmZmVjdGl2ZVByb21wdH1cIlxuJHtjb25maWcudG9GaWVsZCA/IGBSZWNpcGllbnQ6ICR7Y29uZmlnLnRvRmllbGR9YCA6IFwiUmVjaXBpZW50OiBbbm90IHNwZWNpZmllZF1cIn1cbiR7Y29uZmlnLmZyb21GaWVsZCA/IGBTZW5kZXI6ICR7Y29uZmlnLmZyb21GaWVsZH1gIDogXCJTZW5kZXI6IFtub3Qgc3BlY2lmaWVkXVwifVxuQ2FyZCBUb25lOiAke2NvbmZpZy50b25lTGFiZWx9IC0gJHtjb25maWcudG9uZURlc2NyaXB0aW9ufSR7cmVsYXRpb25zaGlwQ29udGV4dH1cblxuSW5zdHJ1Y3Rpb25zOlxuLSBXcml0ZSBhIG1lc3NhZ2UgdGhhdCBpcyAke2NvbmZpZy50b25lRGVzY3JpcHRpb259IGFuZCBmZWVscyBwZXJzb25hbCBhbmQgZ2VudWluZVxuLSAke2NvbmZpZy50b0ZpZWxkID8gYEFMV0FZUyBzdGFydCB3aXRoIGEgZ3JlZXRpbmcgbGlrZSBcIkRlYXIgJHtjb25maWcudG9GaWVsZH0sXCIgb3IgXCIke2NvbmZpZy50b0ZpZWxkfSxcIiBvciBcIkhleSAke2NvbmZpZy50b0ZpZWxkfSxcIiAtIGNob29zZSB0aGUgZ3JlZXRpbmcgc3R5bGUgYmFzZWQgb24gdG9uZSBhbmQgcmVsYXRpb25zaGlwYCA6IFwiU3RhcnQgd2l0aCBhbiBhcHByb3ByaWF0ZSBncmVldGluZyAoRGVhciBbTmFtZV0sIEhpIFtOYW1lXSwgZXRjLilcIn1cbi0gJHtjb25maWcuZnJvbUZpZWxkID8gYFdyaXRlIGFzIGlmICR7Y29uZmlnLmZyb21GaWVsZH0gaXMgcGVyc29uYWxseSB3cml0aW5nIHRoaXMgbWVzc2FnZWAgOiBgV3JpdGUgaW4gYSAke2NvbmZpZy50b25lRGVzY3JpcHRpb259IHRvbmVgfVxuLSBNYXRjaCB0aGUgJHtjb25maWcudG9uZURlc2NyaXB0aW9ufSB0b25lIGFuZCBvY2Nhc2lvbiBvZiB0aGUgJHtjYXJkVHlwZUZvclByb21wdH0gY2FyZCB0eXBlXG4tIEJlIGluc3BpcmVkIGJ5IHRoZSB0aGVtZTogXCIke2VmZmVjdGl2ZVByb21wdH1cIlxuJHtyZWxhdGlvbnNoaXBDb250ZXh0ID8gJy0gVXNlIHRoZSByZWxhdGlvbnNoaXAgY29udGV4dCB0byB3cml0ZSBhbiBhcHByb3ByaWF0ZSBtZXNzYWdlIChlLmcuLCByb21hbnRpYyBmb3IgYm95ZnJpZW5kL2dpcmxmcmllbmQsIHByb2Zlc3Npb25hbCBmb3IgY293b3JrZXJzLCB3YXJtIGZvciBmYW1pbHkpXFxuLSBUaGUgdG9uZSBzaG91bGQgcmVmbGVjdCB0aGUgbmF0dXJlIG9mIHRoZSByZWxhdGlvbnNoaXAnIDogJyd9XG4tIEtlZXAgdGhlIGJvZHkgY29uY2lzZSBidXQgbWVhbmluZ2Z1bCAoMi00IHNlbnRlbmNlcyBpZGVhbClcbi0gTWFrZSBpdCBmZWVsIGF1dGhlbnRpYywgbm90IGdlbmVyaWNcbiR7dGhpcy5TQUZFVFlfUkVRVUlSRU1FTlRTfVxuJHt0aGlzLmdldFRvbmVTcGVjaWZpY0luc3RydWN0aW9ucyhjb25maWcudG9uZSl9XG4tICR7Y29uZmlnLnRvRmllbGQgJiYgY29uZmlnLmZyb21GaWVsZCA/IGBTaG93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiAke2NvbmZpZy5mcm9tRmllbGR9IGFuZCAke2NvbmZpZy50b0ZpZWxkfSB0aHJvdWdoIHRoZSAke2NvbmZpZy50b25lRGVzY3JpcHRpb259IG1lc3NhZ2UgdG9uZWAgOiBcIlwifVxuLSAke2NvbmZpZy5mcm9tRmllbGQgPyBgQUxXQVlTIGVuZCB3aXRoIGFuIGFwcHJvcHJpYXRlIGNsb3NpbmcgYW5kIHNpZ25hdHVyZS4gRXhhbXBsZXM6XFxuICAtIFJvbWFudGljOiBcIldpdGggYWxsIG15IGxvdmUsICR7Y29uZmlnLmZyb21GaWVsZH1cIiBvciBcIkZvcmV2ZXIgeW91cnMsICR7Y29uZmlnLmZyb21GaWVsZH1cIlxcbiAgLSBGcmllbmRseTogXCJCZXN0LCAke2NvbmZpZy5mcm9tRmllbGR9XCIgb3IgXCJDaGVlcnMsICR7Y29uZmlnLmZyb21GaWVsZH1cIiBvciBcIllvdXIgZnJpZW5kLCAke2NvbmZpZy5mcm9tRmllbGR9XCJcXG4gIC0gRmFtaWx5OiBcIkxvdmUsICR7Y29uZmlnLmZyb21GaWVsZH1cIiBvciBcIkh1Z3MsICR7Y29uZmlnLmZyb21GaWVsZH1cIlxcbiAgLSBQcm9mZXNzaW9uYWw6IFwiQmVzdCByZWdhcmRzLCAke2NvbmZpZy5mcm9tRmllbGR9XCIgb3IgXCJTaW5jZXJlbHksICR7Y29uZmlnLmZyb21GaWVsZH1cIlxcbiAgLSBGdW5ueTogXCJZb3VyIGZhdm9yaXRlIHRyb3VibGVtYWtlciwgJHtjb25maWcuZnJvbUZpZWxkfVwiIG9yIFwiU3RheSBhd2Vzb21lLCAke2NvbmZpZy5mcm9tRmllbGR9XCJgIDogXCJFbmQgd2l0aCBhbiBhcHByb3ByaWF0ZSBjbG9zaW5nIChCZXN0IHdpc2hlcywgV2FybSByZWdhcmRzLCBldGMuKVwifVxuXG5SZXR1cm4gT05MWSB0aGUgbWVzc2FnZSB0ZXh0IHRoYXQgc2hvdWxkIGFwcGVhciBpbnNpZGUgdGhlIGNhcmQgLSBubyBxdW90ZXMsIG5vIGV4cGxhbmF0aW9ucywgbm8gbWFya2Rvd24gZm9ybWF0dGluZyAobm8gKmJvbGQqLCBfaXRhbGljc18sIG9yIG90aGVyIG1hcmtkb3duKSwganVzdCB0aGUgY29tcGxldGUgJHtjb25maWcudG9uZURlc2NyaXB0aW9ufSBtZXNzYWdlIGluIHBsYWluIHRleHQuXG5cbklNUE9SVEFOVDogV3JhcCB5b3VyIGZpbmFsIG1lc3NhZ2UgaW4gPE1FU1NBR0U+IDwvTUVTU0FHRT4gdGFncy4gRXZlcnl0aGluZyBvdXRzaWRlIHRoZXNlIHRhZ3Mgd2lsbCBiZSBpZ25vcmVkLmA7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSByZW1haW5pbmcgcHJvbXB0cyBiYXNlZCBvbiBleGlzdGluZyBmcm9udCBjb3ZlclxuICBzdGF0aWMgZ2VuZXJhdGVGaW5hbEZyb21EcmFmdFByb21wdHMoY29uZmlnOiBGaW5hbEZyb21EcmFmdENvbmZpZyk6IENhcmRQcm9tcHRzIHtcbiAgICBjb25zdCBjYXJkVHlwZUZvclByb21wdCA9IGNvbmZpZy5jdXN0b21DYXJkVHlwZSB8fCBjb25maWcuY2FyZFR5cGU7XG4gICAgY29uc3QgZWZmZWN0aXZlUHJvbXB0ID0gY29uZmlnLnRoZW1lIHx8IGBBIGJlYXV0aWZ1bCAke2NhcmRUeXBlRm9yUHJvbXB0fSBjYXJkYDtcbiAgICBjb25zdCBzdHlsZU1vZGlmaWVyID0gY29uZmlnLmFydGlzdGljU3R5bGU/LnByb21wdE1vZGlmaWVyIHx8ICcnO1xuXG4gICAgLy8gRm9yIG5vdywga2VlcCB0aGUgZXhpc3RpbmcgaW5kaXZpZHVhbCBnZW5lcmF0aW9uIGFwcHJvYWNoXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbWJpbmVkIGdlbmVyYXRpb24gd2l0aCBBSSBjaGF0XG4gICAgY29uc3QgYmFja0NvdmVyID0gdGhpcy5nZW5lcmF0ZUJhY2tDb3ZlclByb21wdEZyb21Gcm9udChjb25maWcuZnJvbnRDb3ZlclByb21wdCwgc3R5bGVNb2RpZmllciwgY29uZmlnLmNhcmRUeXBlKTtcbiAgICBcbiAgICBjb25zdCBwcm9tcHRzOiBDYXJkUHJvbXB0cyA9IHtcbiAgICAgIGZyb250Q292ZXI6IGNvbmZpZy5mcm9udENvdmVyUHJvbXB0LCAvLyBLZWVwIGV4aXN0aW5nIGZyb250IGNvdmVyXG4gICAgICBiYWNrQ292ZXJcbiAgICB9O1xuXG4gICAgaWYgKCFjb25maWcuaXNGcm9udEJhY2tPbmx5KSB7XG4gICAgICBwcm9tcHRzLmxlZnRJbnRlcmlvciA9IHRoaXMuZ2VuZXJhdGVMZWZ0SW50ZXJpb3JQcm9tcHRGcm9tRnJvbnQoY29uZmlnLmZyb250Q292ZXJQcm9tcHQsIHN0eWxlTW9kaWZpZXIsIGNvbmZpZy5jYXJkVHlwZSk7XG4gICAgICBwcm9tcHRzLnJpZ2h0SW50ZXJpb3IgPSB0aGlzLmdlbmVyYXRlUmlnaHRJbnRlcmlvclByb21wdEZyb21Gcm9udChcbiAgICAgICAgY29uZmlnLmZyb250Q292ZXJQcm9tcHQsXG4gICAgICAgIGNvbmZpZy5tZXNzYWdlIHx8ICcnLFxuICAgICAgICBjb25maWcuaXNIYW5kd3JpdHRlbk1lc3NhZ2UgfHwgZmFsc2UsXG4gICAgICAgIHN0eWxlTW9kaWZpZXIsXG4gICAgICAgIGNvbmZpZy5jYXJkVHlwZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbXB0cztcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGFsbCBub24tZnJvbnQgcHJvbXB0cyBpbiBhIHNpbmdsZSBBSSBjYWxsIGZvciBiZXR0ZXIgY29oZXNpb25cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlRmluYWxGcm9tRHJhZnRQcm9tcHRzQ29tYmluZWQoY29uZmlnOiBGaW5hbEZyb21EcmFmdENvbmZpZyk6IFByb21pc2U8Q2FyZFByb21wdHM+IHtcbiAgICBjb25zdCBjYXJkVHlwZUZvclByb21wdCA9IGNvbmZpZy5jdXN0b21DYXJkVHlwZSB8fCBjb25maWcuY2FyZFR5cGU7XG4gICAgY29uc3QgZGVuc2l0eSA9IHRoaXMuZ2V0VmlzdWFsRGVuc2l0eShjb25maWcuY2FyZFR5cGUpO1xuICAgIFxuICAgIC8vIEltcG9ydCBjaGF0V2l0aEFJIGR5bmFtaWNhbGx5IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IHsgY2hhdFdpdGhBSSB9ID0gYXdhaXQgaW1wb3J0KCcuLi9ob29rcy9jYXJkU3R1ZGlvL3V0aWxzJyk7XG4gICAgXG4gICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gYFlvdSBhcmUgYW4gZXhwZXJ0IGdyZWV0aW5nIGNhcmQgZGVzaWduZXIuIEdlbmVyYXRlIGNvaGVzaXZlIGltYWdlIHByb21wdHMgZm9yIHRoZSBiYWNrIGNvdmVyLCBsZWZ0IGludGVyaW9yLCBhbmQgcmlnaHQgaW50ZXJpb3Igb2YgYSBncmVldGluZyBjYXJkLiBUaGUgZnJvbnQgY292ZXIgaGFzIGFscmVhZHkgYmVlbiBkZXNpZ25lZCwgYW5kIHlvdSBuZWVkIHRvIGNyZWF0ZSBwcm9tcHRzIHRoYXQgY29tcGxlbWVudCBpdCB3aGlsZSBmb2xsb3dpbmcgc3BlY2lmaWMgZGVzaWduIHJlcXVpcmVtZW50cy5gO1xuICAgIFxuICAgIGNvbnN0IHVzZXJNZXNzYWdlID0gYEdlbmVyYXRlIHByb21wdHMgZm9yIHRoZSByZW1haW5pbmcgcGFuZWxzIG9mIGEgJHtjYXJkVHlwZUZvclByb21wdH0gZ3JlZXRpbmcgY2FyZC5cblxuQ09OVEVYVCAtIEZST05UIENPVkVSIChhbHJlYWR5IGRlc2lnbmVkKTpcblwiJHtjb25maWcuZnJvbnRDb3ZlclByb21wdH1cIlxuXG5JTVBPUlRBTlQ6IFRoZSBhYm92ZSBmcm9udCBjb3ZlciBkZXNjcmlwdGlvbiBpcyBwcm92aWRlZCBhcyBDT05URVhUIE9OTFkuIFlvdSBzaG91bGQgZXh0cmFjdCB0aGUgY29sb3IgcGFsZXR0ZSwgYXJ0aXN0aWMgc3R5bGUsIGFuZCBvdmVyYWxsIGFlc3RoZXRpYyBmcm9tIGl0LCBidXQgRE8gTk9UIGNvcHkgY2hhcmFjdGVycywgcGVvcGxlLCBvciBzcGVjaWZpYyBzY2VuZXMgdG8gb3RoZXIgcGFuZWxzLlxuXG5DQVJEIERFVEFJTFM6XG4tIENhcmQgVHlwZTogJHtjYXJkVHlwZUZvclByb21wdH1cbi0gTWVzc2FnZSBzcGFjZSBuZWVkZWQ6ICR7Y29uZmlnLmlzSGFuZHdyaXR0ZW5NZXNzYWdlID8gJ1llcyAoYmxhbmsgc3BhY2UgZm9yIGhhbmR3cml0aW5nKScgOiAnWWVzIChmb3IgcHJvdmlkZWQgbWVzc2FnZSknfVxuLSBTdHlsZSBNb2RpZmllcjogJHtjb25maWcuYXJ0aXN0aWNTdHlsZT8ucHJvbXB0TW9kaWZpZXIgfHwgJ0RlZmF1bHQgc3R5bGUnfVxuXG5WSVNVQUwgREVOU0lUWSBSRVFVSVJFTUVOVFM6XG4tIEJhY2sgQ292ZXI6ICR7ZGVuc2l0eS5iYWNrfSUgZGVjb3JhdGlvbiAodmVyeSBtaW5pbWFsKVxuLSBMZWZ0IEludGVyaW9yOiAke2RlbnNpdHkubGVmdEludGVyaW9yfSUgZGVjb3JhdGlvbiAoc3VidGxlLCBjb21wbGVtZW50YXJ5KVxuLSBSaWdodCBJbnRlcmlvcjogJHtkZW5zaXR5LnJpZ2h0SW50ZXJpb3J9JSBkZWNvcmF0aW9uIChtaW5pbWFsLCBtZXNzYWdlLWZvY3VzZWQpXG5cbkNSSVRJQ0FMIFJFUVVJUkVNRU5UUzpcbjEuIE5PIFBFT1BMRSwgQ0hBUkFDVEVSUywgT1IgRklHVVJFUyBvbiBhbnkgaW50ZXJpb3IgcGFnZXMgb3IgYmFjayBjb3ZlclxuMi4gTk8gR1JFRVRJTkcgVEVYVCAobGlrZSBcIkhhcHB5IEJpcnRoZGF5XCIsIFwiVGhhbmsgWW91XCIsIGV0Yy4pIG9uIGJhY2sgY292ZXIgb3IgbGVmdCBpbnRlcmlvciAtIG9ubHkgZGVjb3JhdGl2ZSBlbGVtZW50c1xuMy4gRXh0cmFjdCBPTkxZIGNvbG9ycyBhbmQgYXJ0aXN0aWMgc3R5bGUgZnJvbSB0aGUgZnJvbnQgY292ZXIgY29udGV4dFxuNC4gRWFjaCBwYW5lbCBzaG91bGQgZmVlbCBjb2hlc2l2ZSBidXQgc2VydmUgaXRzIHNwZWNpZmljIHB1cnBvc2VcbjUuIEJhY2sgY292ZXIgbXVzdCBsZWF2ZSBib3R0b20tcmlnaHQgY29ybmVyIGNsZWFyIGZvciBRUiBjb2RlXG42LiBSaWdodCBpbnRlcmlvciBtdXN0IGhhdmUgZWxlZ2FudCBzcGFjZSBmb3IgYSBtZXNzYWdlIChkbyBOT1QgaW5jbHVkZSB0aGUgYWN0dWFsIG1lc3NhZ2UgdGV4dCAtIGp1c3QgY3JlYXRlIHNwYWNlIGZvciBpdClcbjcuIE5FVkVSIGluY2x1ZGUgdGhlIGNhcmQgdHlwZSBncmVldGluZyB0ZXh0IGFueXdoZXJlIGV4Y2VwdCB0aGUgZnJvbnQgY292ZXJcblxuJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9XG4ke3RoaXMuU0FGRVRZX1JFUVVJUkVNRU5UU31gO1xuXG4gICAgY29uc3QganNvblNjaGVtYSA9IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGJhY2tDb3Zlcjoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiQ29tcGxldGUgcHJvbXB0IGZvciBiYWNrIGNvdmVyIGltYWdlIGdlbmVyYXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBsZWZ0SW50ZXJpb3I6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLCBcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJDb21wbGV0ZSBwcm9tcHQgZm9yIGxlZnQgaW50ZXJpb3IgaW1hZ2UgZ2VuZXJhdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0SW50ZXJpb3I6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkNvbXBsZXRlIHByb21wdCBmb3IgcmlnaHQgaW50ZXJpb3IgaW1hZ2UgZ2VuZXJhdGlvblwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wiYmFja0NvdmVyXCIsIFwibGVmdEludGVyaW9yXCIsIFwicmlnaHRJbnRlcmlvclwiXVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0V2l0aEFJKHVzZXJNZXNzYWdlLCB7XG4gICAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi41LXBybycsXG4gICAgICAgIGpzb25TY2hlbWFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXNwb25zZSBzaG91bGQgYWxyZWFkeSBiZSBwYXJzZWQgSlNPTiBkdWUgdG8ganNvblNjaGVtYVxuICAgICAgY29uc3QgcHJvbXB0czogQ2FyZFByb21wdHMgPSB7XG4gICAgICAgIGZyb250Q292ZXI6IGNvbmZpZy5mcm9udENvdmVyUHJvbXB0LFxuICAgICAgICBiYWNrQ292ZXI6IHJlc3BvbnNlLmJhY2tDb3ZlclxuICAgICAgfTtcblxuICAgICAgaWYgKCFjb25maWcuaXNGcm9udEJhY2tPbmx5KSB7XG4gICAgICAgIHByb21wdHMubGVmdEludGVyaW9yID0gcmVzcG9uc2UubGVmdEludGVyaW9yO1xuICAgICAgICBwcm9tcHRzLnJpZ2h0SW50ZXJpb3IgPSByZXNwb25zZS5yaWdodEludGVyaW9yO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBhY3R1YWwgbWVzc2FnZSB0byB0aGUgcmlnaHQgaW50ZXJpb3IgcHJvbXB0XG4gICAgICAgIGlmIChjb25maWcubWVzc2FnZSAmJiAhY29uZmlnLmlzSGFuZHdyaXR0ZW5NZXNzYWdlKSB7XG4gICAgICAgICAgcHJvbXB0cy5yaWdodEludGVyaW9yICs9IGBcXG5cXG5EaXNwbGF5IHRoaXMgZXhhY3QgdGV4dCBpbiBlbGVnYW50LCBjbGVhcmx5IHJlYWRhYmxlIGhhbmR3cml0dGVuIHNjcmlwdDogXCIke2NvbmZpZy5tZXNzYWdlfVwiYDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbXB0cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNvbWJpbmVkIHByb21wdHMsIGZhbGxpbmcgYmFjayB0byBpbmRpdmlkdWFsIGdlbmVyYXRpb246JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRmluYWxGcm9tRHJhZnRQcm9tcHRzKGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyBpbmRpdmlkdWFsIHNlY3Rpb25zXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRnJvbnRDb3ZlclByb21wdChjYXJkVHlwZTogc3RyaW5nLCB0aGVtZTogc3RyaW5nLCBzdHlsZU1vZGlmaWVyOiBzdHJpbmcsIGNvbmZpZzogQ2FyZENvbmZpZyk6IHN0cmluZyB7XG4gICAgLy8gR2VuZXJhdGUgdW5pcXVlIElEIGZvciB0aGlzIHNwZWNpZmljIHBhbmVsXG4gICAgY29uc3QgdW5pcXVlSWQgPSB1dWlkdjQoKTtcbiAgICBcbiAgICBsZXQgcHJvbXB0ID0gYENyZWF0ZSBhIGJlYXV0aWZ1bCBmcm9udCBjb3ZlciBmb3IgYSAke2NhcmRUeXBlfSBncmVldGluZyBjYXJkJHtjb25maWcudG9GaWVsZCA/IGAgZm9yICR7Y29uZmlnLnRvRmllbGR9YCA6ICcnfS4gJHt0aGVtZX0uIEluY2x1ZGUgYXBwcm9wcmlhdGUgZ3JlZXRpbmcgdGV4dCBmb3IgYSAke2NhcmRUeXBlfSBjYXJkJHtjb25maWcudG9GaWVsZCA/IGAgKGNhbiBvcHRpb25hbGx5IGluY2x1ZGUgXCIke2NvbmZpZy50b0ZpZWxkfVwiIGluIHRoZSBncmVldGluZylgIDogJyd9IGluIGVsZWdhbnQgaGFuZHdyaXR0ZW4gc2NyaXB0IHBvc2l0aW9uZWQgaW4gdGhlIGNlbnRlciBhcmVhLiAke3N0eWxlTW9kaWZpZXJ9ICR7dGhpcy5MQVlPVVRfUkVRVUlSRU1FTlRTfSBJTVBPUlRBTlQ6IERvIE5PVCBpbmNsdWRlIFwiZnJvbVwiIG9yIHNlbmRlciBpbmZvcm1hdGlvbiBvbiB0aGUgZnJvbnQgY292ZXIuIFVuaXF1ZSBJRDogJHt1bmlxdWVJZH1gO1xuICAgIFxuICAgIGlmIChjb25maWcucmVmZXJlbmNlSW1hZ2VVcmxzPy5sZW5ndGgpIHtcbiAgICAgIHByb21wdCArPSBgICR7dGhpcy5nZXRFbmhhbmNlZFJlZmVyZW5jZVBob3RvSW5zdHJ1Y3Rpb25zKGNvbmZpZy5waG90b0FuYWx5c2VzKX1gO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHJvbXB0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVCYWNrQ292ZXJQcm9tcHQoc3R5bGVNb2RpZmllcjogc3RyaW5nLCBjYXJkVHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBkZW5zaXR5ID0gdGhpcy5nZXRWaXN1YWxEZW5zaXR5KGNhcmRUeXBlKTtcbiAgICBjb25zdCB1bmlxdWVJZCA9IHV1aWR2NCgpO1xuICAgIHJldHVybiBgQ3JlYXRlIGEgdmVyeSBtaW5pbWFsIGJhY2sgY292ZXIgZGVzaWduIGZvciBhIGdyZWV0aW5nIGNhcmQuIFVzZSBvbmx5ICR7ZGVuc2l0eS5iYWNrfSUgZGVjb3JhdGlvbiAtIHBlcmhhcHMgYSBzaW5nbGUgc21hbGwgbW90aWYsIGEgc3VidGxlIHBhdHRlcm4gYm9yZGVyLCBvciBnZW50bGUgY29sb3Igd2FzaC4gVGhlIGRlc2lnbiBzaG91bGQgYmUgdW5kZXJzdGF0ZWQgYW5kIGVsZWdhbnQsIGxlYXZpbmcgbW9zdCBvZiB0aGUgc3BhY2UgY2xlYW4gYW5kIHBlYWNlZnVsLiBUaGluayBvZiBpdCBhcyBhIHF1aWV0IGVuZGluZyB0byB0aGUgY2FyZCBleHBlcmllbmNlLiBJTVBPUlRBTlQ6IE5PIFBFT1BMRSwgTk8gQ0hBUkFDVEVSUywgTk8gRklHVVJFUywgTk8gVEVYVCwgTk8gV09SRFMsIE5PIEdSRUVUSU5HIC0gb25seSBtaW5pbWFsIGFic3RyYWN0IGRlY29yYXRpdmUgZWxlbWVudHMuICR7c3R5bGVNb2RpZmllcn0gJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9ICR7dGhpcy5RUl9DT0RFX1NQQUNFfSBVbmlxdWUgSUQ6ICR7dW5pcXVlSWR9YDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlTGVmdEludGVyaW9yUHJvbXB0KHN0eWxlTW9kaWZpZXI6IHN0cmluZywgY2FyZFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGVuc2l0eSA9IHRoaXMuZ2V0VmlzdWFsRGVuc2l0eShjYXJkVHlwZSk7XG4gICAgY29uc3QgdW5pcXVlSWQgPSB1dWlkdjQoKTtcbiAgICByZXR1cm4gYENyZWF0ZSBzdWJ0bGUsIGNvbXBsZW1lbnRhcnkgZGVjb3JhdGl2ZSBhcnQgZm9yIHRoZSBsZWZ0IGludGVyaW9yIHBhZ2Ugb2YgYSBncmVldGluZyBjYXJkLiBVc2Ugc29mdCwgbXV0ZWQgdmVyc2lvbnMgb2YgdGhlIGNhcmQncyBjb2xvciBwYWxldHRlLiBLZWVwIGRlY29yYXRpb24gbWluaW1hbCBhbmQgZWxlZ2FudCAtIHRoaW5rICR7ZGVuc2l0eS5sZWZ0SW50ZXJpb3J9JSB2aXN1YWwgZGVuc2l0eSBjb21wYXJlZCB0byB0aGUgZnJvbnQgY292ZXIuIEZvY3VzIG9uIGdlbnRsZSBwYXR0ZXJucywgc29mdCB3YXRlcmNvbG9yIHdhc2hlcywgZGVsaWNhdGUgZmxvcmFscywgb3IgYWJzdHJhY3QgZWxlbWVudHMgdGhhdCB3b24ndCBjb21wZXRlIHdpdGggdGhlIG1lc3NhZ2Ugb24gdGhlIGZhY2luZyBwYWdlLiBJTVBPUlRBTlQ6IE5PIFBFT1BMRSwgTk8gQ0hBUkFDVEVSUywgTk8gRklHVVJFUywgTk8gVEVYVCwgTk8gV09SRFMsIE5PIEdSRUVUSU5HIC0gb25seSBkZWNvcmF0aXZlIGFuZCBhcnRpc3RpYyBlbGVtZW50cy4gJHtzdHlsZU1vZGlmaWVyfSAke3RoaXMuTEFZT1VUX1JFUVVJUkVNRU5UU30gVW5pcXVlIElEOiAke3VuaXF1ZUlkfWA7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVJpZ2h0SW50ZXJpb3JQcm9tcHQobWVzc2FnZTogc3RyaW5nLCBpc0hhbmR3cml0dGVuOiBib29sZWFuLCBzdHlsZU1vZGlmaWVyOiBzdHJpbmcsIGNhcmRUeXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRlbnNpdHkgPSB0aGlzLmdldFZpc3VhbERlbnNpdHkoY2FyZFR5cGUpO1xuICAgIGNvbnN0IGNsZWFuU3BhY2UgPSAxMDAgLSBkZW5zaXR5LnJpZ2h0SW50ZXJpb3I7XG4gICAgY29uc3QgdW5pcXVlSWQgPSB1dWlkdjQoKTtcbiAgICBcbiAgICBpZiAoaXNIYW5kd3JpdHRlbikge1xuICAgICAgcmV0dXJuIGBDcmVhdGUgYW4gZWxlZ2FudCB3cml0aW5nIHNwYWNlIGZvciB0aGUgcmlnaHQgaW50ZXJpb3IgcGFnZS4gQWRkIHZlcnkgc3VidGxlIGRlY29yYXRpdmUgZWxlbWVudHMgLSBwZXJoYXBzIGp1c3QgZGVsaWNhdGUgY29ybmVyIGZsb3VyaXNoZXMgb3IgYSBmYWludCBib3JkZXIuIEtlZXAgJHtjbGVhblNwYWNlfSUgb2YgdGhlIHBhZ2UgY2xlYW4gd2hpdGUvY3JlYW0gc3BhY2UgZm9yIGhhbmR3cml0aW5nLiBUaGUgZGVjb3JhdGlvbiBzaG91bGQgd2hpc3Blciwgbm90IHNob3V0LiBJTVBPUlRBTlQ6IE5PIFBFT1BMRSwgTk8gQ0hBUkFDVEVSUywgTk8gRklHVVJFUyAtIG9ubHkgbWluaW1hbCBkZWNvcmF0aXZlIGVsZW1lbnRzLiAke3N0eWxlTW9kaWZpZXJ9ICR7dGhpcy5MQVlPVVRfUkVRVUlSRU1FTlRTfSBVbmlxdWUgSUQ6ICR7dW5pcXVlSWR9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYENyZWF0ZSB0aGUgcmlnaHQgaW50ZXJpb3IgcGFnZSB3aXRoIHRoaXMgZXhhY3QgbWVzc2FnZSBhcyB0aGUgYWJzb2x1dGUgZm9jYWwgcG9pbnQ6IFwiJHttZXNzYWdlfVwiLiBcbiAgICBcbiR7dGhpcy5URVhUX0xFR0lCSUxJVFlfUkVRVUlSRU1FTlRTfVxuXG5UaGUgbWVzc2FnZSBzaG91bGQgYmUgdGhlIHN0YXIgLSB1c2UgZWxlZ2FudCBoYW5kd3JpdHRlbiBzY3JpcHQgcG9zaXRpb25lZCBwZXJmZWN0bHkgZm9yIHJlYWRpbmcuIEFkZCBvbmx5IG1pbmltYWwgZGVjb3JhdGlvbiAoJHtkZW5zaXR5LnJpZ2h0SW50ZXJpb3J9JSBvZiB0aGUgcGFnZSkgc3VjaCBhczpcbi0gRGVsaWNhdGUgY29ybmVyIGZsb3VyaXNoZXNcbi0gQSBzaW5nbGUgc21hbGwgZGVjb3JhdGl2ZSBlbGVtZW50IGFib3ZlIG9yIGJlbG93IHRoZSB0ZXh0XG4tIFZlcnkgc3VidGxlIGJhY2tncm91bmQgdGV4dHVyZSBvciBzb2Z0IGNvbG9yIHdhc2hcbi0gVGhpbiwgZWxlZ2FudCBib3JkZXIgZWxlbWVudHNcblxuVGhlIGRlY29yYXRpb24gc2hvdWxkIGVuaGFuY2UgdGhlIG1lc3NhZ2UsIG5vdCBjb21wZXRlIHdpdGggaXQuIFRoaW5rIG9mIGEgcHJlbWl1bSB3ZWRkaW5nIGludml0YXRpb24gLSBtb3N0bHkgd2hpdGUgc3BhY2Ugd2l0aCBwZXJmZWN0IHR5cG9ncmFwaHkuIElNUE9SVEFOVDogTk8gUEVPUExFLCBOTyBDSEFSQUNURVJTLCBOTyBGSUdVUkVTIC0gb25seSBtaW5pbWFsIGRlY29yYXRpdmUgZWxlbWVudHMuICR7c3R5bGVNb2RpZmllcn0gJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9IFVuaXF1ZSBJRDogJHt1bmlxdWVJZH1gO1xuICB9XG5cbiAgLy8gTWV0aG9kcyBmb3IgZ2VuZXJhdGluZyBmcm9tIGV4aXN0aW5nIGZyb250IGNvdmVyXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlQmFja0NvdmVyUHJvbXB0RnJvbUZyb250KGZyb250UHJvbXB0OiBzdHJpbmcsIHN0eWxlTW9kaWZpZXI6IHN0cmluZywgY2FyZFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGVuc2l0eSA9IHRoaXMuZ2V0VmlzdWFsRGVuc2l0eShjYXJkVHlwZSk7XG4gICAgLy8gRXh0cmFjdCBzdHlsZSBlbGVtZW50cyBmcm9tIGZyb250IGNvdmVyIGJ1dCBleHBsaWNpdGx5IGV4Y2x1ZGUgYW55IHBlb3BsZS9jaGFyYWN0ZXJzIEFORCBURVhUXG4gICAgcmV0dXJuIGBDcmVhdGUgYSB2ZXJ5IG1pbmltYWwgYmFjayBjb3ZlciBmb3IgYSBncmVldGluZyBjYXJkLiBFeHRyYWN0IE9OTFkgdGhlIGNvbG9yIHBhbGV0dGUgYW5kIGFydGlzdGljIHN0eWxlIGZyb20gdGhpcyBkZXNjcmlwdGlvbiBCVVQgY3JlYXRlIGEgbXVjaCBzaW1wbGVyIGRlc2lnbjogXCIke2Zyb250UHJvbXB0fVwiLiBcbiAgICBcblVzZSBvbmx5ICR7ZGVuc2l0eS5iYWNrfSUgdmlzdWFsIGRlbnNpdHkgLSBwZXJoYXBzIGEgc2luZ2xlIHNtYWxsIGVsZW1lbnQsIHN1YnRsZSBjb3JuZXIgZGV0YWlsLCBvciBzb2Z0IGNvbG9yIGdyYWRpZW50LiBNb3N0IG9mIHRoZSBiYWNrIHNob3VsZCBiZSBjbGVhbiwgcGVhY2VmdWwgc3BhY2UuIFRoaW5rIGVsZWdhbnQgbWluaW1hbGlzbS4gSU1QT1JUQU5UOiBETyBOT1QgaW5jbHVkZSBhbnkgcGVvcGxlLCBjaGFyYWN0ZXJzLCBmaWd1cmVzLCB0ZXh0LCB3b3Jkcywgb3IgZ3JlZXRpbmcgbWVzc2FnZXMuIE5PIFRFWFQgQVQgQUxMIC0gb25seSBtaW5pbWFsIGRlY29yYXRpdmUgZWxlbWVudHMuICR7c3R5bGVNb2RpZmllcn0gJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9ICR7dGhpcy5RUl9DT0RFX1NQQUNFfWA7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUxlZnRJbnRlcmlvclByb21wdEZyb21Gcm9udChmcm9udFByb21wdDogc3RyaW5nLCBzdHlsZU1vZGlmaWVyOiBzdHJpbmcsIGNhcmRUeXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRlbnNpdHkgPSB0aGlzLmdldFZpc3VhbERlbnNpdHkoY2FyZFR5cGUpO1xuICAgIC8vIEV4dHJhY3Qgc3R5bGUgZWxlbWVudHMgZnJvbSBmcm9udCBjb3ZlciBidXQgZXhwbGljaXRseSBleGNsdWRlIGFueSBwZW9wbGUvY2hhcmFjdGVycyBBTkQgVEVYVFxuICAgIHJldHVybiBgQ3JlYXRlIHN1YnRsZSBsZWZ0IGludGVyaW9yIHBhZ2UgYXJ0IGZvciBhIGdyZWV0aW5nIGNhcmQuIEV4dHJhY3QgdGhlIGNvbG9yIHBhbGV0dGUgYW5kIGFydGlzdGljIHN0eWxlIGZyb20gdGhpcyBkZXNjcmlwdGlvbiBCVVQgY3JlYXRlIGEgbXVjaCBzb2Z0ZXIsIG1vcmUgbWluaW1hbCBkZXNpZ24gKCR7ZGVuc2l0eS5sZWZ0SW50ZXJpb3J9JSB2aXN1YWwgZGVuc2l0eSk6IFwiJHtmcm9udFByb21wdH1cIi4gXG4gICAgXG5Vc2UgbXV0ZWQsIHBhc3RlbCB2ZXJzaW9ucyBvZiB0aGUgY29sb3JzLiBGb2N1cyBvbiBnZW50bGUgZWxlbWVudHMgbGlrZSBzb2Z0IHdhdGVyY29sb3Igd2FzaGVzLCBkZWxpY2F0ZSBwYXR0ZXJucywgb3Igc3VidGxlIHRleHR1cmVzLiBUaGlzIHBhZ2Ugc2hvdWxkIGNvbXBsZW1lbnQgYnV0IG5vdCBjb21wZXRlIHdpdGggdGhlIG1lc3NhZ2Ugb24gdGhlIGZhY2luZyBwYWdlLiBJTVBPUlRBTlQ6IE5PIFBFT1BMRSwgTk8gQ0hBUkFDVEVSUywgTk8gRklHVVJFUywgTk8gVEVYVCwgTk8gV09SRFMsIE5PIEdSRUVUSU5HIE1FU1NBR0VTLiBPbmx5IGRlY29yYXRpdmUgZWxlbWVudHMuICR7c3R5bGVNb2RpZmllcn0gJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9YDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlUmlnaHRJbnRlcmlvclByb21wdEZyb21Gcm9udChmcm9udFByb21wdDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGlzSGFuZHdyaXR0ZW46IGJvb2xlYW4sIHN0eWxlTW9kaWZpZXI6IHN0cmluZywgY2FyZFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGlzSGFuZHdyaXR0ZW4pIHtcbiAgICAgIHJldHVybiBgQ3JlYXRlIGFuIGVsZWdhbnQsIG1pbmltYWwgd3JpdGluZyBzcGFjZSBmb3IgdGhlIHJpZ2h0IGludGVyaW9yIG9mIGEgZ3JlZXRpbmcgY2FyZC4gRXh0cmFjdCBPTkxZIHN1YnRsZSBzdHlsZSBoaW50cyBmcm9tOiBcIiR7ZnJvbnRQcm9tcHR9XCIuIFxuICAgICAgXG5LZWVwIDgwJSBvZiB0aGUgcGFnZSBhcyBjbGVhbiB3aGl0ZS9jcmVhbSBzcGFjZSBmb3IgaGFuZHdyaXRpbmcuIEFkZCBvbmx5IHdoaXNwZXItbGlnaHQgZGVjb3JhdGlvbiAtIHBlcmhhcHMgZmFpbnQgY29ybmVyIGZsb3VyaXNoZXMgb3IgYSBkZWxpY2F0ZSBib3JkZXIuIFRoZSBwYWdlIHNob3VsZCBmZWVsIHByZW1pdW0gYW5kIHVuZGVyc3RhdGVkLiBOTyBQRU9QTEUsIE5PIENIQVJBQ1RFUlMsIE5PIEZJR1VSRVMuICR7c3R5bGVNb2RpZmllcn0gJHt0aGlzLkxBWU9VVF9SRVFVSVJFTUVOVFN9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYENyZWF0ZSBhIHJpZ2h0IGludGVyaW9yIHBhZ2Ugd2hlcmUgdGhpcyBtZXNzYWdlIGlzIHRoZSBhYnNvbHV0ZSBzdGFyOiBcIiR7bWVzc2FnZX1cIi4gXG5cblVzZSBzdWJ0bGUgc3R5bGUgZWxlbWVudHMgZnJvbSB0aGUgZnJvbnQgZGVzaWduIGJ1dCBrZWVwIGRlY29yYXRpb24gbWluaW1hbCAoMTAtMjAlIG9mIHBhZ2UpLiBFeHRyYWN0IGNvbG9yIGhpbnRzIGZyb206IFwiJHtmcm9udFByb21wdH1cIi5cblxuJHt0aGlzLlRFWFRfTEVHSUJJTElUWV9SRVFVSVJFTUVOVFN9IFxuXG5UaGluayBwcmVtaXVtIHN0YXRpb25lcnkgLSBtb3N0bHkgd2hpdGUgc3BhY2UsIHBlcmZlY3QgbWVzc2FnZSBwbGFjZW1lbnQsIGFuZCBqdXN0IGEgdG91Y2ggb2YgZWxlZ2FudCBkZWNvcmF0aW9uIChjb3JuZXIgZGV0YWlscywgc21hbGwgZmxvdXJpc2gsIG9yIHNvZnQgd2FzaCkuIFRoZSBtZXNzYWdlIHNob3VsZCBkb21pbmF0ZSB0aGUgdmlzdWFsIGhpZXJhcmNoeS4gTk8gUEVPUExFLCBOTyBDSEFSQUNURVJTLCBOTyBGSUdVUkVTLiAke3N0eWxlTW9kaWZpZXJ9ICR7dGhpcy5MQVlPVVRfUkVRVUlSRU1FTlRTfWA7XG4gIH1cblxuICAvLyBHZXQgdG9uZS1zcGVjaWZpYyBpbnN0cnVjdGlvbnNcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VG9uZVNwZWNpZmljSW5zdHJ1Y3Rpb25zKHRvbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdG9uZUluc3RydWN0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdmdW5ueSc6ICctIEluY2x1ZGUgYXBwcm9wcmlhdGUgaHVtb3IgdGhhdCBmaXRzIHRoZSBvY2Nhc2lvbicsXG4gICAgICAnZ2Vuei1odW1vcic6ICctIFVzZSBHZW5aIGh1bW9yIHdpdGggaW50ZXJuZXQgc2xhbmcsIG1lbWVzLCBhbmQgY2hhb3RpYyBlbmVyZ3kgLSB0aGluayBcIm5vIGNhcFwiLCBcInBlcmlvZHRcIiwgXCJpdFxcJ3MgZ2l2aW5nLi4uXCIsIFwic2xheVwiLCBldGMuIEJlIHVuaGluZ2VkIGJ1dCBlbmRlYXJpbmcnLFxuICAgICAgJ3Byb2Zlc3Npb25hbCc6ICctIEtlZXAgaXQgZm9ybWFsIGFuZCBidXNpbmVzcy1hcHByb3ByaWF0ZScsXG4gICAgICAncm9tYW50aWMnOiAnLSBJbmNsdWRlIGxvdmluZyBhbmQgcm9tYW50aWMgbGFuZ3VhZ2UnLFxuICAgICAgJ3BsYXlmdWwnOiAnLSBVc2UgZnVuIGFuZCBlbmVyZ2V0aWMgbGFuZ3VhZ2UnXG4gICAgfTtcblxuICAgIHJldHVybiB0b25lSW5zdHJ1Y3Rpb25zW3RvbmVdIHx8ICcnO1xuICB9XG5cbiAgLy8gQXBwbHkgcmVmZXJlbmNlIHBob3RvIGluc3RydWN0aW9ucyBpZiB1c2luZyBHUFQtMVxuICBzdGF0aWMgZW5oYW5jZVByb21wdFdpdGhSZWZlcmVuY2VQaG90b3MocHJvbXB0OiBzdHJpbmcsIGhhc1JlZmVyZW5jZVBob3RvczogYm9vbGVhbiwgbW9kZWw/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChoYXNSZWZlcmVuY2VQaG90b3MgJiYgbW9kZWwgPT09ICdncHQtaW1hZ2UtMScpIHtcbiAgICAgIHJldHVybiBgJHtwcm9tcHR9XFxuXFxuJHt0aGlzLlJFRkVSRU5DRV9QSE9UT19JTlNUUlVDVElPTlN9YDtcbiAgICB9XG4gICAgcmV0dXJuIHByb21wdDtcbiAgfVxuXG4gIC8vIEZvcm1hdCBwcm9tcHQgZ2VuZXJhdGlvbiBxdWVyeSBmb3IgSlNPTiByZXNwb25zZVxuICBzdGF0aWMgZm9ybWF0UHJvbXB0R2VuZXJhdGlvblF1ZXJ5KGNvbnRleHQ6IHN0cmluZywgcmVxdWlyZW1lbnRzOiBzdHJpbmcsIGpzb25TdHJ1Y3R1cmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBDcmVhdGUgcHJvbXB0cyBmb3IgYSBncmVldGluZyBjYXJkLlxuXG4ke2NvbnRleHR9XG5cblJlcXVpcmVtZW50czpcbiR7dGhpcy5MQVlPVVRfUkVRVUlSRU1FTlRTfVxuJHt0aGlzLlNBRkVUWV9SRVFVSVJFTUVOVFN9XG4ke3JlcXVpcmVtZW50c31cblxuUmV0dXJuIEpTT046XG4ke2pzb25TdHJ1Y3R1cmV9YDtcbiAgfVxufSJdLCJuYW1lcyI6WyJ2NCIsInV1aWR2NCIsIkNBUkRfVFlQRV9ERU5TSVRJRVMiLCJiYWNrIiwibGVmdEludGVyaW9yIiwicmlnaHRJbnRlcmlvciIsIlByb21wdEdlbmVyYXRvciIsImdldFZpc3VhbERlbnNpdHkiLCJjYXJkVHlwZSIsImRlZmF1bHQiLCJnZXRFbmhhbmNlZFJlZmVyZW5jZVBob3RvSW5zdHJ1Y3Rpb25zIiwicGhvdG9BbmFseXNlcyIsImxlbmd0aCIsInRyaW0iLCJhbmFseXplZFBob3RvcyIsImZpbHRlciIsImEiLCJhbmFseXplZCIsImFuYWx5c2lzRmFpbGVkIiwiYWxsU2VsZWN0ZWRQZW9wbGUiLCJmbGF0TWFwIiwic2VsZWN0ZWRQZW9wbGUiLCJwIiwiaW5jbHVkZUluQ2FyZCIsInRvdGFsRXhjbHVkZWQiLCJyZWR1Y2UiLCJzdW0iLCJleGNsdWRlZENvdW50IiwiaW5zdHJ1Y3Rpb25zIiwibmFtZWRQZW9wbGUiLCJuYW1lIiwiZm9yRWFjaCIsInBlcnNvbiIsImlkeCIsIm5hbWVJbmZvIiwicmVsYXRpb25zaGlwVG9SZWNpcGllbnQiLCJzcGVjaWFsSW5zdHJ1Y3Rpb25zIiwibWFwIiwiam9pbiIsImdlbmVyYXRlQ2FyZFByb21wdHNXaXRoQUkiLCJjb25maWciLCJnZW5lcmF0ZUNhcmRQcm9tcHRzIiwiY2FyZFR5cGVGb3JQcm9tcHQiLCJjdXN0b21DYXJkVHlwZSIsImVmZmVjdGl2ZVByb21wdCIsInRoZW1lIiwic3R5bGVNb2RpZmllciIsImFydGlzdGljU3R5bGUiLCJwcm9tcHRNb2RpZmllciIsInVuaXF1ZUlkIiwiYmFzZUNvbnRleHQiLCJsYWJlbCIsInJlZmVyZW5jZUltYWdlVXJscyIsImZyb250Q292ZXIiLCJnZW5lcmF0ZUZyb250Q292ZXJQcm9tcHQiLCJiYWNrQ292ZXIiLCJnZW5lcmF0ZUJhY2tDb3ZlclByb21wdCIsInByb21wdHMiLCJpc0Zyb250QmFja09ubHkiLCJnZW5lcmF0ZUxlZnRJbnRlcmlvclByb21wdCIsImdlbmVyYXRlUmlnaHRJbnRlcmlvclByb21wdCIsIm1lc3NhZ2UiLCJpc0hhbmR3cml0dGVuTWVzc2FnZSIsImdlbmVyYXRlRHJhZnRQcm9tcHRXaXRoSW1hZ2VzIiwicHJvbXB0IiwiZ2VuZXJhdGVEcmFmdFByb21wdCIsImltYWdlcyIsImlzRHJhZnRWYXJpYXRpb24iLCJ2YXJpYXRpb25JbmRleCIsInVuZGVmaW5lZCIsInNtYXJ0U3R5bGVzIiwidG9GaWVsZCIsInRvbmVMYWJlbCIsInRvbmVEZXNjcmlwdGlvbiIsImdlbmVyYXRlTWVzc2FnZVByb21wdCIsInJlbGF0aW9uc2hpcENvbnRleHQiLCJjb250ZXh0UGFydHMiLCJyZWxhdGlvbnNoaXBGaWVsZCIsInB1c2giLCJhbmFseXNpcyIsInBlb3BsZVdpdGhBZ2UiLCJhcHBhcmVudEFnZSIsInNvbWUiLCJwYXJ0IiwiaW5jbHVkZXMiLCJncm91cFJlbGF0aW9uc2hpcHMiLCJncm91cFJlbGF0aW9uc2hpcCIsImluc3RydWN0aW9uIiwidG9Mb3dlckNhc2UiLCJmcm9tRmllbGQiLCJTQUZFVFlfUkVRVUlSRU1FTlRTIiwiZ2V0VG9uZVNwZWNpZmljSW5zdHJ1Y3Rpb25zIiwidG9uZSIsImdlbmVyYXRlRmluYWxGcm9tRHJhZnRQcm9tcHRzIiwiZ2VuZXJhdGVCYWNrQ292ZXJQcm9tcHRGcm9tRnJvbnQiLCJmcm9udENvdmVyUHJvbXB0IiwiZ2VuZXJhdGVMZWZ0SW50ZXJpb3JQcm9tcHRGcm9tRnJvbnQiLCJnZW5lcmF0ZVJpZ2h0SW50ZXJpb3JQcm9tcHRGcm9tRnJvbnQiLCJnZW5lcmF0ZUZpbmFsRnJvbURyYWZ0UHJvbXB0c0NvbWJpbmVkIiwiZGVuc2l0eSIsImNoYXRXaXRoQUkiLCJzeXN0ZW1Qcm9tcHQiLCJ1c2VyTWVzc2FnZSIsIkxBWU9VVF9SRVFVSVJFTUVOVFMiLCJqc29uU2NoZW1hIiwidHlwZSIsInByb3BlcnRpZXMiLCJkZXNjcmlwdGlvbiIsInJlcXVpcmVkIiwicmVzcG9uc2UiLCJtb2RlbCIsImVycm9yIiwiY29uc29sZSIsIlFSX0NPREVfU1BBQ0UiLCJpc0hhbmR3cml0dGVuIiwiY2xlYW5TcGFjZSIsIlRFWFRfTEVHSUJJTElUWV9SRVFVSVJFTUVOVFMiLCJmcm9udFByb21wdCIsInRvbmVJbnN0cnVjdGlvbnMiLCJlbmhhbmNlUHJvbXB0V2l0aFJlZmVyZW5jZVBob3RvcyIsImhhc1JlZmVyZW5jZVBob3RvcyIsIlJFRkVSRU5DRV9QSE9UT19JTlNUUlVDVElPTlMiLCJmb3JtYXRQcm9tcHRHZW5lcmF0aW9uUXVlcnkiLCJjb250ZXh0IiwicmVxdWlyZW1lbnRzIiwianNvblN0cnVjdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/promptGenerator.ts\n"));

/***/ })

});